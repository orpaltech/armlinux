#
# Build Qt6 framework
#

QT_GIT_ROOT="git://code.qt.io/qt"
QT_RELEASE="6.2"
QT_BRANCH="${QT_RELEASE}"
QT_GIT_TAG=
QT_MODULES=("qtxmlpatterns" "qtimageformats" "qtsvg" "qtdeclarative" "qtquickcontrols2" "qtcharts" "qttranslations" "qttools" "qt5compat" "qtvirtualkeyboard")
QT_ROOT_DIR=${EXTRADIR}/qt-build/qt6
QT_DEVCFG_DIR=${QT_ROOT_DIR}/build/${QT_DEVICE_CONFIG}
QTBASE_URL=${QT_GIT_ROOT}/qtbase.git
QTBASE_SRC_DIR=${QT_ROOT_DIR}/qtbase
QTBASE_OUT_DIR=${QT_DEVCFG_DIR}/qtbase

# version directory is named after the branch
QT_CUSTOM_VER="${QT_RELEASE}"
# here we keep resources needed for Qt customization
QT_PATCH_BASE_DIR=${PATCHDIR}/qt/qt6/${QT_CUSTOM_VER}

QT_TARGET_LOCATION="/usr/local"
QT_TARGET_PREFIX=${QT_TARGET_LOCATION}/qt6pi
QT_HOST_PATH=${QT_ROOT_DIR}/build/x86_64-linux-gnu/qtbase
QT_EXT_PREFIX=${QT_DEVCFG_DIR}/qt6pi
QT_QMAKE=${QT_HOST_PATH}/bin/qmake
QT_CONFIG_MOD=${QT_HOST_PATH}/bin/qt-configure-module

if [ -z "${QT_GIT_TAG}" ] ; then
  QT_DEB_VER="${QT_RELEASE}"
else
  QT_DEB_VER="${QT_RELEASE}-tag-${QT_GIT_TAG}"
fi
QT_DEB_PKG_VER="${QT_DEB_VER}-${QT_DEVICE_CONFIG}-${CONFIG}-${VERSION}"
QT_DEB_PKG="qt-${QT_DEB_PKG_VER}"
QT_DEB_DIR="${DEBS_DIR}/${QT_DEB_PKG}-deb"

QT_CROSS_COMPILE=${QT_CROSS_COMPILE:="$CROSS_COMPILE"}
QT_BUILD="-release"

[[ "${ENABLE_X11}" = yes ]] && QT_XCB_OPTION="-system-xcb" || QT_XCB_OPTION="-no-xcb"

echo -n -e "\n*** Build Settings ***\n"
set -x

# force update sources
QT_UPDATE_SOURCES=${QT_UPDATE_SOURCES:="no"}

# go for a full rebuild
QT_FORCE_REBUILD=${QT_FORCE_REBUILD:="yes"}

set +x

# ----------------------------------------------------------------------------

qt_update()
{
        display_alert "Prepare Qt sources..." "${QT_GIT_ROOT}" "info"

	# make sure Qt root directory exists
	mkdir -p ${QT_ROOT_DIR}

	if [ "${QT_UPDATE_SOURCES}" = yes ] ; then
		echo "Forcing full source update qtbase"
		rm -rf ${QTBASE_SRC_DIR}
	fi

	if [ -d ${QTBASE_SRC_DIR} ] && [ -d ${QTBASE_SRC_DIR}/.git ] ; then
		local old_url=$(git -C ${QTBASE_SRC_DIR} config --get remote.origin.url)
		if [ "${old_url}" != "${QTBASE_URL}" ] ; then
			rm -rf ${QTBASE_SRC_DIR}
		fi
	fi
	if [ -d ${QTBASE_SRC_DIR} ] && [ -d ${QTBASE_SRC_DIR}/.git ] ; then
		# update sources
		echo "Update sources for QtBase..."
		git -C ${QTBASE_SRC_DIR} fetch origin --tags
		[ $? -eq 0 ] || exit $?;

		git -C ${QTBASE_SRC_DIR} reset --hard
		git -C ${QTBASE_SRC_DIR} clean -fdx

		echo "Checking out branch: ${QT_BRANCH}"
		git -C ${QTBASE_SRC_DIR} checkout -B ${QT_BRANCH} origin/${QT_BRANCH}
		[ $? -eq 0 ] || exit $?;

		git -C ${QTBASE_SRC_DIR} pull
	else
		[[ -d ${QTBASE_SRC_DIR} ]] && rm -rf ${QTBASE_SRC_DIR}

		# clone sources
		echo "Clone sources for QtBase..."
		git clone ${QTBASE_URL} -b ${QT_BRANCH} ${QTBASE_SRC_DIR}
		[ $? -eq 0 ] || exit $?;
	fi

	if [ -n "${QT_GIT_TAG}" ] ; then
		echo "Checking out tag: tags/${QT_GIT_TAG}"
		git -C ${QTBASE_SRC_DIR} checkout tags/${QT_GIT_TAG}
		[ $? -eq 0 ] || exit $?;
	fi

	for MODULE in "${QT_MODULES[@]}" ; do
		QT_MODULE_DIR=${QT_ROOT_DIR}/${MODULE}
		QT_MODULE_URL="${QT_GIT_ROOT}/${MODULE}.git"

		if [ "${QT_UPDATE_SOURCES}" = yes ] ; then
			echo "Force full source update ${MODULE}"
			rm -rf ${QT_MODULE_DIR}
		fi

		if [ -d ${QT_MODULE_DIR} ] && [ -d ${QT_MODULE_DIR}/.git ] ; then
			local old_module_url=$(git -C ${QT_MODULE_DIR} config --get remote.origin.url)
			if [ "${old_module_url}" != "${QT_MODULE_URL}" ] ; then
				rm -rf ${QT_MODULE_DIR}
			fi
		fi
		if [ -d ${QT_MODULE_DIR} ] && [ -d ${QT_MODULE_DIR}/.git ] ; then
			# update sources
			git -C ${QT_MODULE_DIR} fetch origin --tags
			[ $? -eq 0 ] || exit $?;

			git -C ${QT_MODULE_DIR} reset --hard
			git -C ${QT_MODULE_DIR} clean -fdx

			echo "Checking out branch: ${QT_BRANCH}"
			git -C ${QT_MODULE_DIR} checkout -B ${QT_BRANCH} origin/${QT_BRANCH}
			[ $? -eq 0 ] || exit $?;

			git -C ${QT_MODULE_DIR} pull
		else
			[[ -d ${QT_MODULE_DIR} ]] && rm -rf ${QT_MODULE_DIR}

			# clone sources
			git clone ${QT_MODULE_URL} -b ${QT_BRANCH} ${QT_MODULE_DIR}
			[ $? -eq 0 ] || exit $?;
		fi

		if [ ! -z "${QT_GIT_TAG}" ] ; then
			echo "Checking out git tag: tags/${QT_GIT_TAG}"
			git -C ${QT_MODULE_DIR} checkout tags/${QT_GIT_TAG}
			[ $? -eq 0 ] || exit $?;
		fi
        done

	display_alert "Sources ready" "release ${QT_RELEASE}" "info"
}

# ----------------------------------------------------------------------------

qt6_apply_patch()
{
	local PATCH_BASE_DIR=${QT_PATCH_BASE_DIR}
	local PATCH_COUNT=$(count_files "${PATCH_BASE_DIR}/qtbase/*.patch")

	echo "Applying patches from '${PATCH_BASE_DIR}' ..."

	# apply qtbase patches
	if [ ${PATCH_COUNT} -gt 0 ] ; then
		echo "Found ${PATCH_COUNT} patches for QtBase ..."
		for PATCH_FILE in ${PATCH_BASE_DIR}/qtbase/*.patch; do
			echo "Applying QtBase patch '${PATCH_FILE}' ..."
			patch -d ${QTBASE_SRC_DIR} --batch -p1 -N < ${PATCH_FILE}
			echo "Patched."
		done
	fi

        for MODULE in "${QT_MODULES[@]}" ; do
		PATCH_COUNT=$(count_files "${PATCH_BASE_DIR}/${MODULE}/*.patch")
		echo "Found ${PATCH_COUNT} patches for ${MODULE} ..."
                # apply module patches
		if [ ${PATCH_COUNT} -gt 0 ] ; then
                    for PATCH_FILE in ${PATCH_BASE_DIR}/${MODULE}/*.patch; do
                        echo "Applying ${MODULE} module patch '${PATCH_FILE}' ..."
                        patch -d ${QT_ROOT_DIR}/${MODULE} --batch -p1 -N < ${PATCH_FILE}
                        echo "Patched."
                    done
		fi
        done

	echo "Done."
}

# ----------------------------------------------------------------------------

qt_make_qtbase()
{
	mkdir -p ${QTBASE_OUT_DIR}
        cd ${QTBASE_OUT_DIR}

        if [ "${QT_FORCE_REBUILD}" = yes ] ; then
		echo "Force rebuild QtBase"
		rm -rf ./*
	fi

        # prepare prefix directories
        mkdir -p ${QT_EXT_PREFIX}
        rm -rf ${QT_EXT_PREFIX}/*

        echo "Configure QtBase..."


	${QTBASE_SRC_DIR}/configure \
			-silent \
			-opensource -confirm-license \
                        ${QT_BUILD} \
			-qt-host-path ${QT_HOST_PATH} \
			-extprefix ${QT_EXT_PREFIX} \
			-prefix ${QT_TARGET_PREFIX} \
                        -device ${QT_DEVICE_CONFIG} \
                        -device-option CROSS_COMPILE=${QT_CROSS_COMPILE} \
                        -sysroot ${SYSROOT_DIR} \
                        -nomake examples \
			-nomake tests \
                        -no-pch \
			-no-rpath \
                        -no-use-gold-linker \
                        -no-openvg \
			-no-cups \
                        ${QT_OPENGL_OPTION} \
			${QT_XCB_OPTION} \
                        -no-openssl \
                        -system-zlib \
                        -system-libjpeg \
                        -system-libpng \
                        -system-freetype \
			-no-sql-db2 -no-sql-ibase -no-sql-mysql -no-sql-oci -no-sql-odbc -no-sql-psql -no-sql-sqlite \
			-- -DQT_BUILD_TOOLS_WHEN_CROSSCOMPILING=ON \
			-DCMAKE_TOOLCHAIN_FILE=${LIBDIR}/boards/${QT_TOOLCHAIN_CMAKE}

        echo "Configured."

	echo "Making QtBase..."

#	chrt -i 0 make -j${NUM_CPU_CORES}
#	[ $? -eq 0 ] || exit $?;
#	make install

	cmake --build . --parallel ${NUM_CPU_CORES}
	cmake --install .

        echo "Make finished."
}

# ----------------------------------------------------------------------------

qt_make_modules()
{
	for MODULE in "${QT_MODULES[@]}" ; do

		echo "Making module '$MODULE'..."
		QT_MODULE_DIR=${QT_ROOT_DIR}/${MODULE}

		mkdir -p ${QT_DEVCFG_DIR}/${MODULE}
		cd ${QT_DEVCFG_DIR}/${MODULE}

		if [ "${QT_FORCE_REBUILD}" = yes ] ; then
			echo "Force rebuilding '${MODULE}'"
			rm -rf ./*
#		else
#			# otherwise delete only makefiles
#			find ./ -type f -name Makefile -exec rm -f {} \;
		fi

#		${QT_QMAKE} -makefile ${QT_MODULE_DIR}/

#		chrt -i 0 make -j${NUM_CPU_CORES}
#		[ $? -eq 0 ] || exit $?;
#		make install
		${QT_CONFIG_MOD} ${QT_MODULE_DIR}/

		cmake --build .
		cmake --install .

		echo "Make finished."
	done
}

# ----------------------------------------------------------------------------

qt_fix_pkgconfig()
{
	local PREFIX=`echo "$QT_TARGET_PREFIX" | sed -e 's/\//\\\\\//g'`
	local EXT_PREFIX=`echo "$QT_EXT_PREFIX" | sed -e 's/\//\\\\\//g'`
	local SRC="prefix=$EXT_PREFIX"
	local DST="prefix=$PREFIX"

	for PCFILE in $QT_EXT_PREFIX/lib/pkgconfig/*.pc ; do
	    sed -i -e 's/'"$SRC"'/'"$DST"'/g' $PCFILE
	done
}

# ----------------------------------------------------------------------------

qt_deploy()
{
	echo "Deploy Qt to target system..."

	mkdir -p ${QT_DEB_DIR}
	dpkg -x ${BASEDIR}/debs/${QT_DEB_PKG}.deb	${QT_DEB_DIR} 2> /dev/null
	mkdir -p ${SYSROOT_DIR}${QT_TARGET_LOCATION}
	rsync -az ${QT_DEB_DIR}${QT_TARGET_PREFIX}	${SYSROOT_DIR}${QT_TARGET_LOCATION}
	${LIBDIR}/make-relativelinks.sh	${SYSROOT_DIR}
	rm -rf ${QT_DEB_DIR}

	cp ${BASEDIR}/debs/${QT_DEB_PKG}.deb	${R}/tmp/
	chroot_exec	dpkg -i	/tmp/${QT_DEB_PKG}.deb
	rm -f ${R}/tmp/${QT_DEB_PKG}.deb

        echo "Done."
}

# ----------------------------------------------------------------------------

qt6_deb_pkg()
{
	echo "Create Qt6 deb package..."

	mkdir -p $QT_DEB_DIR
	rm -rf ${QT_DEB_DIR}/*

	mkdir ${QT_DEB_DIR}/DEBIAN

	cat <<-EOF > ${QT_DEB_DIR}/DEBIAN/control
Package: $QT_DEB_PKG
Version: $QT_DEB_PKG_VER
Maintainer: $MAINTAINER_NAME <$MAINTAINER_EMAIL>
Architecture: all
Priority: optional
Description: This package provides the Qt6 libraries
EOF

	cat <<-EOF > ${QT_DEB_DIR}/DEBIAN/postinst
#!/bin/sh

set -e

case "\$1" in
  configure)
    echo "${QT_TARGET_PREFIX}/lib" > /etc/ld.so.conf.d/qt6.conf
    ldconfig -X
    ;;
esac

exit 0
EOF

	chmod +x ${QT_DEB_DIR}/DEBIAN/postinst

	mkdir -p ${QT_DEB_DIR}${QT_TARGET_LOCATION}
	rsync -az ${QT_EXT_PREFIX}	${QT_DEB_DIR}${QT_TARGET_LOCATION}

	cp ${QTBASE_OUT_DIR}/config.summary ${QT_DEB_DIR}${QT_TARGET_PREFIX}

	dpkg-deb -z0 -b ${QT_DEB_DIR} ${BASEDIR}/debs/${QT_DEB_PKG}.deb
	[ $? -eq 0 ] || exit $?;

	rm -rf ${QT_DEB_DIR}

	echo "Done."
}

# ----------------------------------------------------------------------------

if [[ ${CLEAN} =~ (^|,)"qt"(,|$) ]] ; then
	rm -f ${BASEDIR}/debs/${QT_DEB_PKG}.deb
fi

if [ "${ENABLE_QT}" = yes ] && [ -n "${QT_DEVICE_CONFIG}" ] ; then
	if [ ! -f ${BASEDIR}/debs/${QT_DEB_PKG}.deb ] ; then
		qt_update

		qt6_apply_patch

		qt_make_qtbase

		qt_make_modules

		qt_fix_pkgconfig

		qt6_deb_pkg
	fi

	qt_deploy
fi
