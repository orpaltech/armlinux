From 0b0f29883d3d33cbdcbe5b1b6a6cb328d5f5d872 Mon Sep 17 00:00:00 2001
From: Sergey Suloev <ssuloev@orpaltech.com>
Date: Tue, 19 Jun 2018 12:35:01 +0300
Subject: [PATCH] sunxi: ASoC: Add GY-PCM5102 soundcard driver

---
 sound/soc/sunxi/Kconfig            |   8 ++
 sound/soc/sunxi/Makefile           |   4 +
 sound/soc/sunxi/gy-pcm5102-sound.c | 219 +++++++++++++++++++++++++++++
 3 files changed, 231 insertions(+)
 create mode 100644 sound/soc/sunxi/gy-pcm5102-sound.c

diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 22408bc..24ae60d 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -45,4 +45,12 @@ config SND_SUN4I_SPDIF
 	help
 	  Say Y or M to add support for the S/PDIF audio block in the Allwinner
 	  A10 and affiliated SoCs.
+
+config SND_GY_PCM5102
+	tristate "GY-PCM5102 Soundcard driver for Allwinner SoCs"
+	depends on SND_SUN4I_I2S
+	select SND_SOC_PCM5102A
+	help
+	  Say Y or M if you want to add support for GY-PCM5102 Soundcard.
+
 endmenu
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index 4a9ef67..7d02032 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -4,3 +4,7 @@ obj-$(CONFIG_SND_SUN4I_I2S) += sun4i-i2s.o
 obj-$(CONFIG_SND_SUN4I_SPDIF) += sun4i-spdif.o
 obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
+
+# GY-PCM5102 Soundcard Support
+snd-soc-gy-pcm5102-objs := gy-pcm5102-sound.o
+obj-$(CONFIG_SND_GY_PCM5102) += snd-soc-gy-pcm5102.o
diff --git a/sound/soc/sunxi/gy-pcm5102-sound.c b/sound/soc/sunxi/gy-pcm5102-sound.c
new file mode 100644
index 0000000..7ea3654
--- /dev/null
+++ b/sound/soc/sunxi/gy-pcm5102-sound.c
@@ -0,0 +1,219 @@
+/*
+ * ASoC Driver for GY-PCM5102 soundcard (playback only).
+ *
+ *  Created on:	21-May-2018
+ *  	Author:	Sergey Suloev <ssuloev@orpaltech.com>
+ *
+ * Copyright (C) 2017-2018 ORPAL Technology, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+
+
+static const unsigned int sun4i_i2s_rates[] = {
+        8000, 16000, 32000, 44100, 48000, 88200, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list sun4i_i2s_constraints = {
+	.list	= sun4i_i2s_rates,
+	.count	= ARRAY_SIZE(sun4i_i2s_rates),
+};
+
+static int snd_gy_pcm5102_soundcard_startup(struct snd_pcm_substream *substream)
+{
+	snd_pcm_hw_constraint_list(substream->runtime, 0,
+				SNDRV_PCM_HW_PARAM_RATE,
+				&sun4i_i2s_constraints);
+	return 0;
+}
+
+struct pcm5102_clk_mod {
+	u32	rate;
+	u32	mclk_rate;
+	u32	bclk_ratio;
+};
+
+static struct pcm5102_clk_mod gy_pcm5102_clk_modes[] = {
+	{ .rate = 8000,		.mclk_rate = 3072000,	},
+	{ .rate = 16000,	.mclk_rate = 6144000,	},
+	{ .rate = 32000,	.mclk_rate = 12288000,	},
+	{ .rate = 44100,	.mclk_rate = 11289600,	},
+	{ .rate = 48000,	.mclk_rate = 12288000,	},
+	{ .rate = 88200,	.mclk_rate = 11289600,	},
+	{ .rate = 96000,	.mclk_rate = 12288000,	},
+};
+
+static int snd_gy_pcm5102_soundcard_hw_params(struct snd_pcm_substream *substream,
+					      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct pcm5102_clk_mod *mod = NULL;
+	int ret, i;
+
+	for (i = 0; i < ARRAY_SIZE(gy_pcm5102_clk_modes); i++) {
+		if (gy_pcm5102_clk_modes[i].rate == params_rate(params)) {
+			mod = &gy_pcm5102_clk_modes[i];
+			break;
+		}
+	}
+	if (!mod) {
+		dev_err(card->dev, "Unsupported frame rate: %d\n",
+			params_rate(params));
+		return -EINVAL;
+	}
+
+	/* Set cpu-side sysclk */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mod->mclk_rate,
+				     SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(card->dev, "Failed to set CPU MCLK: %d\n", ret);
+		return ret;
+	}
+
+	if (mod->bclk_ratio) {
+		ret = snd_soc_dai_set_bclk_ratio(cpu_dai, mod->bclk_ratio);
+        	if (ret < 0) {
+			dev_err(card->dev,
+				"Failed to set CPU BCLK ratio: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/* machine stream operations */
+static struct snd_soc_ops gy_pcm5102_soundcard_ops = {
+	.startup	= snd_gy_pcm5102_soundcard_startup,
+	.hw_params	= snd_gy_pcm5102_soundcard_hw_params,
+};
+
+static struct snd_soc_dai_link gy_pcm5102_soundcard_dai = {
+	.name		= "gy-pcm5102-dai",
+	.stream_name	= "gy-pcm5102-stream",
+	.cpu_dai_name	= "sun4i-i2s.0",
+	.codec_dai_name	= "pcm5102a-hifi",
+	.platform_name	= "sun4i-i2s.0",
+	.codec_name	= "pcm5102a",
+	.ops		= &gy_pcm5102_soundcard_ops,
+	.dai_fmt	= SND_SOC_DAIFMT_I2S |
+			  SND_SOC_DAIFMT_CBS_CFS |
+			  SND_SOC_DAIFMT_NB_NF,
+};
+
+//static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+//	SND_SOC_DAPM_LINE("Line In Jacks", NULL),
+//};
+
+//static const struct snd_soc_dapm_route orpal_aapi_audio_map[] = {
+	/* line inputs */
+//	{ "LLINEIN", NULL, "Line In Jacks"},
+//	{ "RLINEIN", NULL, "Line In Jacks"},
+//};
+
+static struct snd_soc_card snd_soc_gy_pcm5102 = {
+	.name		= "gy-pcm5102-sound",
+	.owner		= THIS_MODULE,
+	.dai_link	= &gy_pcm5102_soundcard_dai,
+	.num_links	= 1,
+/*
+	.dapm_widgets	  = wm8731_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(wm8731_dapm_widgets),
+	.dapm_routes	  = orpal_aapi_audio_map,
+	.num_dapm_routes  = ARRAY_SIZE(orpal_aapi_audio_map),*/
+};
+
+static int gy_pcm5102_soundcard_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_soc_card *card;
+	struct snd_soc_dai_link *dai;
+	u32 format;
+	int ret;
+
+	card = devm_kmemdup(dev, &snd_soc_gy_pcm5102,
+			    sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	card->dev = dev;
+	dai = card->dai_link;
+
+	if (dev->of_node) {
+		struct device_node *cpu_node = of_parse_phandle(dev->of_node,
+								"cpu-node", 0);
+		struct device_node *codec_node = of_parse_phandle(dev->of_node,
+								"codec-node", 0);
+
+		if (cpu_node) {
+			dai->cpu_dai_name = NULL;
+			dai->cpu_of_node = cpu_node;
+			dai->platform_name = NULL;
+			dai->platform_of_node = cpu_node;
+		} else
+			if (!dai->cpu_of_node) {
+				dev_err(dev,
+					"Missing property 'cpu-node'\n");
+				return -EINVAL;
+			}
+
+		if (codec_node) {
+			dai->codec_name = NULL;
+			dai->codec_of_node = codec_node;
+		} else
+			if (!dai->codec_of_node) {
+				dev_err(dev,
+					"Missing property 'codec-node'\n");
+				return -EINVAL;
+			}
+	}
+
+	ret = snd_soc_register_card(card);
+	if (ret && ret != -EPROBE_DEFER) {
+		dev_err(dev, "snd_soc_register_card() failed: %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int gy_pcm5102_soundcard_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	return snd_soc_unregister_card(card);
+
+}
+
+static const struct of_device_id gy_pcm5102_soundcard_of_match[] = {
+	{ .compatible = "orpaltech,gy-pcm5102-sound", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, gy_pcm5102_soundcard_of_match);
+
+static struct platform_driver gy_pcm5102_soundcard_driver = {
+	.probe	= gy_pcm5102_soundcard_probe,
+	.remove	= gy_pcm5102_soundcard_remove,
+	.driver	= {
+		.name		= "gy-pcm5102-sound",
+		.of_match_table	= gy_pcm5102_soundcard_of_match,
+	},
+};
+module_platform_driver(gy_pcm5102_soundcard_driver);
+
+MODULE_AUTHOR("Sergey Suloev <ssuloev@orpaltech.com>");
+MODULE_DESCRIPTION("GY-PCM5102 Soundcard kernel module");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:gy-pcm5102-sound");
-- 
2.17.1

