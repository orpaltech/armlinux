From af2412c0e606f5e5412ac9999b45e09edcc530bb Mon Sep 17 00:00:00 2001
From: Sergey Suloev <ssuloev@orpaltech.com>
Date: Tue, 22 May 2018 22:13:05 +0300
Subject: [PATCH] vna: add ORPALTECH AAPi antenna analyzer driver

---
 drivers/Kconfig                |   2 +
 drivers/Makefile               |   2 +
 drivers/vna/Kconfig            |  16 ++
 drivers/vna/Makefile           |   8 +
 drivers/vna/orpal_aapi_drv.c   | 311 +++++++++++++++++++++++++++++++++
 drivers/vna/orpal_aapi_drv.h   |  34 ++++
 drivers/vna/orpal_aapi_sysfs.c |  90 ++++++++++
 drivers/vna/orpal_aapi_sysfs.h |  18 ++
 8 files changed, 481 insertions(+)
 create mode 100644 drivers/vna/Kconfig
 create mode 100644 drivers/vna/Makefile
 create mode 100644 drivers/vna/orpal_aapi_drv.c
 create mode 100644 drivers/vna/orpal_aapi_drv.h
 create mode 100644 drivers/vna/orpal_aapi_sysfs.c
 create mode 100644 drivers/vna/orpal_aapi_sysfs.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 95b9ccc..9776d65 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -217,4 +217,6 @@ source "drivers/siox/Kconfig"
 
 source "drivers/slimbus/Kconfig"
 
+source "drivers/vna/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 24cd470..3d49264 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -185,3 +185,5 @@ obj-$(CONFIG_TEE)		+= tee/
 obj-$(CONFIG_MULTIPLEXER)	+= mux/
 obj-$(CONFIG_UNISYS_VISORBUS)	+= visorbus/
 obj-$(CONFIG_SIOX)		+= siox/
+
+obj-y				+= vna/
diff --git a/drivers/vna/Kconfig b/drivers/vna/Kconfig
new file mode 100644
index 0000000..4547d54
--- /dev/null
+++ b/drivers/vna/Kconfig
@@ -0,0 +1,16 @@
+#
+# VNA
+#
+
+menu "VNA Subsystem"
+
+config VNA_ORPAL_AAPI
+	tristate "ORPAL AAPi antenna analyzer"
+	depends on ARCH_SUNXI || ARCH_BCM2835
+	depends on COMMON_CLK
+	select SND_ORPAL_AAPI
+	select CLK_ORPAL_AAPI
+	help
+	  This option enables ORPAL AAPi antenna analyzer.
+
+endmenu
diff --git a/drivers/vna/Makefile b/drivers/vna/Makefile
new file mode 100644
index 0000000..e47ea92
--- /dev/null
+++ b/drivers/vna/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for kernel VNA drivers.
+#
+
+vna-orpal-aapi-objs := orpal_aapi_drv.o \
+			orpal_aapi_sysfs.o
+obj-$(CONFIG_VNA_ORPAL_AAPI) += vna-orpal-aapi.o
diff --git a/drivers/vna/orpal_aapi_drv.c b/drivers/vna/orpal_aapi_drv.c
new file mode 100644
index 0000000..6c4af10
--- /dev/null
+++ b/drivers/vna/orpal_aapi_drv.c
@@ -0,0 +1,311 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for ORPAL AA-Pi antenna analyzer (VNA)
+ *
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#include "orpal_aapi_drv.h"
+#include "orpal_aapi_sysfs.h"
+
+static DEFINE_IDA(orpal_aapi_ida_dev);
+static struct class *orpal_aapi_class;
+
+ATTRIBUTE_GROUPS(orpal_aapi);
+
+static int orpal_aapi_set_clock(struct clk *clk, u32 rate)
+{
+	int ret;
+
+	ret = clk_round_rate(clk, rate);
+	if (ret < 0)
+		return ret;
+
+	/* A rounded rate value will be passed */
+	ret = clk_set_rate(clk, ret);
+
+	return ret;
+}
+
+int orpal_aapi_set_measure_freq(struct orpal_aapi_device *aapi, u32 measure_freq)
+{
+        u32 lo_freq;
+        int ret;
+
+	lo_freq = measure_freq + aapi->interm_freq;
+
+	// TODO: verify rates
+
+	ret = orpal_aapi_set_clock(aapi->clk0, measure_freq);
+	if (ret)
+		return ret;
+
+	ret = orpal_aapi_set_clock(aapi->clk1, lo_freq);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void orpal_aapi_dev_release(struct device *dev)
+{
+	struct orpal_aapi_device *aapi = dev_get_drvdata(dev);
+
+	ida_simple_remove(&orpal_aapi_ida_dev, aapi->id);
+
+	kfree(aapi);
+}
+
+static struct device_type orpal_aapi_devtype = {
+	.name	= "aapi_device",
+	.release = orpal_aapi_dev_release,
+};
+
+static int orpal_aapi_runtime_resume(struct device *dev)
+{
+	struct orpal_aapi_device *aapi = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(aapi->clk0);
+	if (ret) {
+		dev_err(dev, "Couldn't enable CLK0 clock\n");
+		goto err_exit;
+	}
+
+	ret = clk_prepare_enable(aapi->clk1);
+	if (ret) {
+		dev_err(dev, "Couldn't enable CLK1 clock\n");
+		goto err;
+	}
+
+	return 0;
+
+err:
+	clk_disable_unprepare(aapi->clk0);
+err_exit:
+	return ret;
+}
+
+static int orpal_aapi_runtime_suspend(struct device *dev)
+{
+	struct orpal_aapi_device *aapi = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(aapi->clk0);
+	clk_disable_unprepare(aapi->clk1);
+
+        return 0;
+}
+
+static int orpal_aapi_read_dt(struct device *dev, struct orpal_aapi_device *aapi)
+{
+	int ret;
+	u32 initial_freq;
+
+	aapi->clk0 = devm_clk_get(dev, "clk0");
+	if (IS_ERR(aapi->clk0)) {
+		ret = PTR_ERR(aapi->clk0);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Unable to acquire CLK0 clock\n");
+		else
+			dev_err(dev, "Deferred access to CLK0 clock\n");
+		return ret;
+        }
+
+	aapi->clk1 = devm_clk_get(dev, "clk1");
+	if (IS_ERR(aapi->clk1)) {
+		ret = PTR_ERR(aapi->clk1);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Unable to acquire CLK1 clock\n");
+		else
+			dev_err(dev, "Deferred access to CLK1 clock\n");
+		return ret;
+	}
+
+	ret = device_property_read_u32(dev, "intermediate-frequency",
+				       &aapi->interm_freq);
+	if (ret) {
+		dev_err(dev,
+			"Intermediate frequency not specified\n");
+                return ret;
+        }
+
+	ret = device_property_read_u32(dev, "initial-frequency",
+				       &initial_freq);
+	if (ret) {
+		dev_warn(dev, "Initial frequency not specified\n");
+	} else {
+		ret = orpal_aapi_set_measure_freq(aapi, initial_freq);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static struct orpal_aapi_device *orpal_aapi_dev_init(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct orpal_aapi_device *aapi;
+	int id;
+	int ret;
+
+	id = ida_simple_get(&orpal_aapi_ida_dev, 0, 0, GFP_KERNEL);
+	if (id < 0)
+		return ERR_PTR(id);
+
+	aapi = devm_kzalloc(dev, sizeof(*aapi), GFP_KERNEL);
+	if (!aapi) {
+		ret = -ENOMEM;
+		goto err_free_id;
+	}
+
+	ret = orpal_aapi_read_dt(dev, aapi);
+	if (ret)
+		goto err_free_id;
+
+	dev_set_name(&aapi->dev, DEV_NAME "%d", id);
+	aapi->id = id;
+	aapi->dev.parent = &pdev->dev;
+	aapi->dev.class = orpal_aapi_class;
+	aapi->dev.type = &orpal_aapi_devtype;
+	aapi->dev.groups = orpal_aapi_groups;
+
+	ret = device_register(&aapi->dev);
+	if (ret < 0)
+		goto err_dev;
+
+	return aapi;
+
+err_dev:
+	put_device(&aapi->dev);
+err_free_id:
+	ida_simple_remove(&orpal_aapi_ida_dev, id);
+
+	return ERR_PTR(ret);
+}
+
+static int orpal_aapi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct orpal_aapi_device *aapi;
+	int ret;
+
+	aapi = orpal_aapi_dev_init(pdev);
+	if (IS_ERR(aapi)) {
+		ret = PTR_ERR(aapi);
+		if (ret != -EPROBE_DEFER) {
+			dev_err(dev, "%s: device init failed: %d\n",
+				__func__, ret);
+		}
+		return ret;
+	}
+	platform_set_drvdata(pdev, aapi);
+
+	/*
+	 * This wake-up/shutdown pattern is to be able to have the
+	 * device woken up, even if runtime_pm is disabled
+	 */
+	ret = orpal_aapi_runtime_resume(dev);
+	if (ret) {
+		dev_err(dev, "Couldn't resume the device\n");
+		goto err_exit;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_exit:
+	device_unregister(&aapi->dev);
+	return ret;
+}
+
+static int orpal_aapi_remove(struct platform_device *pdev)
+{
+	struct orpal_aapi_device *aapi = platform_get_drvdata(pdev);
+
+	pm_runtime_force_suspend(&pdev->dev);
+
+	device_unregister(&aapi->dev);
+
+	return 0;
+}
+
+static const struct of_device_id orpal_aapi_match[] = {
+	{ .compatible = "orpaltech,aapi-160", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, orpal_aapi_match);
+
+static const struct dev_pm_ops orpal_aapi_pm_ops = {
+	.runtime_resume	  = orpal_aapi_runtime_resume,
+	.runtime_suspend  = orpal_aapi_runtime_suspend,
+};
+
+static struct platform_driver orpal_aapi_driver = {
+	.probe  = orpal_aapi_probe,
+	.remove = orpal_aapi_remove,
+	.driver = {
+		.name		= DEV_NAME,
+		.of_match_table	= orpal_aapi_match,
+		.pm		= &orpal_aapi_pm_ops,
+        },
+};
+
+static int __init orpal_aapi_init(void)
+{
+	int ret;
+
+        orpal_aapi_class = class_create(THIS_MODULE, CLASS_NAME);
+        if (IS_ERR(orpal_aapi_class)) {
+		pr_err("Unable to create class\n");
+                ret = PTR_ERR(orpal_aapi_class);
+		goto err_exit;
+        }
+
+	ret = platform_driver_register(&orpal_aapi_driver);
+	if (ret) {
+		pr_err("Unable to register platform driver\n");
+		goto err_cls;
+	}
+
+	return 0;
+
+err_cls:
+        class_destroy(orpal_aapi_class);
+err_exit:
+	return ret;
+}
+module_init(orpal_aapi_init);
+
+static void __exit orpal_aapi_exit(void)
+{
+	platform_driver_unregister(&orpal_aapi_driver);
+
+	ida_destroy(&orpal_aapi_ida_dev);
+	class_destroy(orpal_aapi_class);
+}
+module_exit(orpal_aapi_exit);
+
+MODULE_AUTHOR("Sergey Suloev <ssuloev@orpaltech.com");
+MODULE_DESCRIPTION("ORPALTECH AAPi antenna analyzer driver (VNA)");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/vna/orpal_aapi_drv.h b/drivers/vna/orpal_aapi_drv.h
new file mode 100644
index 0000000..ec9a056
--- /dev/null
+++ b/drivers/vna/orpal_aapi_drv.h
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for ORPAL AA-Pi antenna analyzer (VNA)
+ *
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef ORPAL_AAPI_DRV_H
+#define ORPAL_AAPI_DRV_H
+
+#define CLASS_NAME	"vna"
+#define DEV_NAME	"aapi"
+
+struct orpal_aapi_device {
+	u32		id;
+	struct device	dev;
+
+	struct clk	*clk0;
+	struct clk	*clk1;
+
+	u32		xtal_freq;
+	u32		initial_freq;
+	u32		interm_freq;
+};
+
+int orpal_aapi_set_measure_freq(struct orpal_aapi_device *aapi,
+				u32 measure_freq);
+
+#endif /* ORPAL_AAPI_DRV_H */
diff --git a/drivers/vna/orpal_aapi_sysfs.c b/drivers/vna/orpal_aapi_sysfs.c
new file mode 100644
index 0000000..85f4e05
--- /dev/null
+++ b/drivers/vna/orpal_aapi_sysfs.c
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for ORPAL AA-Pi antenna analyzer (VNA)
+ *
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/kfifo.h>
+#include <linux/list.h>
+#include <linux/types.h>
+
+#include "orpal_aapi_drv.h"
+
+
+#define to_aapi_device(device)	\
+	container_of(device, struct orpal_aapi_device, dev)
+
+
+static ssize_t measure_freq_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct orpal_aapi_device *aapi = to_aapi_device(dev);
+	u32 rate;
+
+	rate = clk_get_rate(aapi->clk0);
+
+	return sprintf(buf, "%d\n", rate);
+}
+
+static ssize_t measure_freq_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct orpal_aapi_device *aapi = to_aapi_device(dev);
+	u32 measure_freq;
+	int ret;
+
+	ret = kstrtou32(buf, 10, &measure_freq);
+	if (ret < 0)
+		return ret;
+
+	ret = orpal_aapi_set_measure_freq(aapi, measure_freq);
+	if (ret)
+		return ret;
+
+        return count;
+}
+
+static ssize_t local_osc_freq_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct orpal_aapi_device *aapi = to_aapi_device(dev);
+	u32 rate;
+
+	rate = clk_get_rate(aapi->clk1);
+
+	return sprintf(buf, "%d\n", rate);
+}
+
+static ssize_t intermediate_freq_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+        struct orpal_aapi_device *aapi = to_aapi_device(dev);
+
+        return sprintf(buf, "%d\n", aapi->interm_freq);
+}
+
+static DEVICE_ATTR_RW(measure_freq);
+static DEVICE_ATTR_RO(local_osc_freq);
+static DEVICE_ATTR_RO(intermediate_freq);
+
+struct attribute *orpal_aapi_attrs[] = {
+	&dev_attr_measure_freq.attr,
+	&dev_attr_local_osc_freq.attr,
+	&dev_attr_intermediate_freq.attr,
+	NULL,
+};
diff --git a/drivers/vna/orpal_aapi_sysfs.h b/drivers/vna/orpal_aapi_sysfs.h
new file mode 100644
index 0000000..5ca1d11
--- /dev/null
+++ b/drivers/vna/orpal_aapi_sysfs.h
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for ORPAL AA-Pi antenna analyzer (VNA)
+ *
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef ORPAL_AAPI_SYSFS_H
+#define ORPAL_AAPI_SYSFS_H
+
+extern struct attribute *orpal_aapi_attrs[];
+
+#endif /* ORPAL_AAPI_SYSFS_H */
-- 
2.17.0

