From 991565920a6d09970eb23ed0f19b2fb2b76eef2a Mon Sep 17 00:00:00 2001
From: Sergey Suloev <ssuloev@orpaltech.com>
Date: Tue, 29 May 2018 00:53:07 +0300
Subject: [PATCH] sunxi: ASoC: Add I2S support for Allwinner H3 SoC

---
 sound/soc/codecs/wm8731.c   |   26 +-
 sound/soc/sunxi/sun4i-i2s.c | 1914 +++++++++++++++++++++--------------
 sound/soc/sunxi/sun4i-i2s.h |  238 +++++
 3 files changed, 1398 insertions(+), 780 deletions(-)
 create mode 100644 sound/soc/sunxi/sun4i-i2s.h

diff --git a/sound/soc/codecs/wm8731.c b/sound/soc/codecs/wm8731.c
index 7c8fad8..a5a6e36 100644
--- a/sound/soc/codecs/wm8731.c
+++ b/sound/soc/codecs/wm8731.c
@@ -13,6 +13,8 @@
  * published by the Free Software Foundation.
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -346,6 +348,9 @@ static int wm8731_hw_params(struct snd_pcm_substream *substream,
 
 	wm8731->playback_fs = params_rate(params);
 
+	dev_dbg(dai->dev, "%s: codec hw params: srate = %d\n",
+		__func__, srate);
+
 	snd_soc_component_write(component, WM8731_SRATE, srate);
 
 	/* bit size */
@@ -425,7 +430,6 @@ static int wm8731_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 	return 0;
 }
 
-
 static int wm8731_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
@@ -489,9 +493,16 @@ static int wm8731_set_bias_level(struct snd_soc_component *component,
 				 enum snd_soc_bias_level level)
 {
 	struct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);
+	enum snd_soc_bias_level old_level;
 	int ret;
 	u16 reg;
 
+	old_level = snd_soc_component_get_bias_level(component);
+
+	dev_dbg(component->dev,
+		"%s: bias level %d will change to %d\n",
+		__func__, old_level, level);
+
 	switch (level) {
 	case SND_SOC_BIAS_ON:
 		if (wm8731->mclk) {
@@ -503,7 +514,7 @@ static int wm8731_set_bias_level(struct snd_soc_component *component,
 	case SND_SOC_BIAS_PREPARE:
 		break;
 	case SND_SOC_BIAS_STANDBY:
-		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {
+		if (old_level == SND_SOC_BIAS_OFF) {
 			ret = regulator_bulk_enable(ARRAY_SIZE(wm8731->supplies),
 						    wm8731->supplies);
 			if (ret != 0)
@@ -525,6 +536,7 @@ static int wm8731_set_bias_level(struct snd_soc_component *component,
 		regcache_mark_dirty(wm8731->regmap);
 		break;
 	}
+
 	return 0;
 }
 
@@ -538,9 +550,17 @@ static int wm8731_startup(struct snd_pcm_substream *substream,
 					   SNDRV_PCM_HW_PARAM_RATE,
 					   wm8731->constraints);
 
+	dev_dbg(dai->dev, "%s: codec startup\n", __func__);
+
 	return 0;
 }
 
+static void wm8731_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	dev_dbg(dai->dev, "%s: codec shutdown\n", __func__);
+}
+
 #define WM8731_RATES SNDRV_PCM_RATE_8000_96000
 
 #define WM8731_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
@@ -548,6 +568,7 @@ static int wm8731_startup(struct snd_pcm_substream *substream,
 
 static const struct snd_soc_dai_ops wm8731_dai_ops = {
 	.startup	= wm8731_startup,
+	.shutdown	= wm8731_shutdown,
 	.hw_params	= wm8731_hw_params,
 	.digital_mute	= wm8731_mute,
 	.set_sysclk	= wm8731_set_dai_sysclk,
@@ -647,7 +668,6 @@ static const struct of_device_id wm8731_of_match[] = {
 	{ .compatible = "wlf,wm8731", },
 	{ }
 };
-
 MODULE_DEVICE_TABLE(of, wm8731_of_match);
 
 static const struct regmap_config wm8731_regmap = {
diff --git a/sound/soc/sunxi/sun4i-i2s.c b/sound/soc/sunxi/sun4i-i2s.c
index a4aa931..bb99273 100644
--- a/sound/soc/sunxi/sun4i-i2s.c
+++ b/sound/soc/sunxi/sun4i-i2s.c
@@ -1,16 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright (C) 2015 Andrea Venturi
- * Andrea Venturi <be17068@iperbole.bo.it>
+ * ALSA SoC I2S Audio Layer for Allwinner sunXi SoC
  *
- * Copyright (C) 2016 Maxime Ripard
- * Maxime Ripard <maxime.ripard@free-electrons.com>
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  */
 
+#define DEBUG
+
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
 #include <linux/module.h>
@@ -25,192 +26,39 @@
 #include <sound/soc.h>
 #include <sound/soc-dai.h>
 
-#define SUN4I_I2S_CTRL_REG		0x00
-#define SUN4I_I2S_CTRL_SDO_EN_MASK		GENMASK(11, 8)
-#define SUN4I_I2S_CTRL_SDO_EN(sdo)			BIT(8 + (sdo))
-#define SUN4I_I2S_CTRL_MODE_MASK		BIT(5)
-#define SUN4I_I2S_CTRL_MODE_SLAVE			(1 << 5)
-#define SUN4I_I2S_CTRL_MODE_MASTER			(0 << 5)
-#define SUN4I_I2S_CTRL_TX_EN			BIT(2)
-#define SUN4I_I2S_CTRL_RX_EN			BIT(1)
-#define SUN4I_I2S_CTRL_GL_EN			BIT(0)
-
-#define SUN4I_I2S_FMT0_REG		0x04
-#define SUN4I_I2S_FMT0_LRCLK_POLARITY_MASK	BIT(7)
-#define SUN4I_I2S_FMT0_LRCLK_POLARITY_INVERTED		(1 << 7)
-#define SUN4I_I2S_FMT0_LRCLK_POLARITY_NORMAL		(0 << 7)
-#define SUN4I_I2S_FMT0_BCLK_POLARITY_MASK	BIT(6)
-#define SUN4I_I2S_FMT0_BCLK_POLARITY_INVERTED		(1 << 6)
-#define SUN4I_I2S_FMT0_BCLK_POLARITY_NORMAL		(0 << 6)
-#define SUN4I_I2S_FMT0_SR_MASK			GENMASK(5, 4)
-#define SUN4I_I2S_FMT0_SR(sr)				((sr) << 4)
-#define SUN4I_I2S_FMT0_WSS_MASK			GENMASK(3, 2)
-#define SUN4I_I2S_FMT0_WSS(wss)				((wss) << 2)
-#define SUN4I_I2S_FMT0_FMT_MASK			GENMASK(1, 0)
-#define SUN4I_I2S_FMT0_FMT_RIGHT_J			(2 << 0)
-#define SUN4I_I2S_FMT0_FMT_LEFT_J			(1 << 0)
-#define SUN4I_I2S_FMT0_FMT_I2S				(0 << 0)
-#define SUN4I_I2S_FMT0_POLARITY_INVERTED		(1)
-#define SUN4I_I2S_FMT0_POLARITY_NORMAL			(0)
-
-#define SUN4I_I2S_FMT1_REG		0x08
-#define SUN4I_I2S_FIFO_TX_REG		0x0c
-#define SUN4I_I2S_FIFO_RX_REG		0x10
-
-#define SUN4I_I2S_FIFO_CTRL_REG		0x14
-#define SUN4I_I2S_FIFO_CTRL_FLUSH_TX		BIT(25)
-#define SUN4I_I2S_FIFO_CTRL_FLUSH_RX		BIT(24)
-#define SUN4I_I2S_FIFO_CTRL_TX_MODE_MASK	BIT(2)
-#define SUN4I_I2S_FIFO_CTRL_TX_MODE(mode)		((mode) << 2)
-#define SUN4I_I2S_FIFO_CTRL_RX_MODE_MASK	GENMASK(1, 0)
-#define SUN4I_I2S_FIFO_CTRL_RX_MODE(mode)		(mode)
-
-#define SUN4I_I2S_FIFO_STA_REG		0x18
-
-#define SUN4I_I2S_DMA_INT_CTRL_REG	0x1c
-#define SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN	BIT(7)
-#define SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN	BIT(3)
-
-#define SUN4I_I2S_INT_STA_REG		0x20
-
-#define SUN4I_I2S_CLK_DIV_REG		0x24
-#define SUN4I_I2S_CLK_DIV_MCLK_EN		BIT(7)
-#define SUN4I_I2S_CLK_DIV_BCLK_MASK		GENMASK(6, 4)
-#define SUN4I_I2S_CLK_DIV_BCLK(bclk)			((bclk) << 4)
-#define SUN4I_I2S_CLK_DIV_MCLK_MASK		GENMASK(3, 0)
-#define SUN4I_I2S_CLK_DIV_MCLK(mclk)			((mclk) << 0)
-
-#define SUN4I_I2S_RX_CNT_REG		0x28
-#define SUN4I_I2S_TX_CNT_REG		0x2c
-
-#define SUN4I_I2S_TX_CHAN_SEL_REG	0x30
-#define SUN4I_I2S_CHAN_SEL(num_chan)		(((num_chan) - 1) << 0)
-
-#define SUN4I_I2S_TX_CHAN_MAP_REG	0x34
-#define SUN4I_I2S_TX_CHAN_MAP(chan, sample)	((sample) << (chan << 2))
-
-#define SUN4I_I2S_RX_CHAN_SEL_REG	0x38
-#define SUN4I_I2S_RX_CHAN_MAP_REG	0x3c
-
-/* Defines required for sun8i-h3 support */
-#define SUN8I_I2S_CTRL_BCLK_OUT			BIT(18)
-#define SUN8I_I2S_CTRL_LRCK_OUT			BIT(17)
-
-#define SUN8I_I2S_FMT0_LRCK_PERIOD_MASK		GENMASK(17, 8)
-#define SUN8I_I2S_FMT0_LRCK_PERIOD(period)	((period - 1) << 8)
-
-#define SUN8I_I2S_INT_STA_REG		0x0c
-#define SUN8I_I2S_FIFO_TX_REG		0x20
-
-#define SUN8I_I2S_CHAN_CFG_REG		0x30
-#define SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK	GENMASK(6, 4)
-#define SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(chan)	((chan - 1) << 4)
-#define SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK	GENMASK(2, 0)
-#define SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(chan)	(chan - 1)
-
-#define SUN8I_I2S_TX_CHAN_MAP_REG	0x44
-#define SUN8I_I2S_TX_CHAN_SEL_REG	0x34
-#define SUN8I_I2S_TX_CHAN_OFFSET_MASK		GENMASK(13, 11)
-#define SUN8I_I2S_TX_CHAN_OFFSET(offset)	(offset << 12)
-#define SUN8I_I2S_TX_CHAN_EN_MASK		GENMASK(11, 4)
-#define SUN8I_I2S_TX_CHAN_EN(num_chan)		(((1 << num_chan) - 1) << 4)
-
-#define SUN8I_I2S_RX_CHAN_SEL_REG	0x54
-#define SUN8I_I2S_RX_CHAN_MAP_REG	0x58
-
-/**
- * struct sun4i_i2s_quirks - Differences between SoC variants.
- *
- * @has_reset: SoC needs reset deasserted.
- * @has_slave_select_bit: SoC has a bit to enable slave mode.
- * @has_fmt_set_lrck_period: SoC requires lrclk period to be set.
- * @has_chcfg: tx and rx slot number need to be set.
- * @has_chsel_tx_chen: SoC requires that the tx channels are enabled.
- * @has_chsel_offset: SoC uses offset for selecting dai operational mode.
- * @reg_offset_txdata: offset of the tx fifo.
- * @sun4i_i2s_regmap: regmap config to use.
- * @mclk_offset: Value by which mclkdiv needs to be adjusted.
- * @bclk_offset: Value by which bclkdiv needs to be adjusted.
- * @fmt_offset: Value by which wss and sr needs to be adjusted.
- * @field_clkdiv_mclk_en: regmap field to enable mclk output.
- * @field_fmt_wss: regmap field to set word select size.
- * @field_fmt_sr: regmap field to set sample resolution.
- * @field_fmt_bclk: regmap field to set clk polarity.
- * @field_fmt_lrclk: regmap field to set frame polarity.
- * @field_fmt_mode: regmap field to set the operational mode.
- * @field_txchanmap: location of the tx channel mapping register.
- * @field_rxchanmap: location of the rx channel mapping register.
- * @field_txchansel: location of the tx channel select bit fields.
- * @field_rxchansel: location of the rx channel select bit fields.
- */
-struct sun4i_i2s_quirks {
-	bool				has_reset;
-	bool				has_slave_select_bit;
-	bool				has_fmt_set_lrck_period;
-	bool				has_chcfg;
-	bool				has_chsel_tx_chen;
-	bool				has_chsel_offset;
-	unsigned int			reg_offset_txdata;	/* TX FIFO */
-	const struct regmap_config	*sun4i_i2s_regmap;
-	unsigned int			mclk_offset;
-	unsigned int			bclk_offset;
-	unsigned int			fmt_offset;
-
-	/* Register fields for i2s */
-	struct reg_field		field_clkdiv_mclk_en;
-	struct reg_field		field_fmt_wss;
-	struct reg_field		field_fmt_sr;
-	struct reg_field		field_fmt_bclk;
-	struct reg_field		field_fmt_lrclk;
-	struct reg_field		field_fmt_mode;
-	struct reg_field		field_txchanmap;
-	struct reg_field		field_rxchanmap;
-	struct reg_field		field_txchansel;
-	struct reg_field		field_rxchansel;
-};
-
-struct sun4i_i2s {
-	struct clk	*bus_clk;
-	struct clk	*mod_clk;
-	struct regmap	*regmap;
-	struct reset_control *rst;
-
-	unsigned int	mclk_freq;
-
-	struct snd_dmaengine_dai_dma_data	capture_dma_data;
-	struct snd_dmaengine_dai_dma_data	playback_dma_data;
-
-	/* Register fields for i2s */
-	struct regmap_field	*field_clkdiv_mclk_en;
-	struct regmap_field	*field_fmt_wss;
-	struct regmap_field	*field_fmt_sr;
-	struct regmap_field	*field_fmt_bclk;
-	struct regmap_field	*field_fmt_lrclk;
-	struct regmap_field	*field_fmt_mode;
-	struct regmap_field	*field_txchanmap;
-	struct regmap_field	*field_rxchanmap;
-	struct regmap_field	*field_txchansel;
-	struct regmap_field	*field_rxchansel;
-
-	const struct sun4i_i2s_quirks	*variant;
-};
+#include "sun4i-i2s.h"
 
-struct sun4i_i2s_clk_div {
-	u8	div;
-	u8	val;
-};
 
-static const struct sun4i_i2s_clk_div sun4i_i2s_bclk_div[] = {
+static const struct sun4i_i2s_clkdiv sun4i_i2s_bclk_div[] = {
 	{ .div = 2, .val = 0 },
 	{ .div = 4, .val = 1 },
 	{ .div = 6, .val = 2 },
 	{ .div = 8, .val = 3 },
 	{ .div = 12, .val = 4 },
 	{ .div = 16, .val = 5 },
-	/* TODO - extend divide ratio supported by newer SoCs */
+	{ .div = 32, .val = 6 },
+	{ .div = 64, .val = 7 },
+};
+
+static const struct sun4i_i2s_clkdiv sun8i_i2s_clk_div[] = {
+	{ .div = 1, .val = 1 },
+	{ .div = 2, .val = 2 },
+	{ .div = 4, .val = 3 },
+	{ .div = 6, .val = 4 },
+	{ .div = 8, .val = 5 },
+	{ .div = 12, .val = 6 },
+	{ .div = 16, .val = 7 },
+	{ .div = 24, .val = 8 },
+	{ .div = 32, .val = 9 },
+	{ .div = 48, .val = 10 },
+	{ .div = 64, .val = 11 },
+	{ .div = 96, .val = 12 },
+	{ .div = 128, .val = 13 },
+	{ .div = 176, .val = 14 },
+	{ .div = 192, .val = 15 },
 };
 
-static const struct sun4i_i2s_clk_div sun4i_i2s_mclk_div[] = {
+static const struct sun4i_i2s_clkdiv sun4i_i2s_mclk_div[] = {
 	{ .div = 1, .val = 0 },
 	{ .div = 2, .val = 1 },
 	{ .div = 4, .val = 2 },
@@ -219,72 +67,112 @@ static const struct sun4i_i2s_clk_div sun4i_i2s_mclk_div[] = {
 	{ .div = 12, .val = 5 },
 	{ .div = 16, .val = 6 },
 	{ .div = 24, .val = 7 },
-	/* TODO - extend divide ratio supported by newer SoCs */
+	{ .div = 32, .val = 8 },
+	{ .div = 48, .val = 9 },
+	{ .div = 64, .val = 10 },
+};
+
+static int sun4i_i2s_oversample_rates[] = {
+	128,
+	192,
+	256,
+	384,
+	512,
+	768,
 };
 
-static int sun4i_i2s_get_bclk_div(struct sun4i_i2s *i2s,
-				  unsigned int oversample_rate,
-				  unsigned int word_size)
+static bool sun4i_i2s_is_oversample_valid(u32 oversample_rate)
 {
-	int div = oversample_rate / word_size / 2;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_bclk_div); i++) {
-		const struct sun4i_i2s_clk_div *bdiv = &sun4i_i2s_bclk_div[i];
+	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++)
+		if (sun4i_i2s_oversample_rates[i] == oversample_rate)
+			return true;
+
+	return false;
+}
+
+static int sun4i_i2s_get_bclk_div(struct sun4i_i2s *i2s, u32 clk_rate,
+				  u32 channels, u32 sample_rate, u32 word_size)
+{
+	int div, i;
+	u32 bclk_rate, oversample;
+
+	if (i2s->bclk_ratio) {
+		bclk_rate = sample_rate * i2s->bclk_ratio;
+		div = clk_rate / bclk_rate;
+	} else {
+		oversample = clk_rate / sample_rate;
+		div = oversample / word_size / channels;
+
+		bclk_rate = clk_rate / div;
+		/* Calc BCLK ratio to find LRCK/SYNC period later on */
+		i2s->bclk_ratio = bclk_rate / sample_rate;
+	}
 
-		if (bdiv->div == div)
-			return bdiv->val;
+	for (i = 0; i < i2s->quirks->num_bclkdiv; i++) {
+		if (i2s->quirks->bclk_div[i].div == div)
+			return i2s->quirks->bclk_div[i].val;
 	}
 
 	return -EINVAL;
 }
 
-static int sun4i_i2s_get_mclk_div(struct sun4i_i2s *i2s,
-				  unsigned int oversample_rate,
-				  unsigned int module_rate,
-				  unsigned int sampling_rate)
+static int sun4i_i2s_get_mclk_div(struct sun4i_i2s *i2s, u32 clk_rate,
+				  const struct sun4i_i2s_clkdiv *mdiv,
+				  int size)
 {
-	int div = module_rate / sampling_rate / oversample_rate;
+	int div = clk_rate / i2s->mclk_rate;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_mclk_div); i++) {
-		const struct sun4i_i2s_clk_div *mdiv = &sun4i_i2s_mclk_div[i];
-
+	for (i = 0; i < size; i++) {
 		if (mdiv->div == div)
 			return mdiv->val;
+		mdiv++;
 	}
 
 	return -EINVAL;
 }
 
-static int sun4i_i2s_oversample_rates[] = { 128, 192, 256, 384, 512, 768 };
-static bool sun4i_i2s_oversample_is_valid(unsigned int oversample)
+static inline u32 sun4i_i2s_field_get(struct sun4i_i2s *i2s, u32 index)
 {
-	int i;
+	struct regmap_field *field;
+	u32 val;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++)
-		if (sun4i_i2s_oversample_rates[i] == oversample)
-			return true;
+	if (index >= REGMAP_NUM_FIELDS)
+		return 0;
 
-	return false;
+	field = i2s->fields[index];
+	return !regmap_field_read(field, &val) ? val : 0;
 }
 
-static int sun4i_i2s_set_clk_rate(struct snd_soc_dai *dai,
-				  unsigned int rate,
-				  unsigned int word_size)
+static inline void sun4i_i2s_field_set(struct sun4i_i2s *i2s, u32 index, u32 val)
+{
+	struct regmap_field *field;
+
+	if (index >= REGMAP_NUM_FIELDS)
+		return;
+
+	dev_dbg(i2s->dev,
+		"write regmap: field = %d, val = 0x%08x\n",
+		index, val);
+
+	field = i2s->fields[index];
+	regmap_field_write(field, val);
+}
+
+static int sun4i_i2s_setup_pll(struct sun4i_i2s *i2s, u32 sample_rate, u32 *clk_rate)
 {
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	unsigned int oversample_rate, clk_rate;
-	int bclk_div, mclk_div;
 	int ret;
 
-	switch (rate) {
+	/* cpu master */
+	switch (sample_rate) {
 	case 176400:
 	case 88200:
 	case 44100:
 	case 22050:
 	case 11025:
-		clk_rate = 22579200;
+		*clk_rate = 22579200;
 		break;
 
 	case 192000:
@@ -297,324 +185,792 @@ static int sun4i_i2s_set_clk_rate(struct snd_soc_dai *dai,
 	case 16000:
 	case 12000:
 	case 8000:
-		clk_rate = 24576000;
+		*clk_rate = 24576000;
 		break;
 
 	default:
-		dev_err(dai->dev, "Unsupported sample rate: %u\n", rate);
+		dev_err(i2s->dev, "Unsupported frame rate: %u\n",
+			sample_rate);
 		return -EINVAL;
 	}
 
-	ret = clk_set_rate(i2s->mod_clk, clk_rate);
-	if (ret)
+	ret = clk_set_rate(i2s->mod_clk, *clk_rate);
+	if (ret) {
+		dev_err(i2s->dev, "Unable to set PLL rate\n");
 		return ret;
-
-	oversample_rate = i2s->mclk_freq / rate;
-	if (!sun4i_i2s_oversample_is_valid(oversample_rate)) {
-		dev_err(dai->dev, "Unsupported oversample rate: %d\n",
-			oversample_rate);
-		return -EINVAL;
 	}
 
-	bclk_div = sun4i_i2s_get_bclk_div(i2s, oversample_rate,
-					  word_size);
-	if (bclk_div < 0) {
-		dev_err(dai->dev, "Unsupported BCLK divider: %d\n", bclk_div);
-		return -EINVAL;
+	return 0;
+}
+
+static int sun4i_i2s_set_frame_period(struct sun4i_i2s *i2s, u32 channels,
+				      u32 word_size)
+{
+	u32 bclk_ratio;
+	int i, max = 4;
+
+	if (i2s->bclk_ratio) {
+		for (i = 0; i <= max; i++) {
+			bclk_ratio = (1 << (4 + i));
+
+			if (i2s->bclk_ratio < bclk_ratio) {
+				i2s->bclk_ratio = bclk_ratio;
+				break;
+			} else if (i2s->bclk_ratio == bclk_ratio)
+				break;
+		}
+
+		if (i2s->bclk_ratio > bclk_ratio) {
+			i = max;
+			i2s->bclk_ratio = bclk_ratio;
+		}
+
+		regmap_update_bits(i2s->regmap,
+				   SUN4I_I2S_REG_FMT1,
+				   SUN4I_I2S_FMT1_PCM_SYNC_PRD_MASK,
+				   SUN4I_I2S_FMT1_PCM_SYNC_PRD(i));
+
+		dev_dbg(i2s->dev, "%s: SYNC period = %d, BCLK ratio = %d\n",
+			 __func__, i, i2s->bclk_ratio);
+	} else {
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT1,
+				   SUN4I_I2S_FMT1_PCM_SYNC_PRD_MASK,
+				   SUN4I_I2S_FMT1_PCM_SYNC_PRD(max));
 	}
 
-	mclk_div = sun4i_i2s_get_mclk_div(i2s, oversample_rate,
-					  clk_rate, rate);
-	if (mclk_div < 0) {
-		dev_err(dai->dev, "Unsupported MCLK divider: %d\n", mclk_div);
-		return -EINVAL;
+	return 0;
+}
+
+static int sun8i_i2s_set_frame_period(struct sun4i_i2s *i2s, u32 channels,
+				      u32 word_size)
+{
+	u32 lrck_period, min;
+
+	if (i2s->is_pcm) {
+		/* For PCM mode LRCK period includes both channels */
+		min = word_size * channels;
+		channels = 1;
+	} else
+		min = word_size;
+
+	lrck_period = i2s->bclk_ratio / channels;
+	if (lrck_period < min) {
+		lrck_period = min;
+
+	} else if (lrck_period > SUN8I_I2S_LRCK_MAX_PERIOD) {
+		lrck_period = SUN8I_I2S_LRCK_MAX_PERIOD;
 	}
 
-	/* Adjust the clock division values if needed */
-	bclk_div += i2s->variant->bclk_offset;
-	mclk_div += i2s->variant->mclk_offset;
+	i2s->bclk_ratio = lrck_period * channels;
 
-	regmap_write(i2s->regmap, SUN4I_I2S_CLK_DIV_REG,
-		     SUN4I_I2S_CLK_DIV_BCLK(bclk_div) |
-		     SUN4I_I2S_CLK_DIV_MCLK(mclk_div));
+	/* Set LRCK(R) period */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_LRCK_PERIOD_MASK,
+			   SUN8I_I2S_LRCK_PERIOD(lrck_period));
 
-	regmap_field_write(i2s->field_clkdiv_mclk_en, 1);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_LRCKR_PERIOD_MASK,
+			   SUN8I_I2S_LRCKR_PERIOD(lrck_period));
 
-	/* Set sync period */
-	if (i2s->variant->has_fmt_set_lrck_period)
-		regmap_update_bits(i2s->regmap, SUN4I_I2S_FMT0_REG,
-				   SUN8I_I2S_FMT0_LRCK_PERIOD_MASK,
-				   SUN8I_I2S_FMT0_LRCK_PERIOD(32));
+	dev_dbg(i2s->dev,
+		"%s: BCLK ratio = %d, LRCK period = %d\n",
+                __func__, i2s->bclk_ratio, lrck_period);
 
 	return 0;
 }
 
-static int sun4i_i2s_hw_params(struct snd_pcm_substream *substream,
-			       struct snd_pcm_hw_params *params,
-			       struct snd_soc_dai *dai)
+static int sun4i_i2s_set_rate(struct sun4i_i2s *i2s, u32 channels,
+			      u32 sample_rate, u32 word_size)
 {
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	int sr, wss, channels;
-	u32 width;
+	int ret, i;
+	int bclk_div, mclk_div;
+	u32 pll_rate, oversample_rate;
+	u32 bclk_rate;
 
-	channels = params_channels(params);
-	if (channels != 2) {
-		dev_err(dai->dev, "Unsupported number of channels: %d\n",
-			channels);
-		return -EINVAL;
-	}
+	if (i2s->bit_clk_master) {
+		/* CPU bit & frame clk master */
+		ret = sun4i_i2s_setup_pll(i2s, sample_rate, &pll_rate);
+		if (ret)
+			return ret;
 
-	if (i2s->variant->has_chcfg) {
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_CHAN_CFG_REG,
-				   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK,
-				   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(channels));
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_CHAN_CFG_REG,
-				   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK,
-				   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(channels));
+		oversample_rate = i2s->mclk_rate / sample_rate;
+		if (!sun4i_i2s_is_oversample_valid(oversample_rate)) {
+			dev_err(i2s->dev, "Unsupported oversample: %d\n",
+				oversample_rate);
+			return -EINVAL;
+		}
+
+		mclk_div = sun4i_i2s_get_mclk_div(i2s, pll_rate,
+						i2s->quirks->mclk_div,
+						i2s->quirks->num_mclkdiv);
+		if (mclk_div < 0) {
+			dev_err(i2s->dev, "Unsupported MCLK rate\n");
+			return -EINVAL;
+		}
+
+		bclk_div = sun4i_i2s_get_bclk_div(i2s,
+						i2s->quirks->bclk_parent
+							== BCLK_PARENT_PLL ?
+							pll_rate : i2s->mclk_rate,
+						channels,
+						sample_rate,
+						word_size);
+		if (bclk_div < 0) {
+			dev_err(i2s->dev, "Unsupported BCLK divider\n");
+			return -EINVAL;
+		}
+
+		bclk_rate = sample_rate * i2s->bclk_ratio;
+
+		dev_dbg(i2s->dev,
+                        "%s: channels = %d, rate = %d, word = %d, o/sample = %d, PLL = %d, MCLK = %lu, BCLK = %d, BCLK ratio = %d\n",
+                        __func__, channels, sample_rate, word_size, oversample_rate,
+			pll_rate, i2s->mclk_rate, bclk_rate, i2s->bclk_ratio);
+
+		dev_dbg(i2s->dev,
+			"%s: setting dividers: MCLK div = %d, BCLK div = %d\n",
+			 __func__, mclk_div, bclk_div);
+
+		sun4i_i2s_field_set(i2s, FIELD_BCLK_DIV, bclk_div);
+		sun4i_i2s_field_set(i2s, FIELD_MCLK_DIV, mclk_div);
+		sun4i_i2s_field_set(i2s, FIELD_MCLK_OUT_EN, 1);
+
+	} else {
+		/* CPU bit & frame clk slave */
 	}
 
-	/* Map the channels for playback and capture */
-	regmap_field_write(i2s->field_txchanmap, 0x76543210);
-	regmap_field_write(i2s->field_rxchanmap, 0x00003210);
+	return 0;
+}
 
-	/* Configure the channels */
-	regmap_field_write(i2s->field_txchansel,
-			   SUN4I_I2S_CHAN_SEL(params_channels(params)));
+static int sun4i_i2s_set_format(struct sun4i_i2s *i2s, u32 fmt)
+{
+	u32 mode, subm = 0, val;
+	u32 format = (fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+	u32 master = (fmt & SND_SOC_DAIFMT_MASTER_MASK);
 
-	regmap_field_write(i2s->field_rxchansel,
-			   SUN4I_I2S_CHAN_SEL(params_channels(params)));
+	/* DAI Mode */
+	switch (format) {
+	case SND_SOC_DAIFMT_I2S:
+		mode = SUN4I_I2S_CTRL_MODE_I2S;
+		subm = SUN4I_I2S_FMT0_FMT_I2S;
+		break;
 
-	if (i2s->variant->has_chsel_tx_chen)
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_TX_CHAN_SEL_REG,
-				   SUN8I_I2S_TX_CHAN_EN_MASK,
-				   SUN8I_I2S_TX_CHAN_EN(channels));
+	case SND_SOC_DAIFMT_LEFT_J:
+		mode = SUN4I_I2S_CTRL_MODE_I2S;
+		subm = SUN4I_I2S_FMT0_FMT_LEFT_J;
+		break;
 
-	switch (params_physical_width(params)) {
-	case 16:
-		width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		mode = SUN4I_I2S_CTRL_MODE_I2S;
+		subm = SUN4I_I2S_FMT0_FMT_RIGHT_J;
+		break;
+
+	case SND_SOC_DAIFMT_DSP_A:
+		mode = SUN4I_I2S_CTRL_MODE_PCM;
+		subm = SUN4I_I2S_FMT0_DSP_MODE_A;
+		break;
+
+	case SND_SOC_DAIFMT_DSP_B:
+		mode = SUN4I_I2S_CTRL_MODE_PCM;
+		subm = SUN4I_I2S_FMT0_DSP_MODE_B;
 		break;
+
 	default:
-		dev_err(dai->dev, "Unsupported physical sample width: %d\n",
-			params_physical_width(params));
+		dev_err(i2s->dev, "Unsupported format: %d\n",
+			format);
 		return -EINVAL;
 	}
-	i2s->playback_dma_data.addr_width = width;
 
-	switch (params_width(params)) {
-	case 16:
-		sr = 0;
-		wss = 0;
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_MODE_MASK, mode);
+
+	switch (mode) {
+	case SUN4I_I2S_CTRL_MODE_I2S:
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+				   SUN4I_I2S_FMT0_FMT_MASK, subm);
+		break;
+
+	case SUN4I_I2S_CTRL_MODE_PCM:
+		/* Store PCM mode flag */
+		i2s->is_pcm = 1;
+
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+				   SUN4I_I2S_FMT0_DSP_MODE_MASK,
+				   subm);
+
+		/* Set short sync (one BCLK period)*/
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT1,
+				   SUN4I_I2S_PCM_SYNC_WIDTH,
+				   SUN4I_I2S_PCM_SYNC_SHORT);
 		break;
+	}
+
 
+	/* DAI clock master masks */
+	switch (master) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* BCLK and LRCK master */
+		val = SUN4I_I2S_CTRL_MASTER;
+		i2s->bit_clk_master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* BCLK and LRCLK slave */
+		val = SUN4I_I2S_CTRL_SLAVE;
+		i2s->bit_clk_master = 0;
+		break;
 	default:
-		dev_err(dai->dev, "Unsupported sample width: %d\n",
-			params_width(params));
+		dev_err(i2s->dev,
+			"Unsupported master/slave option: %d\n",
+			master);
 		return -EINVAL;
 	}
 
-	regmap_field_write(i2s->field_fmt_wss,
-			   wss + i2s->variant->fmt_offset);
-	regmap_field_write(i2s->field_fmt_sr,
-			   sr + i2s->variant->fmt_offset);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_SLAVE_MASK, val);
 
-	return sun4i_i2s_set_clk_rate(dai, params_rate(params),
-				      params_width(params));
+	return 0;
 }
 
-static int sun4i_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+static int sun8i_i2s_set_format(struct sun4i_i2s *i2s, u32 fmt)
 {
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	u32 val;
-	u32 offset = 0;
-	u32 bclk_polarity = SUN4I_I2S_FMT0_POLARITY_NORMAL;
-	u32 lrclk_polarity = SUN4I_I2S_FMT0_POLARITY_NORMAL;
-
+	u32 mode, val, offset = 0;
+	u32 format = (fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+	u32 master = (fmt & SND_SOC_DAIFMT_MASTER_MASK);
+
+	/*
+	 * The offset indicates that we're connected to an I2S device,
+	 * however offset is only used on sun8i hardware. I2S shares
+	 * the same setting with the LJ format.
+	 */
 	/* DAI Mode */
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	switch (format) {
 	case SND_SOC_DAIFMT_I2S:
-		val = SUN4I_I2S_FMT0_FMT_I2S;
+		mode = SUN8I_I2S_CTRL_MODE_LEFT_J;
 		offset = 1;
 		break;
 	case SND_SOC_DAIFMT_LEFT_J:
-		val = SUN4I_I2S_FMT0_FMT_LEFT_J;
+		mode = SUN8I_I2S_CTRL_MODE_LEFT_J;
 		break;
 	case SND_SOC_DAIFMT_RIGHT_J:
-		val = SUN4I_I2S_FMT0_FMT_RIGHT_J;
+		mode = SUN8I_I2S_CTRL_MODE_RIGHT_J;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		mode = SUN8I_I2S_CTRL_MODE_PCM;
+		offset = 1;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		mode = SUN8I_I2S_CTRL_MODE_PCM;
 		break;
 	default:
-		dev_err(dai->dev, "Unsupported format: %d\n",
-			fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+		dev_err(i2s->dev, "Unsupported format: %d\n",
+			format);
 		return -EINVAL;
 	}
 
-	if (i2s->variant->has_chsel_offset) {
-		/*
-		 * offset being set indicates that we're connected to an i2s
-		 * device, however offset is only used on the sun8i block and
-		 * i2s shares the same setting with the LJ format. Increment
-		 * val so that the bit to value to write is correct.
-		 */
-		if (offset > 0)
-			val++;
-		/* blck offset determines whether i2s or LJ */
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_TX_CHAN_SEL_REG,
-				   SUN8I_I2S_TX_CHAN_OFFSET_MASK,
-				   SUN8I_I2S_TX_CHAN_OFFSET(offset));
-	}
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN8I_I2S_CTRL_MODE_MASK, mode);
+
+	/* BCLK offset determines submode (see datasheet)*/
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_TX_CHAN_SEL,
+			   SUN8I_I2S_TX_CHAN_SEL_OFFSET_MASK,
+			   SUN8I_I2S_TX_CHAN_SEL_OFFSET(offset));
 
-	regmap_field_write(i2s->field_fmt_mode, val);
+	if (mode == SUN8I_I2S_CTRL_MODE_PCM) {
+		/* Store PCM mode flag */
+		i2s->is_pcm = 1;
 
-	/* DAI clock polarity */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_IB_IF:
-		/* Invert both clocks */
-		bclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
-		lrclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
+		/* Set short sync (1 BCLK period)*/
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+				   SUN8I_I2S_PCM_SYNC_WIDTH,
+				   SUN8I_I2S_PCM_SYNC_SHORT);
+	}
+
+	/*
+	 * The newer i2s block does not have a slave select bit,
+	 * instead the clk pins are configured as inputs.
+	 */
+	/* DAI clock master masks */
+	switch (master) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* BCLK and LRCLK master */
+		val = SUN8I_I2S_CTRL_BCLK_OUT |
+		      SUN8I_I2S_CTRL_LRCK_OUT;
+		i2s->bit_clk_master = 1;
 		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		/* Invert bit clock */
-		bclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* BCLK and LRCLK slave */
+		val = 0;
+		i2s->bit_clk_master = 0;
 		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		/* Invert frame clock */
-		lrclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
+	default:
+		dev_err(i2s->dev,
+			"Unsupported master/slave option: %d\n",
+			master);
+		return -EINVAL;
+	}
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN8I_I2S_CTRL_BCLK_OUT |
+			   SUN8I_I2S_CTRL_LRCK_OUT, val);
+
+	return 0;
+}
+
+static int sun4i_i2s_set_hw_config(struct snd_soc_dai *dai,
+				   u32 channels, u32 sample_rate,
+				   u32 sample_size, u32 word_size)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 sr, wss;
+	int i;
+
+	switch (sample_size) {
+	case 16:
+		sr = 0;
+		wss = 0;
 		break;
-	case SND_SOC_DAIFMT_NB_NF:
+	case 20:
+		sr = 1;
+		wss = 1;
+		break;
+	case 24:
+		sr = 2;
+		wss = 2;
 		break;
 	default:
-		dev_err(dai->dev, "Unsupported clock polarity: %d\n",
-			fmt & SND_SOC_DAIFMT_INV_MASK);
+		dev_err(dai->dev, "Unsupported sample size: %d\n",
+			sample_size);
 		return -EINVAL;
 	}
 
-	regmap_field_write(i2s->field_fmt_bclk, bclk_polarity);
-	regmap_field_write(i2s->field_fmt_lrclk, lrclk_polarity);
+	if (word_size > sample_size) {
+		switch (word_size) {
+		case 16:
+			break;
+		case 20:
+			wss = 1;
+			break;
+		case 24:
+			wss = 2;
+			break;
+		case 32:
+			wss = 3;
+			break;
+		default:
+			dev_err(dai->dev, "Unsupported word size: %d\n",
+				word_size);
+			return -EINVAL;
+		}
+	}
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN4I_I2S_FMT0_SR_MASK,
+			   SUN4I_I2S_FMT0_SR(sr));
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN4I_I2S_FMT0_WSS_MASK,
+			   SUN4I_I2S_FMT0_WSS(wss));
+
+	dev_dbg(dai->dev,
+		"%s: channels = %d, rate = %d, sample = %d (sr = %d), word = %d (wss = %d)\n",
+		__func__, channels, sample_rate, sample_size, sr, word_size, wss);
+
+	return 0;
+}
+
+static int sun8i_i2s_set_hw_config(struct snd_soc_dai *dai,
+				   u32 channels, u32 sample_rate,
+				   u32 sample_size, u32 word_size)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 sr, sw;
+
+	/* Set channel config register */
+       	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_CHAN_CFG,
+			   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK,
+			   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(channels));
+
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_CHAN_CFG,
+			   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK,
+			   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(channels));
+
+	/* Enable TX channels */
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_TX_CHAN_SEL,
+			   SUN8I_I2S_TX_CHAN_SEL_EN_MASK,
+			   SUN8I_I2S_TX_CHAN_SEL_EN(channels));
+
+	switch (sample_size) {
+	case 16:
+		sr = 3;
+		sw = 3;
+		break;
+	case 20:
+		sr = 4;
+		sw = 4;
+		break;
+	case 24:
+		sr = 5;
+		sw = 5;
+		break;
+	case 32:
+		sr = 7;
+		sw = 7;
+		break;
+        default:
+		dev_err(i2s->dev, "Unsupported sample size: %d\n",
+			sample_size);
+		return -EINVAL;
+	}
 
-	if (i2s->variant->has_slave_select_bit) {
-		/* DAI clock master masks */
-		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-		case SND_SOC_DAIFMT_CBS_CFS:
-			/* BCLK and LRCLK master */
-			val = SUN4I_I2S_CTRL_MODE_MASTER;
+	if (word_size > sample_size) {
+		switch (word_size) {
+		case 16:
 			break;
-		case SND_SOC_DAIFMT_CBM_CFM:
-			/* BCLK and LRCLK slave */
-			val = SUN4I_I2S_CTRL_MODE_SLAVE;
+		case 20:
+			sw = 4;
+			break;
+		case 24:
+			sw = 5;
+			break;
+		case 32:
+			sw = 7;
 			break;
 		default:
-			dev_err(dai->dev, "Unsupported slave setting: %d\n",
-				fmt & SND_SOC_DAIFMT_MASTER_MASK);
+			dev_err(dai->dev, "Unsupported word size: %d\n",
+				word_size);
 			return -EINVAL;
 		}
-		regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-				   SUN4I_I2S_CTRL_MODE_MASK,
-				   val);
-	} else {
-		/*
-		 * The newer i2s block does not have a slave select bit,
-		 * instead the clk pins are configured as inputs.
-		 */
-		/* DAI clock master masks */
-		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-		case SND_SOC_DAIFMT_CBS_CFS:
-			/* BCLK and LRCLK master */
-			val = SUN8I_I2S_CTRL_BCLK_OUT |
-				SUN8I_I2S_CTRL_LRCK_OUT;
+	}
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_FMT0_SR_MASK,
+			   SUN8I_I2S_FMT0_SR(sr));
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_FMT0_SW_MASK,
+			   SUN8I_I2S_FMT0_SW(sw));
+
+        dev_dbg(dai->dev,
+                "%s: channels = %d, rate = %d, sample = %d (sr = %d), word = %d (sw = %d)\n",
+                __func__, channels, sample_rate, sample_size, sr, word_size, sw);
+
+	return 0;
+}
+
+#define FULL_CHAN_MAP	SUN4I_I2S_CHAN_MAP(0,0) | \
+			SUN4I_I2S_CHAN_MAP(1,1) | \
+			SUN4I_I2S_CHAN_MAP(2,2) | \
+			SUN4I_I2S_CHAN_MAP(3,3) | \
+			SUN4I_I2S_CHAN_MAP(4,4) | \
+			SUN4I_I2S_CHAN_MAP(5,5) | \
+			SUN4I_I2S_CHAN_MAP(6,6) | \
+			SUN4I_I2S_CHAN_MAP(7,7)
+
+static int sun4i_i2s_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 channels, lines;
+	u32 bus_width, sample_rate;
+	u32 word_size;
+	u32 sample_size, storage_size;
+	int ret;
+
+	channels	= params_channels(params);
+	sample_size	= params_width(params);
+	sample_rate	= params_rate(params);
+	storage_size	= params_physical_width(params);
+
+	if ((channels > dai->driver->playback.channels_max) ||
+	    (channels < dai->driver->playback.channels_min)) {
+		dev_err(dai->dev, "Unsupported number of channels: %d\n",
+			channels);
+		return -EINVAL;
+	}
+
+	lines = (channels + 1) / 2;
+
+	/* Enable the required output lines */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_SDO_EN_MASK,
+			   SUN4I_I2S_CTRL_SDO_EN(lines));
+
+	switch (storage_size) {
+	case 16:
+		bus_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 24:
+	case 32:
+		bus_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		dev_err(i2s->dev, "Unsupported storage size: %d\n",
+			storage_size);
+		return -EINVAL;
+	}
+	i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width = bus_width;
+	i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width = bus_width;
+
+
+	/* Map channels for playback */
+	sun4i_i2s_field_set(i2s, FIELD_TX_CHAN_MAP, FULL_CHAN_MAP);
+
+	/* Select playback channels */
+	sun4i_i2s_field_set(i2s, FIELD_TX_CHAN_SEL,
+			    SUN4I_I2S_CHAN_SEL(channels));
+
+	/* Map channels for capture */
+	sun4i_i2s_field_set(i2s, FIELD_RX_CHAN_MAP, FULL_CHAN_MAP);
+
+	/* Select capture channels */
+	sun4i_i2s_field_set(i2s, FIELD_RX_CHAN_SEL,
+			    SUN4I_I2S_CHAN_SEL(channels));
+
+	if (i2s->slot_width)
+		/* Override the word size from device tree */
+		word_size = i2s->slot_width;
+	else {
+		switch (sample_size) {
+		case 32:
+		case 24:
+		case 20:
+			/* Always use 32-bit slot if samples > 16 */
+			word_size = 32;
 			break;
-		case SND_SOC_DAIFMT_CBM_CFM:
-			/* BCLK and LRCLK slave */
-			val = 0;
+		case 16:
+			word_size = 16;
 			break;
 		default:
-			dev_err(dai->dev, "Unsupported slave setting: %d\n",
-				fmt & SND_SOC_DAIFMT_MASTER_MASK);
+			dev_err(i2s->dev, "Unsupported sample size: %d\n",
+				sample_size);
 			return -EINVAL;
 		}
-		regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-				   SUN8I_I2S_CTRL_BCLK_OUT |
-				   SUN8I_I2S_CTRL_LRCK_OUT,
-				   val);
 	}
 
-	/* Set significant bits in our FIFOs */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG,
-			   SUN4I_I2S_FIFO_CTRL_TX_MODE_MASK |
-			   SUN4I_I2S_FIFO_CTRL_RX_MODE_MASK,
-			   SUN4I_I2S_FIFO_CTRL_TX_MODE(1) |
-			   SUN4I_I2S_FIFO_CTRL_RX_MODE(1));
+	ret = i2s->quirks->set_frame_period(i2s, channels, word_size);
+	if (ret)
+		return ret;
+
+	ret = sun4i_i2s_set_rate(i2s, channels, sample_rate, word_size);
+	if (ret)
+		return ret;
+
+	/* Invoke platform-specific hardware config */
+	ret = i2s->quirks->set_hw_config(dai, channels, sample_rate,
+					 sample_size, word_size);
+	if (ret)
+		return ret;
+
+	/* Set to pad out LSB with 0 */
+	sun4i_i2s_field_set(i2s, FIELD_SIGN_EXT, 0);
+
 	return 0;
 }
 
-static void sun4i_i2s_start_capture(struct sun4i_i2s *i2s)
+static int sun4i_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	/* Flush RX FIFO */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_RX,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_RX);
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 bclk_pol = SUN4I_I2S_POLARITY_NORMAL;
+	u32 lrck_pol = SUN4I_I2S_POLARITY_NORMAL;
+	int ret;
 
-	/* Clear RX counter */
-	regmap_write(i2s->regmap, SUN4I_I2S_RX_CNT_REG, 0);
+	/* Invoke platform-specific portion */
+	ret = i2s->quirks->set_format(i2s, fmt);
+	if (ret)
+		return ret;
 
-	/* Enable RX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_RX_EN,
-			   SUN4I_I2S_CTRL_RX_EN);
+        /* DAI clock polarity */
+        switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+        case SND_SOC_DAIFMT_IB_IF:
+                /* Invert both clocks */
+                bclk_pol = SUN4I_I2S_POLARITY_INVERT;
+                lrck_pol = SUN4I_I2S_POLARITY_INVERT;
+                break;
+        case SND_SOC_DAIFMT_IB_NF:
+                /* Invert bit clock only */
+                bclk_pol = SUN4I_I2S_POLARITY_INVERT;
+                break;
+        case SND_SOC_DAIFMT_NB_IF:
+                /* Invert frame clock only */
+                lrck_pol = SUN4I_I2S_POLARITY_INVERT;
+                break;
+        case SND_SOC_DAIFMT_NB_NF:
+                break;
+        default:
+                dev_err(i2s->dev, "Unsupported clock polarity: %d\n",
+                        (fmt & SND_SOC_DAIFMT_INV_MASK));
+                return -EINVAL;
+        }
+
+        sun4i_i2s_field_set(i2s, FIELD_BCLK_POLARITY, bclk_pol);
+
+        /* LRCK can't be inverted in PCM mode */
+        if (!i2s->is_pcm)
+                sun4i_i2s_field_set(i2s, FIELD_LRCK_POLARITY, lrck_pol);
+	else
+		sun4i_i2s_field_set(i2s, FIELD_LRCK_POLARITY,
+				    SUN4I_I2S_POLARITY_NORMAL);
+
+
+	/* Set significant bits in FIFOs */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_CTRL_TX_IM_MASK |
+			   SUN4I_I2S_FIFO_CTRL_RX_OM_MASK,
+			   SUN4I_I2S_FIFO_CTRL_TX_IM(1) |
+			   SUN4I_I2S_FIFO_CTRL_RX_OM(1));
+
+	/* Try to avoid FIFO underrun */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_TX_TL_MASK,
+			   SUN4I_I2S_FIFO_TX_TL(0x20));
+	return 0;
+}
 
-	/* Enable RX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN,
-			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN);
+/**
+ * sun4i_i2s_set_bclk_ratio - configure BCLK to sample rate ratio.
+ * @dai: DAI
+ * @ratio: Ratio of BCLK to Sample rate.
+ *
+ * Configures the DAI for a preset BCLK to sample rate ratio.
+ */
+static int sun4i_i2s_set_bclk_ratio(struct snd_soc_dai *dai,
+				    unsigned int ratio)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	i2s->bclk_ratio = ratio;
+
+	return 0;
+}
+
+static int sun4i_i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+				unsigned int rate, int dir)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	if (clk_id != 0)
+		return -EINVAL;
+
+	i2s->mclk_rate = rate;
+
+	return 0;
+}
+
+static void sun4i_i2s_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	clk_disable_unprepare(i2s->mod_clk);
+
+	/* Disable output lines */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_SDO_EN_MASK, 0);
+
+	/* Disable whole hardware block */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_GLOB_EN, 0);
+
+	/* Reset BCLK ratio */
+	i2s->bclk_ratio = 0;
+}
+
+static int sun4i_i2s_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	/* Enable whole hardware block */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_GLOB_EN,
+			   SUN4I_I2S_CTRL_GLOB_EN);
+
+	return clk_prepare_enable(i2s->mod_clk);
 }
 
 static void sun4i_i2s_start_playback(struct sun4i_i2s *i2s)
 {
 	/* Flush TX FIFO */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_TX,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_TX);
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_FLUSH_TX,
+			   SUN4I_I2S_FIFO_FLUSH_TX);
 
 	/* Clear TX counter */
-	regmap_write(i2s->regmap, SUN4I_I2S_TX_CNT_REG, 0);
+	regmap_write(i2s->regmap, SUN4I_I2S_REG_TX_COUNT, 0);
+
 
 	/* Enable TX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
 			   SUN4I_I2S_CTRL_TX_EN,
 			   SUN4I_I2S_CTRL_TX_EN);
 
 	/* Enable TX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN,
-			   SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN);
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_TX_DRQ_EN,
+			   SUN4I_I2S_TX_DRQ_EN);
+
+}
+
+static void sun4i_i2s_start_capture(struct sun4i_i2s *i2s)
+{
+	/* Flush RX FIFO */
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_FLUSH_RX,
+			   SUN4I_I2S_FIFO_FLUSH_RX);
+
+	/* Clear RX counter */
+	regmap_write(i2s->regmap, SUN4I_I2S_REG_RX_COUNT, 0);
+
+
+	/* Enable RX Block */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_RX_EN,
+			   SUN4I_I2S_CTRL_RX_EN);
+
+	/* Enable RX DRQ */
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_RX_DRQ_EN,
+			   SUN4I_I2S_RX_DRQ_EN);
+
+	/* Debugging without codec */
+	if (i2s->loopback)
+		regmap_update_bits(i2s->regmap,
+				   SUN4I_I2S_REG_CTRL,
+				   SUN4I_I2S_CTRL_LOOPBACK,
+				   SUN4I_I2S_CTRL_LOOPBACK);
 }
 
 static void sun4i_i2s_stop_capture(struct sun4i_i2s *i2s)
 {
 	/* Disable RX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_RX_EN,
-			   0);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_RX_EN, 0);
 
 	/* Disable RX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN,
-			   0);
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_RX_DRQ_EN, 0);
 }
 
 static void sun4i_i2s_stop_playback(struct sun4i_i2s *i2s)
 {
 	/* Disable TX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_TX_EN,
-			   0);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_TX_EN, 0);
 
 	/* Disable TX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN,
-			   0);
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_TX_DRQ_EN, 0);
 }
 
-static int sun4i_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
-			     struct snd_soc_dai *dai)
+static int sun4i_i2s_trigger(struct snd_pcm_substream *substream,
+			     int cmd, struct snd_soc_dai *dai)
 {
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
@@ -644,56 +1000,10 @@ static int sun4i_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-static int sun4i_i2s_startup(struct snd_pcm_substream *substream,
-			     struct snd_soc_dai *dai)
-{
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-
-	/* Enable the whole hardware block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_GL_EN, SUN4I_I2S_CTRL_GL_EN);
-
-	/* Enable the first output line */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_SDO_EN_MASK,
-			   SUN4I_I2S_CTRL_SDO_EN(0));
-
-
-	return clk_prepare_enable(i2s->mod_clk);
-}
-
-static void sun4i_i2s_shutdown(struct snd_pcm_substream *substream,
-			       struct snd_soc_dai *dai)
-{
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-
-	clk_disable_unprepare(i2s->mod_clk);
-
-	/* Disable our output lines */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_SDO_EN_MASK, 0);
-
-	/* Disable the whole hardware block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_GL_EN, 0);
-}
-
-static int sun4i_i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id,
-				unsigned int freq, int dir)
-{
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-
-	if (clk_id != 0)
-		return -EINVAL;
-
-	i2s->mclk_freq = freq;
-
-	return 0;
-}
-
 static const struct snd_soc_dai_ops sun4i_i2s_dai_ops = {
 	.hw_params	= sun4i_i2s_hw_params,
 	.set_fmt	= sun4i_i2s_set_fmt,
+	.set_bclk_ratio = sun4i_i2s_set_bclk_ratio,
 	.set_sysclk	= sun4i_i2s_set_sysclk,
 	.shutdown	= sun4i_i2s_shutdown,
 	.startup	= sun4i_i2s_startup,
@@ -705,8 +1015,8 @@ static int sun4i_i2s_dai_probe(struct snd_soc_dai *dai)
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
 	snd_soc_dai_init_dma_data(dai,
-				  &i2s->playback_dma_data,
-				  &i2s->capture_dma_data);
+			&i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK],
+			&i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE]);
 
 	snd_soc_dai_set_drvdata(dai, i2s);
 
@@ -714,20 +1024,18 @@ static int sun4i_i2s_dai_probe(struct snd_soc_dai *dai)
 }
 
 static struct snd_soc_dai_driver sun4i_i2s_dai = {
-	.probe = sun4i_i2s_dai_probe,
+	.probe	= sun4i_i2s_dai_probe,
 	.capture = {
 		.stream_name = "Capture",
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_192000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	},
 	.playback = {
 		.stream_name = "Playback",
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_192000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	},
 	.ops = &sun4i_i2s_dai_ops,
 	.symmetric_rates = 1,
@@ -737,118 +1045,27 @@ static const struct snd_soc_component_driver sun4i_i2s_component = {
 	.name	= "sun4i-dai",
 };
 
-static bool sun4i_i2s_rd_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case SUN4I_I2S_FIFO_TX_REG:
-		return false;
-
-	default:
-		return true;
-	}
-}
-
-static bool sun4i_i2s_wr_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case SUN4I_I2S_FIFO_RX_REG:
-	case SUN4I_I2S_FIFO_STA_REG:
-		return false;
-
-	default:
-		return true;
-	}
-}
-
-static bool sun4i_i2s_volatile_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case SUN4I_I2S_FIFO_RX_REG:
-	case SUN4I_I2S_INT_STA_REG:
-	case SUN4I_I2S_RX_CNT_REG:
-	case SUN4I_I2S_TX_CNT_REG:
-		return true;
-
-	default:
-		return false;
-	}
-}
 
-static bool sun8i_i2s_rd_reg(struct device *dev, unsigned int reg)
+static int sun4i_i2s_alloc_regmap_fields(struct device *dev,
+					 struct sun4i_i2s *i2s)
 {
-	switch (reg) {
-	case SUN8I_I2S_FIFO_TX_REG:
-		return false;
-
-	default:
-		return true;
+	int i, ret;
+
+	for (i = 0; i < REGMAP_NUM_FIELDS; i++) {
+		i2s->fields[i] = devm_regmap_field_alloc(dev,
+						i2s->regmap,
+						i2s->quirks->reg_fields[i]);
+		if (IS_ERR(i2s->fields[i])) {
+			dev_err(dev, "Failed to allocate regmap field\n");
+			ret = PTR_ERR(i2s->fields[i]);
+			i2s->fields[i] = NULL;
+			return ret;
+		}
 	}
-}
-
-static bool sun8i_i2s_volatile_reg(struct device *dev, unsigned int reg)
-{
-	if (reg == SUN8I_I2S_INT_STA_REG)
-		return true;
-	if (reg == SUN8I_I2S_FIFO_TX_REG)
-		return false;
 
-	return sun4i_i2s_volatile_reg(dev, reg);
+	return 0;
 }
 
-static const struct reg_default sun4i_i2s_reg_defaults[] = {
-	{ SUN4I_I2S_CTRL_REG, 0x00000000 },
-	{ SUN4I_I2S_FMT0_REG, 0x0000000c },
-	{ SUN4I_I2S_FMT1_REG, 0x00004020 },
-	{ SUN4I_I2S_FIFO_CTRL_REG, 0x000400f0 },
-	{ SUN4I_I2S_DMA_INT_CTRL_REG, 0x00000000 },
-	{ SUN4I_I2S_CLK_DIV_REG, 0x00000000 },
-	{ SUN4I_I2S_TX_CHAN_SEL_REG, 0x00000001 },
-	{ SUN4I_I2S_TX_CHAN_MAP_REG, 0x76543210 },
-	{ SUN4I_I2S_RX_CHAN_SEL_REG, 0x00000001 },
-	{ SUN4I_I2S_RX_CHAN_MAP_REG, 0x00003210 },
-};
-
-static const struct reg_default sun8i_i2s_reg_defaults[] = {
-	{ SUN4I_I2S_CTRL_REG, 0x00060000 },
-	{ SUN4I_I2S_FMT0_REG, 0x00000033 },
-	{ SUN4I_I2S_FMT1_REG, 0x00000030 },
-	{ SUN4I_I2S_FIFO_CTRL_REG, 0x000400f0 },
-	{ SUN4I_I2S_DMA_INT_CTRL_REG, 0x00000000 },
-	{ SUN4I_I2S_CLK_DIV_REG, 0x00000000 },
-	{ SUN8I_I2S_CHAN_CFG_REG, 0x00000000 },
-	{ SUN8I_I2S_TX_CHAN_SEL_REG, 0x00000000 },
-	{ SUN8I_I2S_TX_CHAN_MAP_REG, 0x00000000 },
-	{ SUN8I_I2S_RX_CHAN_SEL_REG, 0x00000000 },
-	{ SUN8I_I2S_RX_CHAN_MAP_REG, 0x00000000 },
-};
-
-static const struct regmap_config sun4i_i2s_regmap_config = {
-	.reg_bits	= 32,
-	.reg_stride	= 4,
-	.val_bits	= 32,
-	.max_register	= SUN4I_I2S_RX_CHAN_MAP_REG,
-
-	.cache_type	= REGCACHE_FLAT,
-	.reg_defaults	= sun4i_i2s_reg_defaults,
-	.num_reg_defaults	= ARRAY_SIZE(sun4i_i2s_reg_defaults),
-	.writeable_reg	= sun4i_i2s_wr_reg,
-	.readable_reg	= sun4i_i2s_rd_reg,
-	.volatile_reg	= sun4i_i2s_volatile_reg,
-};
-
-static const struct regmap_config sun8i_i2s_regmap_config = {
-	.reg_bits	= 32,
-	.reg_stride	= 4,
-	.val_bits	= 32,
-	.max_register	= SUN8I_I2S_RX_CHAN_MAP_REG,
-	.cache_type	= REGCACHE_FLAT,
-	.reg_defaults	= sun8i_i2s_reg_defaults,
-	.num_reg_defaults	= ARRAY_SIZE(sun8i_i2s_reg_defaults),
-	.writeable_reg	= sun4i_i2s_wr_reg,
-	.readable_reg	= sun8i_i2s_rd_reg,
-	.volatile_reg	= sun8i_i2s_volatile_reg,
-};
-
 static int sun4i_i2s_runtime_resume(struct device *dev)
 {
 	struct sun4i_i2s *i2s = dev_get_drvdata(dev);
@@ -873,6 +1090,7 @@ static int sun4i_i2s_runtime_resume(struct device *dev)
 
 err_disable_clk:
 	clk_disable_unprepare(i2s->bus_clk);
+
 	return ret;
 }
 
@@ -887,195 +1105,64 @@ static int sun4i_i2s_runtime_suspend(struct device *dev)
 	return 0;
 }
 
-static const struct sun4i_i2s_quirks sun4i_a10_i2s_quirks = {
-	.has_reset		= false,
-	.reg_offset_txdata	= SUN4I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun4i_i2s_regmap_config,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 7, 7),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 2, 3),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 5),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 6, 6),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.has_slave_select_bit	= true,
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 1),
-	.field_txchanmap	= REG_FIELD(SUN4I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN4I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN4I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN4I_I2S_RX_CHAN_SEL_REG, 0, 2),
-};
-
-static const struct sun4i_i2s_quirks sun6i_a31_i2s_quirks = {
-	.has_reset		= true,
-	.reg_offset_txdata	= SUN4I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun4i_i2s_regmap_config,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 7, 7),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 2, 3),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 5),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 6, 6),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.has_slave_select_bit	= true,
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 1),
-	.field_txchanmap	= REG_FIELD(SUN4I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN4I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN4I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN4I_I2S_RX_CHAN_SEL_REG, 0, 2),
-};
-
-static const struct sun4i_i2s_quirks sun8i_a83t_i2s_quirks = {
-	.has_reset		= true,
-	.reg_offset_txdata	= SUN8I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun4i_i2s_regmap_config,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 7, 7),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 2, 3),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 5),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 6, 6),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.has_slave_select_bit	= true,
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 1),
-	.field_txchanmap	= REG_FIELD(SUN4I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN4I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN4I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN4I_I2S_RX_CHAN_SEL_REG, 0, 2),
-};
-
-static const struct sun4i_i2s_quirks sun8i_h3_i2s_quirks = {
-	.has_reset		= true,
-	.reg_offset_txdata	= SUN8I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun8i_i2s_regmap_config,
-	.mclk_offset		= 1,
-	.bclk_offset		= 2,
-	.fmt_offset		= 3,
-	.has_fmt_set_lrck_period = true,
-	.has_chcfg		= true,
-	.has_chsel_tx_chen	= true,
-	.has_chsel_offset	= true,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 8, 8),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 2),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 6),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 19, 19),
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_CTRL_REG, 4, 5),
-	.field_txchanmap	= REG_FIELD(SUN8I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN8I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN8I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN8I_I2S_RX_CHAN_SEL_REG, 0, 2),
-};
-
-static int sun4i_i2s_init_regmap_fields(struct device *dev,
-					struct sun4i_i2s *i2s)
-{
-	i2s->field_clkdiv_mclk_en =
-		devm_regmap_field_alloc(dev, i2s->regmap,
-					i2s->variant->field_clkdiv_mclk_en);
-	if (IS_ERR(i2s->field_clkdiv_mclk_en))
-		return PTR_ERR(i2s->field_clkdiv_mclk_en);
-
-	i2s->field_fmt_wss =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_wss);
-	if (IS_ERR(i2s->field_fmt_wss))
-		return PTR_ERR(i2s->field_fmt_wss);
-
-	i2s->field_fmt_sr =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_sr);
-	if (IS_ERR(i2s->field_fmt_sr))
-		return PTR_ERR(i2s->field_fmt_sr);
-
-	i2s->field_fmt_bclk =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_bclk);
-	if (IS_ERR(i2s->field_fmt_bclk))
-		return PTR_ERR(i2s->field_fmt_bclk);
-
-	i2s->field_fmt_lrclk =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_lrclk);
-	if (IS_ERR(i2s->field_fmt_lrclk))
-		return PTR_ERR(i2s->field_fmt_lrclk);
-
-	i2s->field_fmt_mode =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_mode);
-	if (IS_ERR(i2s->field_fmt_mode))
-		return PTR_ERR(i2s->field_fmt_mode);
-
-	i2s->field_txchanmap =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_txchanmap);
-	if (IS_ERR(i2s->field_txchanmap))
-		return PTR_ERR(i2s->field_txchanmap);
-
-	i2s->field_rxchanmap =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_rxchanmap);
-	if (IS_ERR(i2s->field_rxchanmap))
-		return PTR_ERR(i2s->field_rxchanmap);
-
-	i2s->field_txchansel =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_txchansel);
-	if (IS_ERR(i2s->field_txchansel))
-		return PTR_ERR(i2s->field_txchansel);
-
-	i2s->field_rxchansel =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_rxchansel);
-	return PTR_ERR_OR_ZERO(i2s->field_rxchansel);
-}
-
 static int sun4i_i2s_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct sun4i_i2s *i2s;
+	struct snd_soc_dai_driver *soc_dai;
 	struct resource *res;
-	void __iomem *regs;
+	void __iomem *base;
+	u32 val;
 	int irq, ret;
 
-	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	i2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);
 	if (!i2s)
 		return -ENOMEM;
+
+	i2s->dev = dev;
 	platform_set_drvdata(pdev, i2s);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(regs))
-		return PTR_ERR(regs);
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
-		dev_err(&pdev->dev, "Can't retrieve our interrupt\n");
+		dev_err(dev, "Couldn't request interrupt\n");
 		return irq;
-	}
+        }
 
-	i2s->variant = of_device_get_match_data(&pdev->dev);
-	if (!i2s->variant) {
-		dev_err(&pdev->dev, "Failed to determine the quirks to use\n");
+	i2s->quirks = of_device_get_match_data(dev);
+	if (!i2s->quirks) {
+		dev_err(dev, "Failed to get quirks to use\n");
 		return -ENODEV;
 	}
 
-	i2s->bus_clk = devm_clk_get(&pdev->dev, "apb");
-	if (IS_ERR(i2s->bus_clk)) {
-		dev_err(&pdev->dev, "Can't get our bus clock\n");
-		return PTR_ERR(i2s->bus_clk);
-	}
-
-	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
-					    i2s->variant->sun4i_i2s_regmap);
+	i2s->regmap = devm_regmap_init_mmio(dev, base,
+					i2s->quirks->regmap_cfg);
 	if (IS_ERR(i2s->regmap)) {
-		dev_err(&pdev->dev, "Regmap initialisation failed\n");
+		dev_err(dev, "Couldn't initialize regmap\n");
 		return PTR_ERR(i2s->regmap);
 	}
 
-	i2s->mod_clk = devm_clk_get(&pdev->dev, "mod");
+	i2s->bus_clk = devm_clk_get(dev, "apb");
+	if (IS_ERR(i2s->bus_clk)) {
+		dev_err(dev, "Couldn't get bus clock\n");
+		return PTR_ERR(i2s->bus_clk);
+	}
+
+	i2s->mod_clk = devm_clk_get(dev, "mod");
 	if (IS_ERR(i2s->mod_clk)) {
-		dev_err(&pdev->dev, "Can't get our mod clock\n");
+		dev_err(dev, "Couldn't get mod clock\n");
 		return PTR_ERR(i2s->mod_clk);
 	}
 
-	if (i2s->variant->has_reset) {
-		i2s->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (i2s->quirks->has_reset) {
+		i2s->rst = devm_reset_control_get_exclusive(
+					dev, NULL);
 		if (IS_ERR(i2s->rst)) {
-			dev_err(&pdev->dev, "Failed to get reset control\n");
+			dev_err(dev, "Failed to get reset control\n");
 			return PTR_ERR(i2s->rst);
 		}
 	}
@@ -1083,53 +1170,77 @@ static int sun4i_i2s_probe(struct platform_device *pdev)
 	if (!IS_ERR(i2s->rst)) {
 		ret = reset_control_deassert(i2s->rst);
 		if (ret) {
-			dev_err(&pdev->dev,
-				"Failed to deassert the reset control\n");
+			dev_err(dev,
+				"Couldn't deassert reset control\n");
 			return -EINVAL;
 		}
 	}
 
-	i2s->playback_dma_data.addr = res->start +
-					i2s->variant->reg_offset_txdata;
-	i2s->playback_dma_data.maxburst = 8;
+	i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr = res->start +
+						i2s->quirks->reg_offset_txdata;
+	i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr = res->start +
+						SUN4I_I2S_REG_RX_FIFO;
 
-	i2s->capture_dma_data.addr = res->start + SUN4I_I2S_FIFO_RX_REG;
-	i2s->capture_dma_data.maxburst = 8;
+	i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 8;
+	i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 8;
 
-	pm_runtime_enable(&pdev->dev);
-	if (!pm_runtime_enabled(&pdev->dev)) {
-		ret = sun4i_i2s_runtime_resume(&pdev->dev);
-		if (ret)
-			goto err_pm_disable;
+
+	if (of_property_read_bool(dev->of_node, "loopback"))
+		i2s->loopback = 1;
+
+	if (!of_property_read_u32(dev->of_node,
+			"allwinner,slot-width-override", &val)) {
+		if (val >= 16 && val <= 32)
+			i2s->slot_width = val;
 	}
 
-	ret = devm_snd_soc_register_component(&pdev->dev,
-					      &sun4i_i2s_component,
-					      &sun4i_i2s_dai, 1);
+	soc_dai = devm_kmemdup(dev, &sun4i_i2s_dai,
+			       sizeof(*soc_dai), GFP_KERNEL);
+	if (!soc_dai)
+		goto err_quit;
+
+	soc_dai->playback.formats = i2s->quirks->playback_formats;
+	soc_dai->capture.formats = i2s->quirks->capture_formats;
+
+	ret = sun4i_i2s_alloc_regmap_fields(dev, i2s);
+	if (ret) {
+		dev_err(dev, "Couldn't alloc regmap fields: %d\n",
+			ret);
+		goto err_quit;
+	}
+
+	ret = sun4i_i2s_runtime_resume(dev);
 	if (ret) {
-		dev_err(&pdev->dev, "Could not register DAI\n");
-		goto err_suspend;
+		dev_err(dev, "Couldn't resume device: %d\n", ret);
+		goto err_quit;
 	}
 
-	ret = snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	ret = devm_snd_soc_register_component(dev,
+					      &sun4i_i2s_component,
+					      soc_dai, 1);
 	if (ret) {
-		dev_err(&pdev->dev, "Could not register PCM\n");
-		goto err_suspend;
+		dev_err(dev, "Could not register DAI: %d\n", ret);
+		goto err_pm_disable;
 	}
 
-	ret = sun4i_i2s_init_regmap_fields(&pdev->dev, i2s);
+	ret = snd_dmaengine_pcm_register(dev, NULL, 0);
 	if (ret) {
-		dev_err(&pdev->dev, "Could not initialise regmap fields\n");
-		goto err_suspend;
+		dev_err(dev, "Could not register PCM: %d\n", ret);
+		goto err_pm_disable;
 	}
 
 	return 0;
 
-err_suspend:
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		sun4i_i2s_runtime_suspend(&pdev->dev);
 err_pm_disable:
-	pm_runtime_disable(&pdev->dev);
+	pm_runtime_disable(dev);
+
+	if (!pm_runtime_status_suspended(dev))
+		sun4i_i2s_runtime_suspend(dev);
+err_quit:
 	if (!IS_ERR(i2s->rst))
 		reset_control_assert(i2s->rst);
 
@@ -1142,9 +1253,7 @@ static int sun4i_i2s_remove(struct platform_device *pdev)
 
 	snd_dmaengine_pcm_unregister(&pdev->dev);
 
-	pm_runtime_disable(&pdev->dev);
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		sun4i_i2s_runtime_suspend(&pdev->dev);
+	pm_runtime_force_suspend(&pdev->dev);
 
 	if (!IS_ERR(i2s->rst))
 		reset_control_assert(i2s->rst);
@@ -1152,6 +1261,254 @@ static int sun4i_i2s_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static bool sun4i_i2s_readable_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN4I_I2S_REG_TX_FIFO:
+		return false;
+
+	default:
+		return true;
+	}
+}
+
+static bool sun4i_i2s_writable_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN4I_I2S_REG_RX_FIFO:
+	case SUN4I_I2S_REG_FIFO_STA:
+		return false;
+
+	default:
+		return true;
+	}
+}
+
+static bool sun4i_i2s_volatile_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN4I_I2S_REG_RX_FIFO:
+	case SUN4I_I2S_REG_INT_STA:
+	case SUN4I_I2S_REG_RX_COUNT:
+	case SUN4I_I2S_REG_TX_COUNT:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool sun8i_i2s_readable_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN8I_I2S_REG_TX_FIFO:
+		return false;
+
+	default:
+		return true;
+	}
+}
+
+static bool sun8i_i2s_volatile_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN8I_I2S_REG_INT_STA:
+		return true;
+	case SUN8I_I2S_REG_TX_FIFO:
+		return false;
+
+	default:
+		return sun4i_i2s_volatile_reg(dev, reg);
+	}
+}
+
+static const struct reg_default sun4i_i2s_reg_defaults[] = {
+	{ SUN4I_I2S_REG_CTRL,		0x00000000 },
+	{ SUN4I_I2S_REG_FMT0,		0x0000000c },
+	{ SUN4I_I2S_REG_FMT1,		0x00004020 },
+	{ SUN4I_I2S_REG_FIFO_CTRL,	0x000400f0 },
+	{ SUN4I_I2S_REG_DMA_INT_CTRL,	0x00000000 },
+	{ SUN4I_I2S_REG_CLKDIV,		0x00000000 },
+	{ SUN4I_I2S_REG_TX_CHAN_SEL,	0x00000001 },
+	{ SUN4I_I2S_REG_TX_CHAN_MAP,	0x76543210 },
+	{ SUN4I_I2S_REG_RX_CHAN_SEL,	0x00000001 },
+	{ SUN4I_I2S_REG_RX_CHAN_MAP,	0x00003210 },
+};
+
+static const struct reg_default sun8i_i2s_reg_defaults[] = {
+	{ SUN4I_I2S_REG_CTRL,		0x00060000 },
+	{ SUN4I_I2S_REG_FMT0,		0x00000033 },
+	{ SUN4I_I2S_REG_FMT1,		0x00000030 },
+	{ SUN4I_I2S_REG_FIFO_CTRL,	0x000400f0 },
+	{ SUN4I_I2S_REG_DMA_INT_CTRL,	0x00000000 },
+	{ SUN4I_I2S_REG_CLKDIV,		0x00000000 },
+	{ SUN8I_I2S_REG_CHAN_CFG,	0x00000000 },
+	{ SUN8I_I2S_REG_TX_CHAN_SEL,	0x00000000 },
+	{ SUN8I_I2S_REG_TX_CHAN_MAP,	0x00000000 },
+	{ SUN8I_I2S_REG_RX_CHAN_SEL,	0x00000000 },
+	{ SUN8I_I2S_REG_RX_CHAN_MAP,	0x00000000 },
+};
+
+static const struct regmap_config sun4i_i2s_regmap_config = {
+	.reg_bits		= 32,
+	.reg_stride		= 4,
+	.val_bits		= 32,
+	.max_register		= SUN4I_I2S_REG_RX_CHAN_MAP,
+	.cache_type		= REGCACHE_FLAT,
+	.reg_defaults		= sun4i_i2s_reg_defaults,
+	.num_reg_defaults	= ARRAY_SIZE(sun4i_i2s_reg_defaults),
+	.writeable_reg		= sun4i_i2s_writable_reg,
+	.readable_reg		= sun4i_i2s_readable_reg,
+	.volatile_reg		= sun4i_i2s_volatile_reg,
+};
+
+static const struct regmap_config sun8i_i2s_regmap_config = {
+	.reg_bits		= 32,
+	.reg_stride		= 4,
+	.val_bits		= 32,
+	.max_register		= SUN8I_I2S_REG_RX_CHAN_MAP,
+	.cache_type		= REGCACHE_FLAT,
+	.reg_defaults		= sun8i_i2s_reg_defaults,
+	.num_reg_defaults	= ARRAY_SIZE(sun8i_i2s_reg_defaults),
+	.writeable_reg		= sun4i_i2s_writable_reg,
+	.readable_reg		= sun8i_i2s_readable_reg,
+	.volatile_reg		= sun8i_i2s_volatile_reg,
+};
+
+static const struct reg_field sun4i_a10_i2s_reg_fields[REGMAP_NUM_FIELDS] = {
+	[FIELD_MCLK_OUT_EN]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 7, 7),
+	[FIELD_BCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 4, 6),
+	[FIELD_MCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 0, 3),
+	[FIELD_BCLK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 6, 6),
+	[FIELD_LRCK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 7, 7),
+	[FIELD_SIGN_EXT]	= REG_FIELD(SUN4I_I2S_REG_FMT1, 8, 8),
+	[FIELD_TX_CHAN_SEL]	= REG_FIELD(SUN4I_I2S_REG_TX_CHAN_SEL, 0, 2),
+	[FIELD_RX_CHAN_SEL]	= REG_FIELD(SUN4I_I2S_REG_RX_CHAN_SEL, 0, 2),
+	[FIELD_TX_CHAN_MAP]	= REG_FIELD(SUN4I_I2S_REG_TX_CHAN_MAP, 0, 31),
+	[FIELD_RX_CHAN_MAP]	= REG_FIELD(SUN4I_I2S_REG_RX_CHAN_MAP, 0, 31),
+};
+
+static const struct reg_field sun8i_h3_i2s_reg_fields[REGMAP_NUM_FIELDS] = {
+	[FIELD_MCLK_OUT_EN]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 8, 8),
+	[FIELD_BCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 4, 7),
+	[FIELD_MCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 0, 3),
+	[FIELD_BCLK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 7, 7),
+	[FIELD_LRCK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 19, 19),
+	[FIELD_SIGN_EXT]	= REG_FIELD(SUN4I_I2S_REG_FMT1, 4, 5),
+	[FIELD_TX_CHAN_SEL]	= REG_FIELD(SUN8I_I2S_REG_TX_CHAN_SEL, 0, 2),
+	[FIELD_RX_CHAN_SEL]	= REG_FIELD(SUN8I_I2S_REG_RX_CHAN_SEL, 0, 2),
+	[FIELD_TX_CHAN_MAP]	= REG_FIELD(SUN8I_I2S_REG_TX_CHAN_MAP, 0, 31),
+	[FIELD_RX_CHAN_MAP]	= REG_FIELD(SUN8I_I2S_REG_RX_CHAN_MAP, 0, 31),
+};
+
+#define SUN4I_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE)
+
+#define SUN8I_FORMATS	(SUN4I_FORMATS | \
+			 SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct sun4i_i2s_quirks sun4i_a10_i2s_quirks = {
+	.has_reset		= 0,
+	.reg_offset_txdata	= SUN4I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+	.set_frame_period	= sun4i_i2s_set_frame_period,
+};
+
+static const struct sun4i_i2s_quirks sun6i_a31_i2s_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN4I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+	.set_frame_period	= sun4i_i2s_set_frame_period,
+};
+
+static const struct sun4i_i2s_quirks sun8i_a83t_i2s_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN8I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+	.set_frame_period	= sun4i_i2s_set_frame_period,
+};
+
+static struct sun4i_i2s_quirks sun8i_h3_i2s_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN8I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun8i_i2s_regmap_config,
+	.reg_fields		= sun8i_h3_i2s_reg_fields,
+
+	.bclk_div		= sun8i_i2s_clk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun8i_i2s_clk_div),
+	.mclk_div		= sun8i_i2s_clk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun8i_i2s_clk_div),
+
+	.bclk_parent		= BCLK_PARENT_PLL,
+
+	.playback_formats	= SUN8I_FORMATS,
+	.capture_formats	= SUN8I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun8i_i2s_set_format,
+	.set_hw_config		= sun8i_i2s_set_hw_config,
+	.set_frame_period	= sun8i_i2s_set_frame_period,
+};
+
+static const struct sun4i_i2s_quirks sun50i_a64_i2s_ap_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN8I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+	.set_frame_period	= sun4i_i2s_set_frame_period,
+};
+
 static const struct of_device_id sun4i_i2s_match[] = {
 	{
 		.compatible = "allwinner,sun4i-a10-i2s",
@@ -1169,19 +1526,23 @@ static const struct of_device_id sun4i_i2s_match[] = {
 		.compatible = "allwinner,sun8i-h3-i2s",
 		.data = &sun8i_h3_i2s_quirks,
 	},
-	{}
+	{
+		.compatible = "allwinner,sun50i-a64-i2s-codec",
+		.data = &sun50i_a64_i2s_ap_quirks,
+	},
+	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, sun4i_i2s_match);
 
 static const struct dev_pm_ops sun4i_i2s_pm_ops = {
-	.runtime_resume		= sun4i_i2s_runtime_resume,
-	.runtime_suspend	= sun4i_i2s_runtime_suspend,
+	.runtime_resume	 = sun4i_i2s_runtime_resume,
+	.runtime_suspend = sun4i_i2s_runtime_suspend,
 };
 
 static struct platform_driver sun4i_i2s_driver = {
-	.probe	= sun4i_i2s_probe,
-	.remove	= sun4i_i2s_remove,
-	.driver	= {
+	.probe  = sun4i_i2s_probe,
+	.remove = sun4i_i2s_remove,
+	.driver = {
 		.name		= "sun4i-i2s",
 		.of_match_table	= sun4i_i2s_match,
 		.pm		= &sun4i_i2s_pm_ops,
@@ -1189,7 +1550,6 @@ static struct platform_driver sun4i_i2s_driver = {
 };
 module_platform_driver(sun4i_i2s_driver);
 
-MODULE_AUTHOR("Andrea Venturi <be17068@iperbole.bo.it>");
-MODULE_AUTHOR("Maxime Ripard <maxime.ripard@free-electrons.com>");
-MODULE_DESCRIPTION("Allwinner A10 I2S driver");
+MODULE_AUTHOR("Sergey Suloev <ssuloev@orpaltech.com>");
+MODULE_DESCRIPTION("Allwinner sunXi I2S interface driver");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sun4i-i2s.h b/sound/soc/sunxi/sun4i-i2s.h
new file mode 100644
index 0000000..64a89b5
--- /dev/null
+++ b/sound/soc/sunxi/sun4i-i2s.h
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Allwinner sunXi I2S controller driver
+ *
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_SUN4I_I2S_H
+#define __LINUX_SUN4I_I2S_H
+
+
+#define SUN4I_I2S_REG_CTRL		0x00	/* Control Register */
+#define  SUN4I_I2S_CTRL_SDO_EN_MASK		GENMASK(11,8)
+#define  SUN4I_I2S_CTRL_SDO_EN(lines)		(((1 << lines) - 1) << 8)
+#define  SUN4I_I2S_CTRL_SLAVE_MASK		BIT(5)
+#define  SUN4I_I2S_CTRL_SLAVE			(1 << 5)
+#define  SUN4I_I2S_CTRL_MASTER			(0 << 5)
+#define  SUN4I_I2S_CTRL_MODE_MASK		BIT(4)
+#define  SUN4I_I2S_CTRL_MODE_PCM		(1 << 4)
+#define  SUN4I_I2S_CTRL_MODE_I2S		(0 << 4)
+#define  SUN4I_I2S_CTRL_LOOPBACK		BIT(3)
+#define  SUN4I_I2S_CTRL_TX_EN			BIT(2)
+#define  SUN4I_I2S_CTRL_RX_EN			BIT(1)
+#define  SUN4I_I2S_CTRL_GLOB_EN			BIT(0)
+
+#define  SUN8I_I2S_CTRL_BCLK_OUT		BIT(18)
+#define  SUN8I_I2S_CTRL_LRCK_OUT		BIT(17)
+
+#define  SUN8I_I2S_CTRL_MODE_MASK		GENMASK(5,4)
+#define  SUN8I_I2S_CTRL_MODE_PCM		(0 << 4)
+#define  SUN8I_I2S_CTRL_MODE_LEFT_J		(1 << 4)
+#define  SUN8I_I2S_CTRL_MODE_RIGHT_J		(2 << 4)
+
+
+#define SUN4I_I2S_REG_FMT0		0x04	/* Format 0 Register */
+#define  SUN4I_I2S_FMT0_DSP_MODE_MASK		BIT(7)
+#define  SUN4I_I2S_FMT0_DSP_MODE_A		(0 << 7)
+#define  SUN4I_I2S_FMT0_DSP_MODE_B		(1 << 7)
+#define  SUN4I_I2S_FMT0_SR_MASK			GENMASK(5,4)
+#define  SUN4I_I2S_FMT0_SR(sr)			((sr) << 4)
+#define  SUN4I_I2S_FMT0_WSS_MASK		GENMASK(3,2)
+#define  SUN4I_I2S_FMT0_WSS(ws)			((ws) << 2)
+
+#define  SUN4I_I2S_FMT0_FMT_MASK		GENMASK(1,0)
+#define  SUN4I_I2S_FMT0_FMT_RIGHT_J		(2 << 0)
+#define  SUN4I_I2S_FMT0_FMT_LEFT_J		(1 << 0)
+#define  SUN4I_I2S_FMT0_FMT_I2S			(0 << 0)
+
+#define  SUN4I_I2S_POLARITY_INVERT		1
+#define  SUN4I_I2S_POLARITY_NORMAL		0
+
+#define  SUN8I_I2S_FMT0_SR_MASK			GENMASK(6,4)
+#define  SUN8I_I2S_FMT0_SR(sr)			((sr) << 4)
+#define  SUN8I_I2S_FMT0_SW_MASK			GENMASK(2,0)
+#define  SUN8I_I2S_FMT0_SW(sw)			((sw) << 0)
+
+#define  SUN8I_I2S_LRCK_PERIOD_MASK		GENMASK(17,8)
+#define  SUN8I_I2S_LRCK_PERIOD(prd)		((prd - 1) << 8)
+#define  SUN8I_I2S_LRCK_MAX_PERIOD		1024
+#define  SUN8I_I2S_LRCKR_PERIOD_MASK		GENMASK(29,20)
+#define  SUN8I_I2S_LRCKR_PERIOD(prd)		((prd - 1) << 20)
+
+#define  SUN8I_I2S_PCM_SYNC_WIDTH		BIT(30)
+#define  SUN8I_I2S_PCM_SYNC_SHORT		(0 << 30)	/*1 BCLK period*/
+#define  SUN8I_I2S_PCM_SYNC_LONG		(1 << 30)	/*2 BCLK period*/
+
+#define SUN4I_I2S_REG_FMT1		0x08	/* Format 1 Register */
+#define  SUN4I_I2S_PCM_SYNC_WIDTH		BIT(4)
+#define  SUN4I_I2S_PCM_SYNC_SHORT		(1 << 4)	/*1 BCLK period*/
+#define  SUN4I_I2S_PCM_SYNC_LONG		(0 << 4)	/*2 BCLK period*/
+#define  SUN4I_I2S_FMT1_SEXT_MASK		BIT(8)
+#define  SUN4I_I2S_FMT1_SEXT(sext)		((sext) << 8)
+#define  SUN4I_I2S_FMT1_PCM_SYNC_PRD_MASK	GENMASK(14,12)
+#define  SUN4I_I2S_FMT1_PCM_SYNC_PRD(prd)	((prd) << 12)
+
+
+#define SUN4I_I2S_REG_RX_FIFO		0x10	/* RX FIFO Register */
+
+
+#define SUN4I_I2S_REG_FIFO_CTRL		0x14	/* FIFO Control Register */
+#define  SUN4I_I2S_FIFO_CTRL_TX_IM_MASK		BIT(2)
+#define  SUN4I_I2S_FIFO_CTRL_TX_IM(mod)		((mod) << 2)
+#define  SUN4I_I2S_FIFO_CTRL_RX_OM_MASK		GENMASK(1,0)
+#define  SUN4I_I2S_FIFO_CTRL_RX_OM(mod)		((mod) << 0)
+#define  SUN4I_I2S_FIFO_RX_TL_MASK		GENMASK(9,4)
+#define  SUN4I_I2S_FIFO_RX_TL(tl)		((tl) << 4)
+#define  SUN4I_I2S_FIFO_TX_TL_MASK		GENMASK(18,12)
+#define  SUN4I_I2S_FIFO_TX_TL(tl)		((tl) << 12)
+#define  SUN4I_I2S_FIFO_FLUSH_TX		BIT(25)
+#define  SUN4I_I2S_FIFO_FLUSH_RX		BIT(24)
+
+
+#define SUN4I_I2S_REG_FIFO_STA		0x18	/* FIFO Status Register */
+
+
+#define SUN4I_I2S_REG_TX_FIFO		0x0c	/* TX FIFO Register */
+#define SUN8I_I2S_REG_TX_FIFO		0x20	/* TX FIFO Register */
+
+
+#define SUN4I_I2S_REG_INT_STA		0x20	/* Interrupt Status Register */
+#define SUN8I_I2S_REG_INT_STA		0x0c	/* Interrupt Status Register */
+
+
+#define SUN4I_I2S_REG_DMA_INT_CTRL	0x1c	/* Interrupt/DMA Control Register */
+#define  SUN4I_I2S_TX_DRQ_EN			BIT(7)
+#define  SUN4I_I2S_RX_DRQ_EN			BIT(3)
+
+
+#define SUN4I_I2S_REG_CLKDIV		0x24	/* Clock Divide Register */
+#define  SUN4I_I2S_CLKDIV_MCLK_EN		BIT(7)
+#define  SUN4I_I2S_CLKDIV_MCLK_MASK		GENMASK(3,0)
+#define  SUN4I_I2S_CLKDIV_MCLK(div)		((div) << 0)
+#define  SUN4I_I2S_CLKDIV_BCLK_MASK		GENMASK(6,4)
+#define  SUN4I_I2S_CLKDIV_BCLK(div)		((div) << 4)
+
+#define  SUN8I_I2S_CLKDIV_BCLK_MASK		GENMASK(7,4)
+#define  SUN8I_I2S_CLKDIV_MCLK_EN		BIT(8)
+
+
+#define SUN4I_I2S_REG_TX_COUNT		0x28	/* TX Sample Counter Register */
+#define SUN4I_I2S_REG_RX_COUNT		0x2c	/* RX Sample Counter Register */
+
+
+#define SUN8I_I2S_REG_CHAN_CFG		0x30
+#define  SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK	GENMASK(6,4)
+#define  SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(ch)	(((ch) - 1) << 4)
+#define  SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK	GENMASK(2, 0)
+#define  SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(ch)	(((ch) - 1) << 0)
+
+
+#define SUN4I_I2S_REG_TX_CHAN_SEL	0x30	/* TX Channel Select Register */
+#define SUN8I_I2S_REG_TX_CHAN_SEL	0x34
+#define  SUN8I_I2S_TX_CHAN_SEL_EN_MASK		GENMASK(11,4)
+#define  SUN8I_I2S_TX_CHAN_SEL_EN(ch)		(((1 << (ch)) - 1) << 4)
+#define  SUN8I_I2S_TX_CHAN_SEL_OFFSET_MASK	GENMASK(13,12)
+#define  SUN8I_I2S_TX_CHAN_SEL_OFFSET(off)	((off) << 12)
+
+
+#define SUN4I_I2S_REG_RX_CHAN_SEL	0x38    /* RX Channel Select Register */
+#define SUN8I_I2S_REG_RX_CHAN_SEL	0x54
+#define  SUN4I_I2S_CHAN_SEL(num)		((num) - 1)
+
+
+#define SUN4I_I2S_REG_TX_CHAN_MAP	0x34	/* TX Channel Mapping Register */
+#define SUN8I_I2S_REG_TX_CHAN_MAP	0x44
+#define SUN4I_I2S_REG_RX_CHAN_MAP	0x3c	/* RX Channel Mapping Register */
+#define SUN8I_I2S_REG_RX_CHAN_MAP	0x58
+#define  SUN4I_I2S_CHAN_MAP(chan, sample)	((sample) << ((chan) << 2))
+
+
+/* regmap fields */
+enum {
+	FIELD_MCLK_OUT_EN,	/* MCLK Enable */
+
+	FIELD_BCLK_DIV,
+	FIELD_MCLK_DIV,
+
+	FIELD_BCLK_POLARITY,	/* BCLK Polarity */
+	FIELD_LRCK_POLARITY,	/* LRCK	Polarity */
+
+	FIELD_SIGN_EXT,		/* Sign Extend in slot */
+
+	FIELD_TX_CHAN_MAP,	/* TX Channel Mapping */
+	FIELD_RX_CHAN_MAP,	/* RX Channel Mapping */
+	FIELD_TX_CHAN_SEL,	/* TX Channel Select */
+	FIELD_RX_CHAN_SEL,	/* RX Channel Select */
+
+	/* Keep last */
+	REGMAP_NUM_FIELDS,
+};
+
+struct sun4i_i2s;
+
+struct sun4i_i2s_clkdiv {
+	u8	div;
+	u8	val;
+};
+
+enum {
+	BCLK_PARENT_MCLK,
+	BCLK_PARENT_PLL,
+};
+
+struct sun4i_i2s_quirks {
+	bool				has_reset;
+	u32				reg_offset_txdata;
+	const struct regmap_config	*regmap_cfg;
+	const struct reg_field		*reg_fields;
+
+	const struct sun4i_i2s_clkdiv	*bclk_div;
+	unsigned int			num_bclkdiv;
+
+	const struct sun4i_i2s_clkdiv	*mclk_div;
+	unsigned int			num_mclkdiv;
+
+	u32				playback_formats;
+	u32				capture_formats;
+
+	int				bclk_parent;
+
+	/* SoC-specific DAI configuration */
+	int (*set_format)(struct sun4i_i2s *i2s, u32 fmt);
+	int (*set_hw_config)(struct snd_soc_dai *dai,
+			     u32 channels, u32 sample_rate,
+			     u32 sample_size, u32 word_size);
+	int (*set_frame_period)(struct sun4i_i2s *i2s,
+				u32 channels, u32 word_size);
+};
+
+struct sun4i_i2s {
+	struct device		*dev;
+	struct clk		*bus_clk;
+	struct clk		*mod_clk;
+	struct regmap		*regmap;
+	struct regmap_field	*fields[REGMAP_NUM_FIELDS];
+	struct reset_control	*rst;
+
+	bool		loopback;
+	bool		bit_clk_master;
+	bool		is_pcm;
+
+	unsigned long	mclk_rate;
+
+	u32		bclk_ratio;
+	u32		slot_width;
+
+	struct snd_dmaengine_dai_dma_data
+			dma_data[SNDRV_PCM_STREAM_LAST + 1];
+
+	const struct sun4i_i2s_quirks	*quirks;
+};
+
+#endif	// __LINUX_SUN4I_I2S_H
-- 
2.17.0

