From 2f855b08e63d091326bbd06789ebf7e7796b84f8 Mon Sep 17 00:00:00 2001
From: Sergey Suloev <sergey.suloev@gmail.com>
Date: Mon, 28 Jul 2025 19:36:48 +0300
Subject: [PATCH] net: wireless: Add Espressif ESP-Hosted-NG driver

---
 drivers/net/wireless/Kconfig                  |    1 +
 drivers/net/wireless/Makefile                 |    1 +
 drivers/net/wireless/espressif/Kconfig        |   17 +
 drivers/net/wireless/espressif/Makefile       |    2 +
 .../wireless/espressif/esp_hosted_ng/Kconfig  |   45 +
 .../wireless/espressif/esp_hosted_ng/Makefile |   45 +
 .../wireless/espressif/esp_hosted_ng/esp_bt.c |  260 ++
 .../espressif/esp_hosted_ng/esp_cfg80211.c    | 1283 +++++++++
 .../espressif/esp_hosted_ng/esp_cmd.c         | 2336 +++++++++++++++++
 .../espressif/esp_hosted_ng/esp_debugfs.c     |  287 ++
 .../espressif/esp_hosted_ng/esp_log.c         |   66 +
 .../espressif/esp_hosted_ng/esp_stats.c       |  197 ++
 .../espressif/esp_hosted_ng/esp_utils.c       |   52 +
 .../espressif/esp_hosted_ng/include/adapter.h |  457 ++++
 .../espressif/esp_hosted_ng/include/esp.h     |  182 ++
 .../espressif/esp_hosted_ng/include/esp_api.h |   48 +
 .../esp_hosted_ng/include/esp_bt_api.h        |   36 +
 .../esp_hosted_ng/include/esp_cfg80211.h      |   25 +
 .../espressif/esp_hosted_ng/include/esp_cmd.h |   72 +
 .../esp_hosted_ng/include/esp_fw_version.h    |   19 +
 .../espressif/esp_hosted_ng/include/esp_if.h  |   23 +
 .../esp_hosted_ng/include/esp_kernel_port.h   |  230 ++
 .../esp_hosted_ng/include/esp_stats.h         |   32 +
 .../esp_hosted_ng/include/esp_utils.h         |   50 +
 .../espressif/esp_hosted_ng/include/main.h    |   23 +
 .../espressif/esp_hosted_ng/include/utils.h   |   45 +
 .../wireless/espressif/esp_hosted_ng/main.c   | 1099 ++++++++
 .../espressif/esp_hosted_ng/sdio/esp_sdio.c   |  958 +++++++
 .../esp_hosted_ng/sdio/esp_sdio_api.c         |  149 ++
 .../esp_hosted_ng/sdio/esp_sdio_api.h         |   17 +
 .../esp_hosted_ng/sdio/esp_sdio_decl.h        |   85 +
 .../espressif/esp_hosted_ng/spi/esp_spi.c     |  639 +++++
 .../espressif/esp_hosted_ng/spi/esp_spi.h     |   34 +
 33 files changed, 8815 insertions(+)
 create mode 100644 drivers/net/wireless/espressif/Kconfig
 create mode 100644 drivers/net/wireless/espressif/Makefile
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/Kconfig
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/Makefile
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_debugfs.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_log.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_utils.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_fw_version.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_utils.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/main.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/utils.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/main.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h

diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index c659959..fe9e847 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -22,6 +22,7 @@ source "drivers/net/wireless/admtek/Kconfig"
 source "drivers/net/wireless/ath/Kconfig"
 source "drivers/net/wireless/atmel/Kconfig"
 source "drivers/net/wireless/broadcom/Kconfig"
+source "drivers/net/wireless/espressif/Kconfig"
 source "drivers/net/wireless/intel/Kconfig"
 source "drivers/net/wireless/intersil/Kconfig"
 source "drivers/net/wireless/marvell/Kconfig"
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index e1c4141..ce79dbd 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_WLAN_VENDOR_ADMTEK) += admtek/
 obj-$(CONFIG_WLAN_VENDOR_ATH) += ath/
 obj-$(CONFIG_WLAN_VENDOR_ATMEL) += atmel/
 obj-$(CONFIG_WLAN_VENDOR_BROADCOM) += broadcom/
+obj-$(CONFIG_WLAN_VENDOR_ESPRESSIF) += espressif/
 obj-$(CONFIG_WLAN_VENDOR_INTEL) += intel/
 obj-$(CONFIG_WLAN_VENDOR_INTERSIL) += intersil/
 obj-$(CONFIG_WLAN_VENDOR_MARVELL) += marvell/
diff --git a/drivers/net/wireless/espressif/Kconfig b/drivers/net/wireless/espressif/Kconfig
new file mode 100644
index 0000000..b6342a5
--- /dev/null
+++ b/drivers/net/wireless/espressif/Kconfig
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config WLAN_VENDOR_ESPRESSIF
+	bool "Espressif ESP-series wireless devices"
+	default y
+	help
+	  If you have a wireless card belonging to this class, say Y.
+
+	  Note that the answer to this question doesn't directly affect the
+	  kernel: saying N will just cause the configurator to skip all the
+	  questions about these cards. If you say Y, you will be asked for
+	  your specific card in the following questions.
+
+if WLAN_VENDOR_ESPRESSIF
+
+source "drivers/net/wireless/espressif/esp_hosted_ng/Kconfig"
+
+endif # WLAN_VENDOR_ESPRESSIF
diff --git a/drivers/net/wireless/espressif/Makefile b/drivers/net/wireless/espressif/Makefile
new file mode 100644
index 0000000..74b7996
--- /dev/null
+++ b/drivers/net/wireless/espressif/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_ESPRESSIF_ESP_HOSTED_NG) += esp_hosted_ng/
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/Kconfig b/drivers/net/wireless/espressif/esp_hosted_ng/Kconfig
new file mode 100644
index 0000000..2f8213a
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/Kconfig
@@ -0,0 +1,45 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# ESP hosted (New Generation) wireless drivers
+#
+
+config ESPRESSIF_ESP_HOSTED_NG
+	tristate
+	help
+	  The driver allows for using ESP32-series SoC 
+	  as a hosted wireless transceiver.
+
+config ESP_HOSTED_NG_SDIO
+	tristate "Espressif ESP-Series hosted (NG) with SDIO"
+	select ESPRESSIF_ESP_HOSTED_NG
+
+config ESP_HOSTED_NG_SPI
+	tristate "Espressif ESP-Series hosted (NG) with SPI"
+	depends on SPI
+	select SPI_MASTER
+	select ESPRESSIF_ESP_HOSTED_NG
+
+config ESP_HOSTED_NG_AP_SUPPORT
+	bool "-- Support for AP-mode"
+	depends on ESPRESSIF_ESP_HOSTED_NG
+
+config ESP_HOSTED_NG_TEST_RAW_TP
+	bool "-- Raw Throughput testing"
+	depends on ESPRESSIF_ESP_HOSTED_NG
+
+config ESP_HOSTED_NG_LOG_LEVEL
+	int "-- Debug log verbosity level"
+	depends on ESPRESSIF_ESP_HOSTED_NG
+	range 0 4
+	default 0
+	help
+	  The entry defines a verbosity level of the debug log.
+	  Allowed values are 0-4.
+
+config ESP_HOSTED_NG_NO_ADJUST_SPI_CLOCK
+	bool "-- Disallow ESP adjusting SPI clock"
+	depends on ESP_HOSTED_NG_SPI
+
+config ESP_HOSTED_NG_NO_CS_CHANGE
+	bool "-- Disallow CS change"
+	depends on ESP_HOSTED_NG_SPI
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/Makefile b/drivers/net/wireless/espressif/esp_hosted_ng/Makefile
new file mode 100644
index 0000000..a6de820
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/Makefile
@@ -0,0 +1,45 @@
+ifneq ($(filter $(CONFIG_ESPRESSIF_ESP_HOSTED_NG),y m),)
+
+mod_name_sdio = esp32_sdio
+mod_name_spi = esp32_spi
+
+ccflags-y += -I$(src)/include -I$(src)
+
+mod_objects = \
+	esp_bt.o \
+	esp_cmd.o \
+	esp_utils.o \
+	esp_cfg80211.o \
+	esp_stats.o \
+	esp_debugfs.o \
+	esp_log.o \
+	main.o \
+
+$(mod_name_sdio)-objs := $(mod_objects)
+$(mod_name_spi)-objs := $(mod_objects)
+
+ifneq ($(filter $(CONFIG_ESP_HOSTED_NG_SDIO),y m),)
+	ccflags-y += -I$(src)/sdio
+	$(mod_name_sdio)-objs += sdio/esp_sdio.o sdio/esp_sdio_api.o
+endif
+
+ifneq ($(filter $(CONFIG_ESP_HOSTED_NG_SPI),y m),)
+	ccflags-y += -I$(src)/spi
+	$(mod_name_spi)-objs += spi/esp_spi.o
+endif
+
+ifeq ($(CONFIG_ESP_HOSTED_NG_AP_SUPPORT), y)
+	ccflags-y += -DCONFIG_AP_MODE
+endif
+
+log_level := $(CONFIG_ESP_HOSTED_NG_LOG_LEVEL)
+log_debug := 3
+is_debug := $(shell echo ${log_level}\>=${log_debug} | bc)
+ifeq ($(is_debug),1)
+	ccflags-y += -DDEBUG
+endif
+
+obj-$(CONFIG_ESP_HOSTED_NG_SDIO) += $(mod_name_sdio).o
+obj-$(CONFIG_ESP_HOSTED_NG_SPI) += $(mod_name_spi).o
+
+endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c
new file mode 100644
index 0000000..bde9848
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#include "utils.h"
+#include "esp_api.h"
+#include "esp_kernel_port.h"
+#include "esp_bt_api.h"
+
+#define INVALID_HDEV_BUS (0xff)
+
+void esp_hci_update_tx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len)
+{
+	if (!hdev)
+		return;
+	if (pkt_type == HCI_COMMAND_PKT) {
+		hdev->stat.cmd_tx++;
+	} else if (pkt_type == HCI_ACLDATA_PKT) {
+		hdev->stat.acl_tx++;
+	} else if (pkt_type == HCI_SCODATA_PKT) {
+		hdev->stat.sco_tx++;
+	}
+
+	hdev->stat.byte_tx += len;
+}
+
+void esp_hci_update_rx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len)
+{
+	if (!hdev)
+		return;
+
+	if (pkt_type == HCI_EVENT_PKT) {
+		hdev->stat.evt_rx++;
+	} else if (pkt_type == HCI_ACLDATA_PKT) {
+		hdev->stat.acl_rx++;
+	} else if (pkt_type == HCI_SCODATA_PKT) {
+		hdev->stat.sco_rx++;
+	}
+
+	hdev->stat.byte_rx += len;
+}
+
+static int esp_bt_open(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_close(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_flush(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static ESP_BT_SEND_FRAME_PROTOTYPE()
+{
+	struct esp_payload_header *hdr;
+	size_t total_len, len = skb->len;
+	int ret = 0;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
+	struct hci_dev *hdev = (struct hci_dev *)(skb->dev);
+#endif
+	struct esp_adapter *adapter = hci_get_drvdata(hdev);
+	struct sk_buff *new_skb;
+	u8 pad_len = 0, realloc_skb = 0;
+	u8 *pos = NULL;
+	u8 pkt_type;
+
+	if (!adapter) {
+		esp_err("Invalid args");
+		return -EINVAL;
+	}
+	esp_hex_dump_verbose("bt_tx: ", skb->data, len);
+
+	/* Create space for payload header */
+	pad_len = sizeof(struct esp_payload_header);
+	total_len = len + sizeof(struct esp_payload_header);
+
+	/* Align buffer len */
+	pad_len += SKB_DATA_ADDR_ALIGNMENT - (total_len % SKB_DATA_ADDR_ALIGNMENT);
+
+	pkt_type = hci_skb_pkt_type(skb);
+
+	if (skb_headroom(skb) < pad_len) {
+		/* Headroom is not sufficient */
+		realloc_skb = 1;
+	}
+
+	if (realloc_skb || !IS_ALIGNED((unsigned long) skb->data, SKB_DATA_ADDR_ALIGNMENT)) {
+		/* Realloc SKB */
+		if (skb_linearize(skb)) {
+			hdev->stat.err_tx++;
+			return -EINVAL;
+		}
+
+		new_skb = esp_alloc_skb(skb->len + pad_len);
+
+		if (!new_skb) {
+			esp_err("Failed to allocate SKB");
+			hdev->stat.err_tx++;
+			return -ENOMEM;
+		}
+
+		pos = new_skb->data;
+
+		pos += pad_len;
+
+		/* Populate new SKB */
+		skb_copy_from_linear_data(skb, pos, skb->len);
+		skb_put(new_skb, skb->len);
+
+		/* Replace old SKB */
+		dev_kfree_skb_any(skb);
+		skb = new_skb;
+	} else {
+		/* Realloc is not needed, Make space for interface header */
+		skb_push(skb, pad_len);
+	}
+
+	hdr = (struct esp_payload_header *) skb->data;
+
+	memset(hdr, 0, sizeof(struct esp_payload_header));
+
+	hdr->if_type = ESP_HCI_IF;
+	hdr->if_num = 0;
+	hdr->len = cpu_to_le16(len);
+	hdr->offset = cpu_to_le16(pad_len);
+	pos = skb->data;
+
+	/* set HCI packet type */
+	*(pos + pad_len - 1) = pkt_type;
+
+	if (adapter->capabilities & ESP_CHECKSUM_ENABLED)
+		hdr->checksum = cpu_to_le16(compute_checksum(skb->data, (len + pad_len)));
+
+	ret = esp_send_packet(adapter, skb);
+
+	if (ret) {
+		hdev->stat.err_tx++;
+		return ret;
+	} else {
+		esp_hci_update_tx_counter(hdev, hdr->hci_pkt_type, skb->len);
+	}
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+static int esp_bt_setup(struct hci_dev *hdev)
+{
+	return 0;
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0))
+static int esp_bt_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)
+{
+	return 0;
+}
+#endif
+
+int esp_deinit_bt(struct esp_adapter *adapter)
+{
+	struct hci_dev *hdev = NULL;
+
+	if (!adapter || !adapter->hcidev)
+		return 0;
+
+	hdev = adapter->hcidev;
+
+	hci_set_drvdata(hdev, NULL);
+	hci_unregister_dev(hdev);
+	hci_free_dev(hdev);
+
+	adapter->hcidev = NULL;
+
+	return 0;
+}
+
+int esp_init_bt(struct esp_adapter *adapter)
+{
+	int ret = 0;
+	struct hci_dev *hdev = NULL;
+
+	if (!adapter) {
+		return -EINVAL;
+	}
+
+	if (adapter->hcidev) {
+		return -EEXIST;
+	}
+
+	hdev = hci_alloc_dev();
+
+	if (!hdev) {
+		BT_ERR("Can not allocate HCI device");
+		return -ENOMEM;
+	}
+
+	adapter->hcidev = hdev;
+	hci_set_drvdata(hdev, adapter);
+
+	hdev->bus = INVALID_HDEV_BUS;
+
+	if (adapter->if_type == ESP_IF_TYPE_SDIO)
+		hdev->bus   = HCI_SDIO;
+    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
+	else if (adapter->if_type == ESP_IF_TYPE_SPI)
+		hdev->bus   = HCI_SPI;
+    #endif
+
+	if (hdev->bus == INVALID_HDEV_BUS) {
+
+		if (adapter->if_type == ESP_IF_TYPE_SDIO) {
+			esp_err("Kernel version does not support HCI over SDIO BUS\n");
+		} else if (adapter->if_type == ESP_IF_TYPE_SPI) {
+			esp_err("Kernel version does not support HCI over SPI BUS\n");
+		} else {
+			esp_err("HCI over expected BUS[%u] is not supported\n", adapter->if_type);
+		}
+		hci_free_dev(hdev);
+		adapter->hcidev = NULL;
+		return -EINVAL;
+	}
+
+	hdev->open  = esp_bt_open;
+	hdev->close = esp_bt_close;
+	hdev->flush = esp_bt_flush;
+	hdev->send  = esp_bt_send_frame;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	hdev->setup = esp_bt_setup;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0))
+	hdev->set_bdaddr = esp_bt_set_bdaddr;
+#endif
+
+#ifdef HCI_PRIMARY
+	hdev->dev_type = HCI_PRIMARY;
+#endif
+
+	if (adapter->dev)
+		SET_HCIDEV_DEV(hdev, adapter->dev);
+
+	ret = hci_register_dev(hdev);
+	if (ret < 0) {
+		BT_ERR("Can not register HCI device");
+		hci_free_dev(hdev);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c
new file mode 100644
index 0000000..a6cc278
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c
@@ -0,0 +1,1283 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ */
+#include "utils.h"
+#include "esp.h"
+#include "esp_api.h"
+#include "esp_cfg80211.h"
+#include "esp_cmd.h"
+#include "esp_kernel_port.h"
+#include "esp_utils.h"
+
+/**
+  * @brief WiFi PHY rate encodings
+  *
+  */
+typedef enum {
+	WIFI_PHY_RATE_1M_L      = 0x00, /**< 1 Mbps with long preamble */
+	WIFI_PHY_RATE_2M_L      = 0x01, /**< 2 Mbps with long preamble */
+	WIFI_PHY_RATE_5M_L      = 0x02, /**< 5.5 Mbps with long preamble */
+	WIFI_PHY_RATE_11M_L     = 0x03, /**< 11 Mbps with long preamble */
+	WIFI_PHY_RATE_2M_S      = 0x05, /**< 2 Mbps with short preamble */
+	WIFI_PHY_RATE_5M_S      = 0x06, /**< 5.5 Mbps with short preamble */
+	WIFI_PHY_RATE_11M_S     = 0x07, /**< 11 Mbps with short preamble */
+	WIFI_PHY_RATE_48M       = 0x08, /**< 48 Mbps */
+	WIFI_PHY_RATE_24M       = 0x09, /**< 24 Mbps */
+	WIFI_PHY_RATE_12M       = 0x0A, /**< 12 Mbps */
+	WIFI_PHY_RATE_6M        = 0x0B, /**< 6 Mbps */
+	WIFI_PHY_RATE_54M       = 0x0C, /**< 54 Mbps */
+	WIFI_PHY_RATE_36M       = 0x0D, /**< 36 Mbps */
+	WIFI_PHY_RATE_18M       = 0x0E, /**< 18 Mbps */
+	WIFI_PHY_RATE_9M        = 0x0F, /**< 9 Mbps */
+	WIFI_PHY_RATE_MCS0_LGI  = 0x10, /**< MCS0 with long GI, 6.5 Mbps for 20MHz, 13.5 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS1_LGI  = 0x11, /**< MCS1 with long GI, 13 Mbps for 20MHz, 27 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS2_LGI  = 0x12, /**< MCS2 with long GI, 19.5 Mbps for 20MHz, 40.5 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS3_LGI  = 0x13, /**< MCS3 with long GI, 26 Mbps for 20MHz, 54 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS4_LGI  = 0x14, /**< MCS4 with long GI, 39 Mbps for 20MHz, 81 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS5_LGI  = 0x15, /**< MCS5 with long GI, 52 Mbps for 20MHz, 108 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS6_LGI  = 0x16, /**< MCS6 with long GI, 58.5 Mbps for 20MHz, 121.5 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS7_LGI  = 0x17, /**< MCS7 with long GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS0_SGI  = 0x18, /**< MCS0 with short GI, 7.2 Mbps for 20MHz, 15 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS1_SGI  = 0x19, /**< MCS1 with short GI, 14.4 Mbps for 20MHz, 30 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS2_SGI  = 0x1A, /**< MCS2 with short GI, 21.7 Mbps for 20MHz, 45 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS3_SGI  = 0x1B, /**< MCS3 with short GI, 28.9 Mbps for 20MHz, 60 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS4_SGI  = 0x1C, /**< MCS4 with short GI, 43.3 Mbps for 20MHz, 90 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS5_SGI  = 0x1D, /**< MCS5 with short GI, 57.8 Mbps for 20MHz, 120 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS6_SGI  = 0x1E, /**< MCS6 with short GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS7_SGI  = 0x1F, /**< MCS7 with short GI, 72.2 Mbps for 20MHz, 150 Mbps for 40MHz */
+	WIFI_PHY_RATE_LORA_250K = 0x29, /**< 250 Kbps */
+	WIFI_PHY_RATE_LORA_500K = 0x2A, /**< 500 Kbps */
+	WIFI_PHY_RATE_MAX,
+} wifi_phy_rate_t;
+
+/* Supported rates to be advertised to the cfg80211 */
+static struct ieee80211_rate esp_rates[] = {
+	{.bitrate = 10, .hw_value = WIFI_PHY_RATE_1M_L, },
+	{.bitrate = 20, .hw_value = WIFI_PHY_RATE_2M_L, },
+	{.bitrate = 55, .hw_value = WIFI_PHY_RATE_5M_L, .hw_value_short = WIFI_PHY_RATE_5M_S},
+	{.bitrate = 110, .hw_value = WIFI_PHY_RATE_11M_L, .hw_value_short = WIFI_PHY_RATE_11M_S},
+	{.bitrate = 60, .hw_value = WIFI_PHY_RATE_6M, },
+	{.bitrate = 90, .hw_value = WIFI_PHY_RATE_9M, },
+	{.bitrate = 120, .hw_value = WIFI_PHY_RATE_12M, },
+	{.bitrate = 180, .hw_value = WIFI_PHY_RATE_18M, },
+	{.bitrate = 240, .hw_value = WIFI_PHY_RATE_24M, },
+	{.bitrate = 360, .hw_value = WIFI_PHY_RATE_36M, },
+	{.bitrate = 480, .hw_value = WIFI_PHY_RATE_48M, },
+	{.bitrate = 540, .hw_value = WIFI_PHY_RATE_54M, },
+};
+
+
+/* Channel definitions to be advertised to cfg80211 */
+static struct ieee80211_channel esp_channels_2ghz[] = {
+	{.center_freq = 2412, .hw_value = 1, },
+	{.center_freq = 2417, .hw_value = 2, },
+	{.center_freq = 2422, .hw_value = 3, },
+	{.center_freq = 2427, .hw_value = 4, },
+	{.center_freq = 2432, .hw_value = 5, },
+	{.center_freq = 2437, .hw_value = 6, },
+	{.center_freq = 2442, .hw_value = 7, },
+	{.center_freq = 2447, .hw_value = 8, },
+	{.center_freq = 2452, .hw_value = 9, },
+	{.center_freq = 2457, .hw_value = 10, },
+	{.center_freq = 2462, .hw_value = 11, },
+	{.center_freq = 2467, .hw_value = 12, },
+	{.center_freq = 2472, .hw_value = 13, },
+	{.center_freq = 2484, .hw_value = 14, },
+};
+
+static struct ieee80211_channel esp_channels_5ghz[] = {
+	{.center_freq = 5180, .hw_value = 36, },
+	{.center_freq = 5200, .hw_value = 40, },
+	{.center_freq = 5220, .hw_value = 44, },
+	{.center_freq = 5240, .hw_value = 48, },
+	{.center_freq = 5260, .hw_value = 52, },
+	{.center_freq = 5280, .hw_value = 56, },
+	{.center_freq = 5300, .hw_value = 60, },
+	{.center_freq = 5320, .hw_value = 64, },
+	{.center_freq = 5500, .hw_value = 100, },
+	{.center_freq = 5520, .hw_value = 104, },
+	{.center_freq = 5540, .hw_value = 108, },
+	{.center_freq = 5560, .hw_value = 112, },
+	{.center_freq = 5580, .hw_value = 116, },
+	{.center_freq = 5600, .hw_value = 120, },
+	{.center_freq = 5620, .hw_value = 124, },
+	{.center_freq = 5640, .hw_value = 128, },
+	{.center_freq = 5660, .hw_value = 132, },
+	{.center_freq = 5680, .hw_value = 136, },
+	{.center_freq = 5700, .hw_value = 140, },
+	{.center_freq = 5720, .hw_value = 144, },
+	{.center_freq = 5745, .hw_value = 149, },
+	{.center_freq = 5765, .hw_value = 153, },
+	{.center_freq = 5785, .hw_value = 157, },
+	{.center_freq = 5805, .hw_value = 161, },
+	{.center_freq = 5825, .hw_value = 165, },
+	{.center_freq = 5845, .hw_value = 169, },
+	{.center_freq = 5865, .hw_value = 173, },
+	{.center_freq = 5885, .hw_value = 177, },
+};
+
+static struct ieee80211_supported_band esp_wifi_bands_2ghz = {
+	.channels = esp_channels_2ghz,
+	.n_channels = ARRAY_SIZE(esp_channels_2ghz),
+	.bitrates = esp_rates,
+	.n_bitrates = ARRAY_SIZE(esp_rates),
+	.ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 | IEEE80211_HT_CAP_SGI_20 |
+			IEEE80211_HT_CAP_RX_STBC | IEEE80211_HT_CAP_DSSSCCK40,
+	.ht_cap.mcs.rx_mask[0] = 0xff,
+	.ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
+	.ht_cap.ht_supported = true,
+};
+
+static struct ieee80211_supported_band esp_wifi_bands_5ghz = {
+	.channels = esp_channels_5ghz,
+	.n_channels = ARRAY_SIZE(esp_channels_5ghz),
+	.bitrates = esp_rates,
+	.n_bitrates = ARRAY_SIZE(esp_rates),
+	.ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 | IEEE80211_HT_CAP_SGI_20 |
+			IEEE80211_HT_CAP_RX_STBC | IEEE80211_HT_CAP_DSSSCCK40,
+	.ht_cap.mcs.rx_mask[0] = 0xff,
+	.ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
+	.ht_cap.ht_supported = true,
+};
+
+/* Supported crypto cipher suits to be advertised to cfg80211 */
+static const u32 esp_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_SMS4,
+	WLAN_CIPHER_SUITE_AES_CMAC,
+};
+
+static const u32 esp_cipher_suites_new[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_SMS4,
+	WLAN_CIPHER_SUITE_GCMP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_GCMP_256,
+	WLAN_CIPHER_SUITE_AES_CMAC,
+	WLAN_CIPHER_SUITE_BIP_GMAC_128,
+	WLAN_CIPHER_SUITE_BIP_GMAC_256,
+};
+
+static const struct wiphy_wowlan_support esp_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT | WIPHY_WOWLAN_4WAY_HANDSHAKE,
+	.n_patterns = 0,
+	.pattern_max_len = 0,
+	.pattern_min_len = 0,
+	.max_pkt_offset = 0,
+};
+
+/* TODO get MAX_TX_POWER_MBM from Firmware for future chips */
+#define MAX_TX_POWER_MBM (20 * 100)
+#define MIN_TX_POWER_MBM (8 * 100)
+static bool is_txpwr_valid(int mbm)
+{
+	if (mbm > MAX_TX_POWER_MBM)
+		return false;
+
+	if (mbm < MIN_TX_POWER_MBM)
+		return false;
+
+	return true;
+}
+
+static int mbm_to_esp_pwr(int mbm)
+{
+	return ((mbm * 4) / 100);
+}
+
+static int esp_pwr_to_dbm(int power)
+{
+	return ((power / 4));
+}
+
+static int esp_inetaddr_event(struct notifier_block *nb,
+	unsigned long event, void *data)
+{
+	struct in_ifaddr *ifa = data;
+	struct net_device *netdev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;
+	struct esp_wifi_device *priv;
+	struct esp_adapter *adapter = esp_get_adapter();
+	struct esp_wifi_device *esp_priv = adapter->priv[0];
+
+	if (!netdev)
+		return 0;
+
+	esp_verbose("------- IP event for interface %s -------\n", netdev->name);
+
+	priv = netdev_priv(netdev);
+	if (esp_priv != priv)
+		return 0;
+
+	switch (event) {
+
+	case NETDEV_UP:
+		esp_info("NETDEV_UP interface %s ip changed to  %pi4\n",
+				netdev->name, &ifa->ifa_local);
+		if (priv && (priv->if_type == ESP_STA_IF))
+			cmd_set_ip_address(priv, ifa->ifa_local);
+		break;
+
+	case NETDEV_DOWN:
+		if (priv && (priv->if_type == ESP_STA_IF)) {
+			cmd_set_ip_address(priv, 0);
+			esp_info("Interface %s Down: %d\n", netdev->name, priv->if_type);
+		}
+		break;
+	}
+
+	return 0;
+}
+
+struct wireless_dev *esp_cfg80211_add_iface(struct wiphy *wiphy,
+		const char *name,
+		unsigned char name_assign_type,
+		enum nl80211_iftype type,
+		struct vif_params *params)
+{
+	struct esp_device *esp_dev = NULL;
+/*	struct wireless_dev *wdev = NULL;*/
+	struct net_device *ndev;
+	struct esp_wifi_device *esp_wdev;
+	uint8_t esp_nw_if_num = 0;
+
+	if (!wiphy || !name) {
+		esp_info("%u invalid input\n", __LINE__);
+		return NULL;
+	}
+
+	esp_dev = wiphy_priv(wiphy);
+
+	if (!esp_dev || !esp_dev->adapter) {
+		esp_info("%u invalid input\n", __LINE__);
+		return NULL;
+	}
+
+	if (type == NL80211_IFTYPE_STATION) {
+		esp_nw_if_num = ESP_STA_NW_IF;
+	} else if (type == NL80211_IFTYPE_AP) {
+		esp_nw_if_num = ESP_AP_NW_IF;
+	} else {
+		esp_info("%u network type[%u] is not supported\n",
+				 __LINE__, type);
+		return NULL;
+	}
+
+	ndev = ALLOC_NETDEV(sizeof(struct esp_wifi_device), name, name_assign_type,
+			ether_setup);
+
+	if (!ndev)
+		return ERR_PTR(-ENOMEM);
+
+	set_bit(ESP_DRIVER_ACTIVE, &esp_dev->adapter->state_flags);
+	esp_wdev = netdev_priv(ndev);
+
+	ndev->ieee80211_ptr = &esp_wdev->wdev;
+	esp_wdev->wdev.wiphy = wiphy;
+	esp_wdev->esp_dev = esp_dev;
+	esp_wdev->ndev = ndev;
+	esp_wdev->adapter = esp_dev->adapter;
+	esp_wdev->adapter->priv[esp_nw_if_num] = esp_wdev;
+	esp_wdev->tx_pwr = mbm_to_esp_pwr(MAX_TX_POWER_MBM);
+	esp_verbose("Updated priv[%u] to %px\n",
+                esp_nw_if_num, esp_wdev->adapter->priv[esp_nw_if_num]);
+	dev_net_set(ndev, wiphy_net(wiphy));
+	SET_NETDEV_DEV(ndev, wiphy_dev(esp_wdev->wdev.wiphy));
+	esp_wdev->wdev.netdev = ndev;
+	esp_wdev->wdev.iftype = type;
+
+	init_waitqueue_head(&esp_wdev->wait_for_scan_completion);
+	esp_wdev->stop_data = 1;
+	esp_wdev->port_open = 0;
+
+#ifdef TODO
+	if (cmd_update_fw_time(esp_wdev))
+		goto free_and_return;
+#endif
+
+	if (cmd_init_interface(esp_wdev))
+		goto free_and_return;
+
+	if (cmd_get_mac(esp_wdev))
+		goto free_and_return;
+
+	ETH_HW_ADDR_SET(ndev, esp_wdev->mac_address);
+
+	esp_init_priv(ndev);
+
+	if (register_netdevice(ndev))
+		goto free_and_return;
+
+
+	set_bit(ESP_NETWORK_UP, &esp_wdev->priv_flags);
+
+	esp_wdev->nb.notifier_call = esp_inetaddr_event;
+	register_inetaddr_notifier(&esp_wdev->nb);
+
+	return &esp_wdev->wdev;
+
+free_and_return:
+	clear_bit(ESP_DRIVER_ACTIVE, &esp_wdev->adapter->state_flags);
+	dev_net_set(ndev, NULL);
+	free_netdev(ndev);
+	esp_wdev->ndev = NULL;
+	esp_wdev->wdev.netdev = NULL;
+	ndev = NULL;
+	return NULL;
+}
+
+#if 0
+static int esp_cfg80211_del_iface(struct wiphy *wiphy,
+							  struct wireless_dev *wdev)
+{
+	return 0;
+}
+#endif
+
+static int esp_nl_mode_to_esp_iface(enum nl80211_iftype type)
+{
+	if (type == NL80211_IFTYPE_STATION) {
+		return ESP_STA_IF;
+	} else if (type == NL80211_IFTYPE_AP) {
+		return ESP_AP_IF;
+	}
+
+	return ESP_MAX_IF;
+}
+
+static int8_t esp_get_mode_from_iface_type(int iface_type)
+{
+	if (iface_type == ESP_AP_IF) {
+		return WIFI_MODE_APSTA;
+	}
+
+	return WIFI_MODE_STA;
+}
+
+static int esp_cfg80211_change_iface(struct wiphy *wiphy,
+					struct net_device *dev,
+					enum nl80211_iftype type,
+					struct vif_params *params)
+{
+	struct esp_wifi_device *priv = NULL;
+	enum ESP_INTERFACE_TYPE esp_if_type;
+	int ret;
+
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		esp_err("empty priv\n");
+		return -EINVAL;
+	}
+
+	esp_if_type = esp_nl_mode_to_esp_iface(type);
+	esp_info("current iface type=%d new iface type=%d\n", priv->if_type, esp_if_type);
+	if (esp_if_type == ESP_MAX_IF) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	if (esp_if_type == priv->if_type) {
+		esp_info("%u operating in same mode\n", __LINE__);
+		return 0;
+	}
+
+	ret = cmd_set_mode(priv, esp_get_mode_from_iface_type(esp_if_type));
+
+	if (ret == 0) {
+		priv->if_type = esp_if_type;
+		priv->wdev.iftype = type;
+		/* update Mac address of interface */
+		cmd_get_mac(priv);
+		ETH_HW_ADDR_SET(dev, priv->mac_address/*mac_addr->sa_data*/);
+	}
+
+	esp_info("wdev iftype=%d, ret=%d\n", priv->wdev.iftype, ret);
+	if (esp_if_type == ESP_AP_IF)
+		esp_port_open(priv);
+
+	return ret;
+}
+
+static int esp_cfg80211_scan(struct wiphy *wiphy,
+		struct cfg80211_scan_request *request)
+{
+
+	struct net_device *ndev = NULL;
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !request || !request->wdev || !request->wdev->netdev) {
+		esp_info("%u invalid input\n", __LINE__);
+		return -EINVAL;
+	}
+
+	ndev = request->wdev->netdev;
+	priv = netdev_priv(ndev);
+
+	esp_dbg("\n");
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return -EINVAL;
+	}
+
+	return cmd_scan_request(priv, request);
+}
+
+#if 0
+static int esp_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
+							  struct cfg80211_connect_params *sme)
+{
+	struct esp_wifi_device *priv = netdev_priv(dev);
+
+	esp_dbg("\n");
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return -EINVAL;
+	}
+
+	return cmd_connect_request(priv, sme);
+}
+#endif
+
+static int esp_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+				struct ieee80211_channel *chan,
+				bool offchan, unsigned int wait, const u8 *buf, size_t len,
+				bool no_cck, bool dont_wait_for_ack,
+#else
+				struct cfg80211_mgmt_tx_params *params,
+#endif
+		u64 *cookie)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !wdev || !params) {
+		esp_info("%u invalid input\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(wdev->netdev);
+
+	if (!priv) {
+		esp_err("empty priv\n");
+		return 0;
+	}
+
+	return cmd_mgmt_request(priv, params);
+}
+
+static int esp_cfg80211_set_ap_chanwidth(struct wiphy *wiphy,
+					 struct net_device *dev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
+					 unsigned int link_id,
+#endif
+					 struct cfg80211_chan_def *chandef)
+{
+	esp_info("%u \n", __LINE__);
+	return 0;
+}
+
+static int esp_cfg80211_set_default_key(struct wiphy *wiphy,
+					struct net_device *dev, INT_LINK_ID
+					u8 key_index, bool unicast, bool multicast)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		esp_err("Empty priv");
+		return -EINVAL;
+	}
+
+	return cmd_set_default_key(priv, key_index);
+}
+
+static int esp_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
+					     struct net_device *ndev, INT_LINK_ID u8 key_index)
+{
+	return 0;
+}
+
+static int esp_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
+				INT_LINK_ID u8 key_index, bool pairwise,
+				const u8 *mac_addr)
+{
+	return 0;
+}
+
+static int esp_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+				INT_LINK_ID u8 key_index, bool pairwise,
+				const u8 *mac_addr, struct key_params *params)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !params) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return -EINVAL;
+	}
+	esp_dbg("\n");
+
+	if (params->key_len == 0) {
+		return esp_cfg80211_del_key(wiphy, dev, ZERO_LINK_ID key_index, pairwise, mac_addr);
+	}
+	return cmd_add_key(priv, key_index, pairwise, mac_addr, params);
+}
+
+static int esp_cfg80211_disconnect(struct wiphy *wiphy,
+		struct net_device *dev, u16 reason_code)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		esp_info("%u invalid input\n",  __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		esp_err("empty priv\n");
+		return 0;
+	}
+	esp_dbg("\n");
+
+	return cmd_disconnect_request(priv, reason_code, NULL);
+}
+
+static int esp_cfg80211_authenticate(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_auth_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		esp_info("%u invalid input\n", __LINE__);
+		return -EINVAL;
+	}
+
+	esp_dbg("\n");
+
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return 0;
+	}
+
+	return cmd_auth_request(priv, req);
+}
+
+
+static int esp_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_assoc_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		esp_info("%u invalid input\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+
+	esp_dbg("\n");
+
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return 0;
+	}
+
+	return cmd_assoc_request(priv, req);
+}
+
+static int esp_cfg80211_deauth(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_deauth_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		esp_info("%u invalid input\n", __LINE__);
+		return -EINVAL;
+	}
+
+	esp_dbg("\n");
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return 0;
+	}
+
+	return cmd_disconnect_request(priv, req->reason_code, req->bssid);
+}
+
+static int esp_cfg80211_disassoc(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_disassoc_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		esp_info("%u invalid input\n", __LINE__);
+		return -EINVAL;
+	}
+
+	esp_dbg("\n");
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return 0;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	return cmd_disconnect_request(priv, req->reason_code, req->ap_addr);
+#else
+	return cmd_disconnect_request(priv, req->reason_code, req->bss->bssid);
+#endif
+}
+
+static int esp_cfg80211_suspend(struct wiphy *wiphy,
+			struct cfg80211_wowlan *wowlan)
+{
+	struct esp_adapter *adapter = esp_get_adapter();
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !adapter) {
+		esp_info("%u invalid input wiphy=%p adapter=%p\n", __LINE__, wiphy, adapter);
+		return -EINVAL;
+	}
+
+	if (!wowlan) {
+		esp_dbg("%u wow config is not set, still suspending\n", __LINE__);
+		return 0;
+	}
+
+	esp_dbg("wow any=%d disconnect=%d magic_pkt=%d four_way_handshake=%d eap_identity_req=%d",
+		    wowlan->any, wowlan->disconnect, wowlan->magic_pkt,
+		    wowlan->four_way_handshake, wowlan->eap_identity_req);
+
+	priv = adapter->priv[0];
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return 0;
+	}
+
+	return cmd_set_wow_config(priv, wowlan);
+}
+
+static int esp_cfg80211_resume(struct wiphy *wiphy)
+{
+	struct esp_adapter *adapter = esp_get_adapter();
+	struct esp_wifi_device *priv = NULL;
+	struct cfg80211_wowlan wowlan = {0};
+
+	esp_dbg("\n");
+	if (!wiphy || !adapter) {
+		esp_info("%u invalid input %p %p\n", __LINE__, wiphy, adapter);
+		return -EINVAL;
+	}
+
+	priv = adapter->priv[0];
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return 0;
+	}
+
+	return cmd_set_wow_config(priv, &wowlan);
+}
+
+static void esp_cfg80211_set_wakeup(struct wiphy *wiphy,
+			bool enabled)
+{
+	/*esp_dbg("\n");*/
+}
+
+static int esp_cfg80211_set_tx_power(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     enum nl80211_tx_power_setting type, int mbm)
+{
+	struct esp_adapter *adapter = esp_get_adapter();
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !adapter) {
+		esp_info("%u invalid input %p %p \n", __LINE__, wiphy, wdev);
+		return -EINVAL;
+	}
+
+	esp_dbg("\n");
+
+	priv = adapter->priv[0];
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return 0;
+	}
+
+        switch (type) {
+        case NL80211_TX_POWER_AUTOMATIC:
+                priv->tx_pwr_type = NL80211_TX_POWER_AUTOMATIC;
+                priv->tx_pwr = mbm_to_esp_pwr(MAX_TX_POWER_MBM);
+                break;
+        case NL80211_TX_POWER_LIMITED:
+                if (!is_txpwr_valid(mbm)) {
+                        esp_warn("mbm:%d not support\n", mbm);
+			return -EINVAL;
+                }
+                priv->tx_pwr_type = NL80211_TX_POWER_LIMITED;
+                priv->tx_pwr = mbm_to_esp_pwr(mbm);
+                break;
+        case NL80211_TX_POWER_FIXED:
+		return -EOPNOTSUPP;
+                break;
+        default:
+                esp_warn("unknown type:%d\n", type);
+        }
+
+	return cmd_set_tx_power(priv, priv->tx_pwr);
+}
+
+static int esp_cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,
+				    const u8 *mac, struct station_info *sinfo)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	priv = netdev_priv(ndev);
+
+	if (!mac || !priv) {
+		esp_err("mac=%p priv=%p\n", mac, priv);
+		return -ENOENT;
+	}
+	if (wireless_dev_current_bss_exists(&priv->wdev)) {
+
+		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+		cmd_get_rssi(priv);
+		sinfo->signal = priv->rssi;
+
+		sinfo->filled |= BIT(NL80211_STA_INFO_RX_BYTES);
+		sinfo->rx_bytes = priv->stats.rx_bytes;
+		sinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);
+		sinfo->rx_packets = priv->stats.rx_packets;
+
+		sinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES);
+		sinfo->tx_bytes = priv->stats.tx_bytes;
+		sinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);
+		sinfo->tx_packets = priv->stats.tx_packets;
+
+		sinfo->filled |= BIT(NL80211_STA_INFO_TX_FAILED);
+		sinfo->tx_failed = priv->stats.tx_dropped;
+	}
+
+	return 0;
+}
+
+static int esp_cfg80211_get_tx_power(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 14, 0))
+				     unsigned int link_id,
+#endif
+				     int *dbm)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !wdev || !dbm || !wdev->netdev) {
+		esp_info("%u invalid input\n", __LINE__);
+		return -EINVAL;
+	}
+
+	esp_dbg("\n");
+	priv = netdev_priv(wdev->netdev);
+
+	if (!priv) {
+		esp_err("Empty priv\n");
+		return -EINVAL;
+	}
+	/* Update Tx power from firmware */
+	cmd_get_tx_power(priv);
+
+	*dbm = esp_pwr_to_dbm(priv->tx_pwr);
+
+	return 0;
+}
+
+static int esp_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	esp_dbg("\n");
+	return 0;
+}
+
+static int esp_cfg80211_set_txq_params(struct wiphy *wiphy, struct net_device *ndev,
+			      struct ieee80211_txq_params *params)
+{
+	esp_dbg("\n");
+	return 0;
+}
+
+static int esp_set_ies(struct esp_wifi_device *priv, struct cfg80211_beacon_data *info)
+{
+	int ret = 0;
+
+#define FIXED_PARAM_LEN 34
+
+	if (info->head_len > FIXED_PARAM_LEN)
+		ret = cmd_set_ie(priv, IE_BEACON_PROBE_HEAD, info->head + FIXED_PARAM_LEN, info->head_len - FIXED_PARAM_LEN);
+
+	if (!ret)
+		ret = cmd_set_ie(priv, IE_BEACON_PROBE_TAIL, info->tail, info->tail_len);
+
+	if (!ret)
+		ret = cmd_set_ie(priv, IE_BEACON, info->beacon_ies, info->beacon_ies_len);
+
+	if (!ret)
+		ret = cmd_set_ie(priv, IE_PROBE_RESP, info->proberesp_ies, info->proberesp_ies_len);
+
+	if (!ret)
+		ret = cmd_set_ie(priv, IE_ASSOC_RESP, info->assocresp_ies, info->assocresp_ies_len);
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0))
+static int esp_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,
+				   struct  cfg80211_ap_update *params)
+{
+	struct cfg80211_beacon_data *info = &params->beacon;
+#else
+static int esp_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,
+				   struct cfg80211_beacon_data *info)
+{
+#endif
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !ndev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(ndev);
+	if (!priv) {
+		esp_err("empty priv\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type != ESP_AP_IF) {
+		esp_err("Interface type is not AP\n");
+		return -EINVAL;
+	}
+
+	return esp_set_ies(priv, info);
+}
+
+static int esp_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_ap_settings *info)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct ieee80211_mgmt *mgmt;
+	u8 *ies;
+	struct esp_ap_config ap_config = {0};
+	int res;
+	int i;
+
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		esp_err("empty priv\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type != ESP_AP_IF) {
+		esp_err("Interface type is not AP\n");
+		return -EINVAL;
+	}
+
+	esp_dbg("\n");
+
+	res = esp_set_ies(priv, &info->beacon);
+
+	ap_config.beacon_interval = info->beacon_interval;
+	//ap_config.dtim_period = info->dtim_period;
+
+	if (info->beacon.head == NULL)
+		return -EINVAL;
+	mgmt = (struct ieee80211_mgmt *) info->beacon.head;
+	ies = mgmt->u.beacon.variable;
+	if (ies > info->beacon.head + info->beacon.head_len)
+		return -EINVAL;
+
+	if (info->ssid == NULL)
+		return -EINVAL;
+	memcpy(ap_config.ssid, info->ssid, info->ssid_len);
+	ap_config.ssid_len = info->ssid_len;
+	if (info->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE)
+		ap_config.ssid_hidden = 1;
+
+	if (info->inactivity_timeout) {
+		ap_config.inactivity_timeout = info->inactivity_timeout;
+	}
+
+	if (info->chandef.chan) {
+		for (i = 0; i < ARRAY_SIZE(esp_channels_2ghz); i++) {
+			if (esp_channels_2ghz[i].center_freq == info->chandef.chan->center_freq) {
+				ap_config.channel = esp_channels_2ghz[i].hw_value;
+				break;
+			}
+		}
+		if (!ap_config.channel && (wiphy->bands[NL80211_BAND_5GHZ] != NULL)) {
+				for (i = 0; i < ARRAY_SIZE(esp_channels_5ghz); i++) {
+					if (esp_channels_5ghz[i].center_freq == info->chandef.chan->center_freq) {
+						ap_config.channel = esp_channels_5ghz[i].hw_value;
+						break;
+					}
+				}
+		}
+	}
+	if (!ap_config.channel)
+		ap_config.channel = 6;
+
+	ap_config.privacy = info->privacy;
+	res = cmd_set_ap_config(priv, &ap_config);
+	if (res < 0)
+		return res;
+
+	return 0;
+}
+
+static int esp_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+				, unsigned int link_id
+#endif
+                                )
+{
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+static void esp_cfg80211_mgmt_frame_registrations(struct wiphy *wiphy,
+						  struct wireless_dev *wdev,
+						  struct mgmt_frame_regs *upd)
+{
+	/* We will forward all the mgmt frame to userspace by default */
+}
+#endif
+
+static int esp_cfg80211_probe_client(struct wiphy *wiphy, struct net_device *dev,
+                                  const u8 *peer, u64 *cookie)
+{
+
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int esp_cfg80211_del_station(struct wiphy *wiphy, struct net_device *dev,
+					struct station_del_parameters *params)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		esp_err("empty priv\n");
+		return -EINVAL;
+	}
+	if (priv->if_type == ESP_AP_IF)
+		return cmd_disconnect_request(priv, params->reason_code, params->mac);
+
+	return 0;
+}
+
+static int esp_cfg80211_add_station(struct wiphy *wiphy, struct net_device *dev,
+				    const u8 *mac,
+				    struct station_parameters *params)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		esp_err("empty priv\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type == ESP_AP_IF)
+		cmd_add_station(priv, mac, params, false);
+
+	return 0;
+}
+
+static int esp_cfg80211_change_station(struct wiphy *wiphy,
+				       struct net_device *dev, const u8 *mac,
+				       struct station_parameters *params)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		esp_err("%u invalid params\n", __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		esp_err("empty priv\n");
+		return -EINVAL;
+	}
+	if (priv->if_type == ESP_AP_IF)
+		return cmd_add_station(priv, mac, params, true);
+
+	return 0;
+}
+
+static struct cfg80211_ops esp_cfg80211_ops = {
+#if 0
+	.add_virtual_intf = esp_cfg80211_add_iface,
+	.del_virtual_intf = esp_cfg80211_del_iface,
+#endif
+	.change_virtual_intf = esp_cfg80211_change_iface,
+	.scan = esp_cfg80211_scan,
+	/*.connect = esp_cfg80211_connect,*/
+	.disconnect = esp_cfg80211_disconnect,
+	.add_key = esp_cfg80211_add_key,
+	.del_key = esp_cfg80211_del_key,
+	.set_default_key = esp_cfg80211_set_default_key,
+	.set_default_mgmt_key = esp_cfg80211_set_default_mgmt_key,
+	.mgmt_tx = esp_cfg80211_mgmt_tx,
+	.auth = esp_cfg80211_authenticate,
+	.deauth = esp_cfg80211_deauth,
+	.disassoc = esp_cfg80211_disassoc,
+	.assoc = esp_cfg80211_associate,
+	.suspend = esp_cfg80211_suspend,
+	.resume = esp_cfg80211_resume,
+	.set_wakeup = esp_cfg80211_set_wakeup,
+	.set_tx_power = esp_cfg80211_set_tx_power,
+	.get_tx_power = esp_cfg80211_get_tx_power,
+	.set_wiphy_params = esp_cfg80211_set_wiphy_params,
+	.set_txq_params = esp_cfg80211_set_txq_params,
+	.change_beacon = esp_cfg80211_change_beacon,
+	.start_ap = esp_cfg80211_start_ap,
+	.stop_ap = esp_cfg80211_stop_ap,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+	.update_mgmt_frame_registrations = esp_cfg80211_mgmt_frame_registrations,
+#endif
+	.probe_client = esp_cfg80211_probe_client,
+	.del_station = esp_cfg80211_del_station,
+	.add_station = esp_cfg80211_add_station,
+	.change_station = esp_cfg80211_change_station,
+	.get_station = esp_cfg80211_get_station,
+	.set_ap_chanwidth = esp_cfg80211_set_ap_chanwidth
+};
+
+static const struct ieee80211_txrx_stypes
+esp_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4),
+	},
+};
+
+static void esp_reg_notifier(struct wiphy *wiphy,
+			     struct regulatory_request *request)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct esp_device *esp_dev = NULL;
+	struct esp_adapter *adapter = esp_get_adapter();
+
+	if (!wiphy || !request) {
+		esp_info("%u invalid input\n", __LINE__);
+		return;
+	}
+
+	if (!test_bit(ESP_INIT_DONE, &adapter->state_flags)) {
+		esp_info("Driver init is ongoing\n");
+		return;
+	}
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &adapter->state_flags)) {
+		esp_info("Driver cleanup is ongoing\n");
+		return;
+	}
+
+	esp_dev = wiphy_priv(wiphy);
+
+	if (!esp_dev || !esp_dev->adapter) {
+		esp_info("%u esp_dev not initialized yet \n", __LINE__);
+		return;
+	}
+
+	priv = esp_dev->adapter->priv[0];
+
+	if (!priv) {
+		esp_info("%u esp_wifi_device not initialized yet \n", __LINE__);
+		return;
+	}
+	esp_info("cfg80211 regulatory domain callback for %c%c, current=%c%c\n",
+		    request->alpha2[0], request->alpha2[1], priv->country_code[0], priv->country_code[1]);
+
+	switch (request->initiator) {
+	case NL80211_REGDOM_SET_BY_DRIVER:
+	case NL80211_REGDOM_SET_BY_CORE:
+	case NL80211_REGDOM_SET_BY_USER:
+	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+		break;
+	default:
+		esp_dbg("unknown regdom initiator: %d\n", request->initiator);
+		return;
+	}
+
+	/* Don't send same regdom info to firmware */
+	if (strncmp(request->alpha2, priv->country_code, strlen(request->alpha2))) {
+		strscpy(priv->country_code, request->alpha2, MAX_COUNTRY_LEN);
+		cmd_set_reg_domain(priv);
+	}
+}
+
+int esp_add_wiphy(struct esp_adapter *adapter)
+{
+	struct wiphy *wiphy;
+	struct esp_device *esp_dev;
+	int ret = 0;
+
+	if (!adapter) {
+		esp_info("adapter not yet initialized\n");
+		return -EINVAL;
+	}
+
+	wiphy = wiphy_new(&esp_cfg80211_ops, sizeof(struct esp_device));
+
+	if (!wiphy) {
+		esp_err("Failed to create wiphy\n");
+		return -EFAULT;
+	}
+
+	adapter->wiphy = wiphy;
+
+	esp_dev = wiphy_priv(wiphy);
+	esp_dev->wiphy = wiphy;
+	esp_dev->adapter = adapter;
+
+	esp_dev->dev = adapter->dev;
+
+	set_wiphy_dev(wiphy, esp_dev->dev);
+
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+#ifdef CONFIG_AP_MODE
+	wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP);
+#endif
+	wiphy->bands[NL80211_BAND_2GHZ] = &esp_wifi_bands_2ghz;
+	if (adapter->chipset == ESP_FIRMWARE_CHIP_ESP32C5) {
+		wiphy->bands[NL80211_BAND_5GHZ] = &esp_wifi_bands_5ghz;
+	}
+	/* Initialize cipher suits */
+	if (adapter->chipset == ESP_FIRMWARE_CHIP_ESP32C3 ||
+	    adapter->chipset == ESP_FIRMWARE_CHIP_ESP32S3 ||
+	    adapter->chipset == ESP_FIRMWARE_CHIP_ESP32C6) {
+		wiphy->cipher_suites = esp_cipher_suites_new;
+		wiphy->n_cipher_suites = ARRAY_SIZE(esp_cipher_suites_new);
+	} else {
+		wiphy->cipher_suites = esp_cipher_suites;
+		wiphy->n_cipher_suites = ARRAY_SIZE(esp_cipher_suites);
+	}
+
+	/* TODO: check and finalize the numbers */
+	wiphy->max_scan_ssids = 10;
+	/*	wiphy->max_match_sets = 10;*/
+	wiphy->max_scan_ie_len = 1000;
+	wiphy->max_sched_scan_ssids = 10;
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+#ifdef CONFIG_PM
+	wiphy->wowlan = &esp_wowlan_support;
+#endif
+	wiphy->mgmt_stypes = esp_default_mgmt_stypes;
+
+	/* Advertise SAE support */
+	wiphy->features |= NL80211_FEATURE_SAE;
+
+	wiphy->reg_notifier = esp_reg_notifier;
+
+	/* set caps */
+	wiphy->flags |= WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;
+	wiphy->flags |= WIPHY_FLAG_REPORTS_OBSS;
+	//wiphy->features |= NL80211_CMD_PROBE_CLIENT;
+	wiphy->features |= NL80211_FEATURE_SK_TX_STATUS;
+
+	ret = wiphy_register(wiphy);
+
+	return ret;
+}
+
+int esp_remove_wiphy(struct esp_adapter *adapter)
+{
+	if (adapter && adapter->wiphy) {
+		wiphy_unregister(adapter->wiphy);
+		wiphy_free(adapter->wiphy);
+		adapter->wiphy = NULL;
+	}
+
+	return 0;
+}
+
+int esp_mark_disconnect(struct esp_wifi_device *priv, uint16_t reason, uint8_t locally_disconnect)
+{
+	if (priv && priv->ndev && wireless_dev_current_bss_exists(&priv->wdev))
+		CFG80211_DISCONNECTED(priv->ndev, reason, NULL, 0, locally_disconnect, GFP_KERNEL);
+
+	return 0;
+}
+
+int esp_mark_scan_done_and_disconnect(struct esp_wifi_device *priv, uint8_t locally_disconnect)
+{
+
+	if (!priv)
+		return -EINVAL;
+
+	if (priv->wdev.iftype != NL80211_IFTYPE_STATION)
+		return 0;
+
+	ESP_MARK_SCAN_DONE(priv, true);
+	return esp_mark_disconnect(priv, 0, locally_disconnect);
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c
new file mode 100644
index 0000000..df716dc
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c
@@ -0,0 +1,2336 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#include "utils.h"
+#include "esp_cmd.h"
+#include "esp_api.h"
+#include "esp_utils.h"
+#include "esp.h"
+#include "esp_cfg80211.h"
+#include "esp_kernel_port.h"
+#include "esp_stats.h"
+
+#define COMMAND_RESPONSE_TIMEOUT (5 * HZ)
+u8 ap_bssid[MAC_ADDR_LEN];
+extern u32 raw_tp_mode;
+
+static int handle_mgmt_tx_done(struct esp_wifi_device *priv,
+				struct command_node *cmd_node);
+
+int internal_scan_request(struct esp_wifi_device *priv, char *ssid,
+		uint8_t channel, uint8_t is_blocking);
+
+struct beacon_probe_fixed_params {
+	__le64 timestamp;
+	__le16 beacon_interval;
+	__le16 cap_info;
+} __packed;
+
+static struct command_node *get_free_cmd_node(struct esp_adapter *adapter)
+{
+	struct command_node *cmd_node;
+
+	spin_lock_bh(&adapter->cmd_free_queue_lock);
+
+	if (list_empty(&adapter->cmd_free_queue)) {
+		spin_unlock_bh(&adapter->cmd_free_queue_lock);
+		esp_err("No free cmd node found\n");
+		return NULL;
+	}
+	cmd_node = list_first_entry(&adapter->cmd_free_queue,
+				    struct command_node, list);
+	list_del(&cmd_node->list);
+	spin_unlock_bh(&adapter->cmd_free_queue_lock);
+
+	cmd_node->cmd_skb = esp_alloc_skb(ESP_SIZE_OF_CMD_NODE);
+	if (!cmd_node->cmd_skb) {
+		esp_err("No free cmd node skb found\n");
+	}
+
+	cmd_node->in_cmd_queue = true;
+
+	return cmd_node;
+}
+
+static inline void reset_cmd_node(struct esp_adapter *adapter, struct command_node *cmd_node)
+{
+	spin_lock_bh(&adapter->cmd_lock);
+
+	if (cmd_node->in_cmd_queue) {
+		esp_verbose("recycling command still in cmd queue\n");
+		spin_lock_bh(&adapter->cmd_pending_queue_lock);
+		list_del(&cmd_node->list);
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+	}
+	cmd_node->cmd_code = 0;
+	if (cmd_node->resp_skb) {
+		dev_kfree_skb_any(cmd_node->resp_skb);
+		cmd_node->resp_skb = NULL;
+	}
+	spin_unlock_bh(&adapter->cmd_lock);
+}
+
+static void queue_cmd_node(struct esp_adapter *adapter,
+		struct command_node *cmd_node, u8 flag_high_prio)
+{
+	spin_lock_bh(&adapter->cmd_pending_queue_lock);
+
+	if (flag_high_prio)
+		list_add_rcu(&cmd_node->list, &adapter->cmd_pending_queue);
+	else
+		list_add_tail_rcu(&cmd_node->list, &adapter->cmd_pending_queue);
+
+	spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+}
+
+static int decode_mac_addr(struct esp_wifi_device *priv,
+		struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct cmd_config_mac_address *header;
+
+	if (!priv || !cmd_node ||
+	    !cmd_node->resp_skb ||
+	    !cmd_node->resp_skb->data) {
+		esp_info("Invalid arg\n");
+		return -1;
+	}
+
+	header = (struct cmd_config_mac_address *) (cmd_node->resp_skb->data);
+
+	if (header->header.cmd_status != CMD_RESPONSE_SUCCESS) {
+		esp_info("Command failed\n");
+		ret = -1;
+	}
+
+	if (priv)
+		memcpy(priv->mac_address, header->mac_addr, MAC_ADDR_LEN);
+	else
+		esp_err("priv not updated\n");
+
+	return ret;
+}
+
+static int decode_rssi(struct esp_wifi_device *priv,
+		struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct cmd_set_get_val *header;
+
+	if (!priv || !cmd_node ||
+	    !cmd_node->resp_skb ||
+	    !cmd_node->resp_skb->data) {
+		esp_info("Invalid arg\n");
+		return -1;
+	}
+
+	header = (struct cmd_set_get_val *) (cmd_node->resp_skb->data);
+
+	if (header->header.cmd_status != CMD_RESPONSE_SUCCESS) {
+		esp_info("Command failed\n");
+		ret = -1;
+	}
+
+	if (priv)
+		priv->rssi = header->value;
+	else
+		esp_err("priv not updated\n");
+
+	return ret;
+}
+
+static int decode_tx_power(struct esp_wifi_device *priv,
+		struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct cmd_set_get_val *header;
+
+	if (!priv || !cmd_node ||
+	    !cmd_node->resp_skb ||
+	    !cmd_node->resp_skb->data) {
+		esp_info("Invalid arg\n");
+		return -1;
+	}
+
+	header = (struct cmd_set_get_val *) (cmd_node->resp_skb->data);
+
+	if (header->header.cmd_status != CMD_RESPONSE_SUCCESS) {
+		esp_info("Command failed\n");
+		ret = -1;
+	}
+
+	if (priv)
+		priv->tx_pwr = header->value;
+	else
+		esp_err("priv not updated\n");
+
+	return ret;
+}
+
+static int decode_disconnect_resp(struct esp_wifi_device *priv, struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct command_header *cmd;
+
+	if (!cmd_node || !cmd_node->resp_skb || !cmd_node->resp_skb->data) {
+		esp_info("Failed. cmd_node:%p\n", cmd_node);
+		if (cmd_node)
+			esp_info("code: %u resp_skb:%p\n",
+					cmd_node->cmd_code, cmd_node->resp_skb);
+		return -1;
+	}
+
+	cmd = (struct command_header *) (cmd_node->resp_skb->data);
+
+	if (cmd->cmd_status != CMD_RESPONSE_SUCCESS) {
+		esp_info("[0x%x] Command failed\n", cmd_node->cmd_code);
+		ret = -1;
+	}
+
+	if (priv)
+		priv->local_disconnect_req = true;
+	else
+		esp_err("priv not updated\n");
+
+	return ret;
+}
+
+
+static int decode_common_resp(struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct command_header *cmd;
+
+
+	if (!cmd_node || !cmd_node->resp_skb || !cmd_node->resp_skb->data) {
+
+		esp_info("Failed. cmd_node:%p\n", cmd_node);
+
+		if (cmd_node)
+			esp_info("code: %u resp_skb:%p\n",
+				 cmd_node->cmd_code, cmd_node->resp_skb);
+
+		return -1;
+	}
+
+	cmd = (struct command_header *) (cmd_node->resp_skb->data);
+
+	if (cmd->cmd_status != CMD_RESPONSE_SUCCESS) {
+		esp_info("[0x%x] Command failed\n", cmd_node->cmd_code);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static void recycle_cmd_node(struct esp_adapter *adapter,
+		struct command_node *cmd_node)
+{
+	if (!adapter || !cmd_node)
+		return;
+
+	reset_cmd_node(adapter, cmd_node);
+
+	spin_lock_bh(&adapter->cmd_free_queue_lock);
+	list_add_tail(&cmd_node->list, &adapter->cmd_free_queue);
+	spin_unlock_bh(&adapter->cmd_free_queue_lock);
+}
+
+
+static int wait_and_decode_cmd_resp(struct esp_wifi_device *priv,
+		struct command_node *cmd_node)
+{
+	struct esp_adapter *adapter = NULL;
+	int ret = 0;
+
+	if (!priv || !priv->adapter || !cmd_node) {
+		esp_info("Invalid params\n");
+		if (priv->adapter) {
+			adapter = priv->adapter;
+			if (adapter && cmd_node)
+				recycle_cmd_node(adapter, cmd_node);
+		}
+		return -EINVAL;
+	}
+
+	adapter = priv->adapter;
+
+	/* wait for command response */
+	ret = wait_event_interruptible_timeout(adapter->wait_for_cmd_resp,
+			adapter->cmd_resp == cmd_node->cmd_code, COMMAND_RESPONSE_TIMEOUT);
+
+	if (!test_bit(ESP_DRIVER_ACTIVE, &adapter->state_flags))
+		return 0;
+
+	if (ret == 0) {
+		esp_err("Command[0x%X] timed out\n", cmd_node->cmd_code);
+		ret = -EINVAL;
+	} else {
+		esp_verbose("Resp for command [0x%X]\n", cmd_node->cmd_code);
+		ret = 0;
+	}
+
+	spin_lock_bh(&adapter->cmd_lock);
+	adapter->cur_cmd = NULL;
+	adapter->cmd_resp = 0;
+	spin_unlock_bh(&adapter->cmd_lock);
+
+	switch (cmd_node->cmd_code) {
+
+	case CMD_SCAN_REQUEST:
+		if (ret == 0)
+			ret = decode_common_resp(cmd_node);
+
+		if (ret)
+			ESP_MARK_SCAN_DONE(priv, false);
+		break;
+
+	case CMD_INIT_INTERFACE:
+	case CMD_DEINIT_INTERFACE:
+	case CMD_STA_AUTH:
+	case CMD_STA_ASSOC:
+	case CMD_STA_CONNECT:
+	case CMD_ADD_KEY:
+	case CMD_DEL_KEY:
+	case CMD_SET_MODE:
+	case CMD_SET_IE:
+	case CMD_AP_CONFIG:
+	case CMD_AP_STATION:
+	case CMD_SET_DEFAULT_KEY:
+	case CMD_SET_IP_ADDR:
+	case CMD_SET_MCAST_MAC_ADDR:
+	case CMD_GET_REG_DOMAIN:
+	case CMD_SET_REG_DOMAIN:
+	case CMD_RAW_TP_ESP_TO_HOST:
+	case CMD_RAW_TP_HOST_TO_ESP:
+	case CMD_SET_WOW_CONFIG:
+	case CMD_SET_TIME:
+	case CMD_START_OTA_UPDATE:
+	case CMD_START_OTA_WRITE:
+	case CMD_START_OTA_END:
+		/* intentional fallthrough */
+		if (ret == 0)
+			ret = decode_common_resp(cmd_node);
+		break;
+
+	case CMD_GET_MAC:
+	case CMD_SET_MAC:
+		if (ret == 0)
+			ret = decode_mac_addr(priv, cmd_node);
+		break;
+	case CMD_DISCONNECT:
+		if (ret == 0)
+			ret = decode_disconnect_resp(priv, cmd_node);
+		break;
+	case CMD_GET_TXPOWER:
+	case CMD_SET_TXPOWER:
+		if (ret == 0)
+			ret = decode_tx_power(priv, cmd_node);
+		break;
+        case CMD_STA_RSSI:
+		if (ret == 0)
+			ret = decode_rssi(priv, cmd_node);
+		break;
+	case CMD_MGMT_TX:
+		if (ret == 0)
+			ret = handle_mgmt_tx_done(priv, cmd_node);
+		break;
+	default:
+		esp_info("Resp for [0x%x] ignored\n", cmd_node->cmd_code);
+		ret = -EINVAL;
+		break;
+	}
+
+	recycle_cmd_node(adapter, cmd_node);
+	return ret;
+}
+
+static void free_esp_cmd_pool(struct esp_adapter *adapter)
+{
+	int i;
+	struct command_node *cmd_pool = NULL;
+
+	if (!adapter || !adapter->cmd_pool)
+		return;
+
+	cmd_pool = adapter->cmd_pool;
+
+	for (i = 0; i < ESP_NUM_OF_CMD_NODES; i++) {
+
+		spin_lock_bh(&adapter->cmd_lock);
+		if (cmd_pool[i].resp_skb) {
+			dev_kfree_skb_any(cmd_pool[i].resp_skb);
+			cmd_pool[i].resp_skb = NULL;
+		}
+		spin_unlock_bh(&adapter->cmd_lock);
+	}
+
+	kfree(adapter->cmd_pool);
+	adapter->cmd_pool = NULL;
+}
+
+static int alloc_esp_cmd_pool(struct esp_adapter *adapter)
+{
+	u16 i;
+
+	struct command_node *cmd_pool = kcalloc(ESP_NUM_OF_CMD_NODES,
+		sizeof(struct command_node), GFP_KERNEL);
+
+	if (!cmd_pool)
+		return -ENOMEM;
+
+	adapter->cmd_pool = cmd_pool;
+
+	for (i = 0; i < ESP_NUM_OF_CMD_NODES; i++) {
+
+		cmd_pool[i].cmd_skb = NULL;
+		cmd_pool[i].resp_skb = NULL;
+		recycle_cmd_node(adapter, &cmd_pool[i]);
+	}
+
+	return 0;
+}
+
+static void esp_cmd_work(struct work_struct *work)
+{
+	int ret;
+	struct command_node *cmd_node = NULL;
+	struct esp_adapter *adapter = NULL;
+	struct esp_payload_header *payload_header = NULL;
+
+	adapter = esp_get_adapter();
+
+	if (!adapter)
+		return;
+
+	if (!test_bit(ESP_DRIVER_ACTIVE, &adapter->state_flags))
+		return;
+
+	synchronize_rcu();
+	spin_lock_bh(&adapter->cmd_lock);
+	if (adapter->cur_cmd) {
+		/* Busy in another command */
+		esp_verbose("Busy in another cmd execution\n");
+		spin_unlock_bh(&adapter->cmd_lock);
+		/* We should queue ourself here and remove the queuing from process_cmd_resp */
+		return;
+	}
+
+	spin_lock_bh(&adapter->cmd_pending_queue_lock);
+
+	if (list_empty(&adapter->cmd_pending_queue)) {
+		/* No command to process */
+		esp_verbose("No more command in queue.\n");
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+
+	cmd_node = list_first_entry(&adapter->cmd_pending_queue,
+				    struct command_node, list);
+	if (!cmd_node) {
+		esp_dbg("cmd node NULL\n");
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+	esp_verbose("Processing Command [0x%X]\n", cmd_node->cmd_code);
+
+	list_del(&cmd_node->list);
+	cmd_node->in_cmd_queue = false;
+
+	/* this should never happen */
+	if (!cmd_node->cmd_skb || !cmd_node->cmd_code) {
+		esp_warn("cmd_node->cmd_skb =%p , cmd_code=[0x%X]\n", cmd_node->cmd_skb, cmd_node->cmd_code);
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+
+	/* Set as current cmd */
+	adapter->cur_cmd = cmd_node;
+
+	adapter->cmd_resp = 0;
+
+	payload_header = (struct esp_payload_header *)cmd_node->cmd_skb->data;
+	if (adapter->capabilities & ESP_CHECKSUM_ENABLED)
+		payload_header->checksum = cpu_to_le16(compute_checksum(cmd_node->cmd_skb->data,
+					payload_header->len+payload_header->offset));
+
+	ret = esp_send_packet(adapter, cmd_node->cmd_skb);
+
+	if (ret) {
+		esp_err("Failed to send command [0x%X]\n", cmd_node->cmd_code);
+		adapter->cur_cmd = NULL;
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+
+	if (!list_empty(&adapter->cmd_pending_queue)) {
+		esp_verbose("Pending cmds, queue work again\n");
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+                /* should we wait before queuing the work again? */
+		queue_work(adapter->cmd_wq, &adapter->cmd_work);
+		return;
+	}
+	spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+	spin_unlock_bh(&adapter->cmd_lock);
+}
+
+static int create_cmd_wq(struct esp_adapter *adapter)
+{
+	adapter->cmd_wq = create_singlethread_workqueue("ESP_CMD_WORK_QUEUE");
+
+	RET_ON_FAIL(!adapter->cmd_wq);
+
+	INIT_WORK(&adapter->cmd_work, esp_cmd_work);
+
+	return 0;
+}
+
+static void destroy_cmd_wq(struct esp_adapter *adapter)
+{
+	if (adapter->cmd_wq) {
+		cancel_work_sync(&adapter->cmd_work);
+		destroy_workqueue(adapter->cmd_wq);
+		adapter->cmd_wq = NULL;
+	}
+	if (adapter->if_rx_workqueue) {
+		flush_workqueue(adapter->if_rx_workqueue);
+	}
+
+}
+
+static struct command_node *prepare_command_request(struct esp_adapter *adapter, u8 cmd_code, u16 len)
+{
+	struct command_header *cmd;
+	struct esp_payload_header *payload_header;
+	struct command_node *node = NULL;
+	struct esp_wifi_device *priv = adapter->priv[0];
+
+	if (!adapter) {
+		esp_info("%u null adapter\n", __LINE__);
+		return NULL;
+	}
+
+	if (!cmd_code || cmd_code >= CMD_MAX) {
+		esp_err("unsupported command code\n");
+		return NULL;
+	}
+	if (!test_bit(ESP_CMD_INIT_DONE, &adapter->state_flags)) {
+		esp_err("command queue init is not done yet\n");
+		return NULL;
+	}
+
+	if (test_bit(ESP_OTA_IN_PROGRESS, &adapter->state_flags)) {
+		if (cmd_code != CMD_START_OTA_UPDATE &&
+			cmd_code != CMD_START_OTA_WRITE &&
+			cmd_code != CMD_START_OTA_END) {
+			esp_err("OTA in progress discarding other commands\n");
+			return NULL;
+		}
+	}
+
+	node = get_free_cmd_node(adapter);
+
+	if (!node || !node->cmd_skb) {
+		esp_err("Failed to get new free cmd node\n");
+		return NULL;
+	}
+
+	node->cmd_code = cmd_code;
+
+	len += sizeof(struct esp_payload_header);
+
+	payload_header = (struct esp_payload_header *)skb_put(node->cmd_skb, len);
+	memset(payload_header, 0, len);
+
+	payload_header->if_type = priv->if_type;
+	payload_header->len = cpu_to_le16(len - sizeof(struct esp_payload_header));
+	payload_header->offset = cpu_to_le16(sizeof(struct esp_payload_header));
+	payload_header->packet_type = PACKET_TYPE_COMMAND_REQUEST;
+
+	cmd = (struct command_header *) (node->cmd_skb->data + payload_header->offset);
+	cmd->cmd_code = cmd_code;
+
+/*	payload_header->checksum = cpu_to_le16(compute_checksum(skb->data, len));*/
+	return node;
+}
+
+int process_cmd_resp(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	if (!skb || !adapter) {
+		esp_err("CMD resp: invalid!\n");
+
+		if (skb)
+			dev_kfree_skb_any(skb);
+
+		return -1;
+	}
+
+	if (!test_bit(ESP_CMD_INIT_DONE, &adapter->state_flags)) {
+		esp_err("CMD resp: cmd init is not done yet\n");
+		if (skb)
+			dev_kfree_skb_any(skb);
+		return -1;
+	}
+
+	spin_lock_bh(&adapter->cmd_lock);
+	if (!adapter->cur_cmd) {
+		struct command_header *header = (struct command_header *) skb->data;
+		esp_err("Command response not expected=%d\n", header->cmd_code);
+		dev_kfree_skb_any(skb);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return -1;
+	}
+
+	adapter->cur_cmd->resp_skb = skb;
+	adapter->cmd_resp = adapter->cur_cmd->cmd_code;
+	spin_unlock_bh(&adapter->cmd_lock);
+
+	wake_up_interruptible(&adapter->wait_for_cmd_resp);
+	queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+	return 0;
+}
+
+static void process_mgmt_tx_status(struct esp_wifi_device * priv,
+				   int status, uint8_t *data, uint32_t len);
+static int handle_mgmt_tx_done(struct esp_wifi_device *priv,
+				struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct cmd_mgmt_tx *header;
+
+	if (!priv || !cmd_node ||
+	    !cmd_node->resp_skb ||
+	    !cmd_node->resp_skb->data) {
+		esp_info("invalid arg\n");
+		return -1;
+	}
+
+	header = (struct cmd_mgmt_tx *) (cmd_node->resp_skb->data);
+
+	if (header->header.cmd_status != CMD_RESPONSE_SUCCESS) {
+		esp_dbg("Command failed\n");
+		ret = 0;
+	}
+
+	if (header->len == 0) {
+		esp_dbg("len is zero, nothing to do...");
+		return ret;
+	}
+
+	process_mgmt_tx_status(priv, header->header.cmd_status == CMD_RESPONSE_SUCCESS,
+			  header->buf, header->len);
+
+	return ret;
+}
+
+static void process_scan_result_event(struct esp_wifi_device *priv,
+		struct scan_event *scan_evt)
+{
+	struct cfg80211_bss *bss = NULL;
+	struct beacon_probe_fixed_params *fixed_params = NULL;
+	struct ieee80211_channel *chan = NULL;
+	u8 *ie_buf = NULL;
+	u64 timestamp;
+	u16 beacon_interval;
+	u16 cap_info;
+	u32 ie_len;
+	int freq;
+	int frame_type = CFG80211_BSS_FTYPE_UNKNOWN; /* int type for older compatibilty */
+
+	if (!priv || !scan_evt) {
+		esp_err("Invalid arguments\n");
+		return;
+	}
+
+	/*if (!priv->scan_in_progress) {
+		return;
+	}*/
+
+	/* End of scan; notify cfg80211 */
+	if (scan_evt->header.status == 0) {
+
+		ESP_MARK_SCAN_DONE(priv, false);
+		if (priv->waiting_for_scan_done) {
+			priv->waiting_for_scan_done = false;
+			wake_up_interruptible(&priv->wait_for_scan_completion);
+		}
+		return;
+	}
+
+	ie_buf = (u8 *) scan_evt->frame;
+	ie_len = le16_to_cpu(scan_evt->frame_len);
+
+	fixed_params = (struct beacon_probe_fixed_params *) ie_buf;
+
+	timestamp = le64_to_cpu(fixed_params->timestamp);
+	beacon_interval = le16_to_cpu(fixed_params->beacon_interval);
+	cap_info = le16_to_cpu(fixed_params->cap_info);
+
+	if (scan_evt->channel > 14) {
+		freq = ieee80211_channel_to_frequency(scan_evt->channel, NL80211_BAND_5GHZ);
+	} else {
+		freq = ieee80211_channel_to_frequency(scan_evt->channel, NL80211_BAND_2GHZ);
+	}
+	chan = ieee80211_get_channel(priv->adapter->wiphy, freq);
+
+	ie_buf += sizeof(struct beacon_probe_fixed_params);
+	ie_len -= sizeof(struct beacon_probe_fixed_params);
+
+	if ((scan_evt->frame_type << 4) == IEEE80211_STYPE_BEACON) {
+		frame_type = CFG80211_BSS_FTYPE_BEACON;
+	} else if ((scan_evt->frame_type << 4) == IEEE80211_STYPE_PROBE_RESP) {
+		frame_type = CFG80211_BSS_FTYPE_PRESP;
+	}
+
+	if (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {
+		bss = CFG80211_INFORM_BSS(priv->adapter->wiphy, chan,
+				frame_type, scan_evt->bssid, timestamp,
+				cap_info, beacon_interval, ie_buf, ie_len,
+				(le32_to_cpu(scan_evt->rssi) * 100), GFP_ATOMIC);
+
+		if (bss)
+			cfg80211_put_bss(priv->adapter->wiphy, bss);
+	} else {
+		esp_info("Scan report: Skip invalid or disabled channel\n");
+	}
+}
+
+static void process_auth_event(struct esp_wifi_device *priv,
+		struct auth_event *event)
+{
+	if (!priv || !event) {
+		esp_err("Invalid arguments\n");
+		return;
+	}
+
+	esp_hex_dump_verbose("Auth frame: ", event->frame, event->frame_len);
+
+	cfg80211_rx_mlme_mgmt(priv->ndev, event->frame, event->frame_len);
+
+}
+
+#define IEEE80211_DEAUTH_FRAME_LEN      (24 /* hdr */ + 2 /* reason */)
+static void process_deauth_event(struct esp_wifi_device *priv, struct disconnect_event *event)
+{
+	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
+	struct ieee80211_mgmt *mgmt = (void *)frame_buf;
+
+	/* build frame */
+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DEAUTH);
+	mgmt->duration = 0; /* initialize only */
+	mgmt->seq_ctrl = 0; /* initialize only */
+	memcpy(mgmt->da, priv->mac_address, ETH_ALEN); /* own address */
+	memcpy(mgmt->sa, event->bssid, ETH_ALEN);
+	memcpy(mgmt->bssid, event->bssid, ETH_ALEN);
+	mgmt->u.deauth.reason_code = cpu_to_le16(event->reason);
+	cfg80211_rx_mlme_mgmt(priv->ndev, frame_buf, IEEE80211_DEAUTH_FRAME_LEN);
+}
+
+static int chan_to_freq(u8 chan)
+{
+	if (chan >= 1 && chan <= 14) {
+		return (2407 + 5 * chan);
+	} else if (chan >= 32 && chan <= 177) {
+		return (5000 + 5 * chan);
+	} else {
+		return -1;
+	}
+}
+
+static void process_mgmt_tx_status(struct esp_wifi_device * priv,
+				   int ack, uint8_t *data, uint32_t len)
+{
+	u64 cookie = 0;
+
+	cfg80211_mgmt_tx_status(&priv->wdev, cookie, data, len,
+				ack, GFP_ATOMIC);
+}
+
+static void process_ap_mgmt_rx(struct esp_wifi_device * priv, struct mgmt_event *event)
+{
+        cfg80211_rx_mgmt(&priv->wdev, chan_to_freq(event->chan),
+                event->rssi, event->frame, event->frame_len, 0);
+}
+
+static void process_disconnect_event(struct esp_wifi_device *priv,
+		struct disconnect_event *event)
+{
+	if (!priv || !event) {
+		esp_err("Invalid arguments\n");
+		return;
+	}
+
+	esp_info("Disconnect event for ssid %s [reason:%d]\n",
+			event->ssid, event->reason);
+
+	//esp_mark_disconnect(priv, event->reason, true);
+	/* Flush previous scan results from kernel */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+	cfg80211_bss_flush(priv->adapter->wiphy);
+#endif
+	esp_port_close(priv);
+
+#if 0
+	if (event->reason >= 200) {
+		priv->local_disconnect_req = true;
+		event->reason = 1;
+	}
+#endif
+	if (priv->local_disconnect_req) {
+		CFG80211_DISCONNECTED(priv->ndev, event->reason, NULL, 0, true, GFP_KERNEL);
+		priv->local_disconnect_req = false;
+	} else {
+		/* Send dummpy deauth to userspace */
+		process_deauth_event(priv, event);
+	}
+}
+
+static void process_assoc_event(struct esp_wifi_device *priv,
+		struct assoc_event *event)
+{
+	u8 mac[6];
+
+	if (!priv || !event) {
+		esp_err("Invalid arguments\n");
+		return;
+	}
+
+	esp_info("Connection status: %d\n", event->header.status);
+
+	memcpy(mac, event->bssid, MAC_ADDR_LEN);
+	priv->rssi = event->rssi;
+
+	CFG80211_RX_ASSOC_RESP(priv->ndev, priv->bss, event->frame, event->frame_len,
+			0, priv->assoc_req_ie, priv->assoc_req_ie_len);
+
+#if 0
+	if (priv->bss) {
+		cfg80211_connect_bss(priv->ndev, mac, priv->bss, NULL, 0, NULL, 0,
+				0, GFP_KERNEL, NL80211_TIMEOUT_UNSPECIFIED);
+	} else {
+		cfg80211_connect_result(priv->ndev, mac, NULL, 0, NULL, 0,
+				0, GFP_KERNEL);
+	}
+#endif
+
+	esp_port_open(priv);
+}
+
+int process_cmd_event(struct esp_wifi_device *priv, struct sk_buff *skb)
+{
+	struct event_header *header;
+
+	if (!skb || !priv) {
+		esp_err("CMD evnt: invalid!\n");
+		return -1;
+	}
+
+	header = (struct event_header *) (skb->data);
+
+	switch (header->event_code) {
+
+	case EVENT_SCAN_RESULT:
+		process_scan_result_event(priv,
+				(struct scan_event *)(skb->data));
+		break;
+
+	case EVENT_ASSOC_RX:
+		process_assoc_event(priv,
+				(struct assoc_event *)(skb->data));
+		break;
+
+	case EVENT_STA_DISCONNECT:
+		process_disconnect_event(priv,
+				(struct disconnect_event *)(skb->data));
+		break;
+
+	case EVENT_AUTH_RX:
+		process_auth_event(priv, (struct auth_event *)(skb->data));
+		break;
+
+	case EVENT_AP_MGMT_RX:
+		process_ap_mgmt_rx(priv,
+				(struct mgmt_event *)(skb->data));
+		break;
+
+	default:
+		esp_info("%u unhandled event[%u]\n",
+				__LINE__, header->event_code);
+		break;
+	}
+
+	return 0;
+}
+
+int cmd_set_mcast_mac_list(struct esp_wifi_device *priv, struct multicast_list *list)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_set_mcast_mac_addr *cmd_mcast_mac_list;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_MCAST_MAC_ADDR,
+			sizeof(struct cmd_set_mcast_mac_addr));
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_mcast_mac_list = (struct cmd_set_mcast_mac_addr *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_mcast_mac_list->count = list->addr_count;
+	memcpy(cmd_mcast_mac_list->mcast_addr, list->mcast_addr,
+			sizeof(cmd_mcast_mac_list->mcast_addr));
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	return 0;
+}
+
+int cmd_set_ip_address(struct esp_wifi_device *priv, u32 ip)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_set_ip_addr *cmd_set_ip;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_IP_ADDR,
+			sizeof(struct cmd_set_ip_addr));
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_set_ip = (struct cmd_set_ip_addr *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_set_ip->ip = cpu_to_le32(ip);
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_disconnect_request(struct esp_wifi_device *priv, u16 reason_code, const uint8_t *mac)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_disconnect *cmd_disconnect;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_DISCONNECT,
+			sizeof(struct cmd_disconnect));
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_disconnect = (struct cmd_disconnect *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_disconnect->reason_code = reason_code;
+	if (mac)
+		memcpy(cmd_disconnect->mac, mac, ETH_ALEN);
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+#if 0
+int cmd_connect_request(struct esp_wifi_device *priv,
+		struct cfg80211_connect_params *params)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_sta_connect *cmd;
+	struct ieee80211_channel *chan;
+	struct cfg80211_bss *bss;
+	struct esp_adapter *adapter = NULL;
+	u8 retry = 2;
+
+	if (!priv || !params || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err("%u cleanup in progress, return failure", __LINE__);
+		return -EFAULT;
+	}
+
+	adapter = priv->adapter;
+
+	cmd_len = sizeof(struct cmd_sta_connect) + params->ie_len;
+
+	cmd_node = prepare_command_request(adapter, CMD_STA_CONNECT, cmd_len);
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+	cmd = (struct cmd_sta_connect *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	if (params->ssid_len)
+		memcpy(cmd->ssid, params->ssid, MAX_SSID_LEN);
+	else
+		esp_err("No ssid\n");
+
+	if (params->bssid) {
+		memcpy(ap_bssid, params->bssid, MAC_ADDR_LEN);
+		memcpy(cmd->bssid, params->bssid, MAC_ADDR_LEN);
+	}
+
+	if (params->channel) {
+		chan = params->channel;
+		cmd->channel = chan->hw_value;
+	}
+
+	if (params->ie_len) {
+		cmd->assoc_ie_len = cpu_to_le16(params->ie_len);
+		memcpy(cmd->assoc_ie, params->ie, params->ie_len);
+	}
+
+	if (params->privacy)
+		cmd->is_auth_open = 0;
+	else
+		cmd->is_auth_open = 1;
+
+	esp_info("Connection request: %s "MACSTR" %d\n",
+			cmd->ssid, MAC2STR(params->bssid), cmd->channel);
+
+	do {
+		bss = cfg80211_get_bss(adapter->wiphy, params->channel, params->bssid,
+				params->ssid, params->ssid_len, IEEE80211_BSS_TYPE_ESS, IEEE80211_PRIVACY_ANY);
+
+		if (bss) {
+			break;
+		} else {
+			esp_info("No BSS in the list.. scanning..\n");
+			internal_scan_request(priv, cmd->ssid, cmd->channel, true);
+		}
+
+		retry--;
+	} while (retry);
+
+	if (retry) {
+		queue_cmd_node(adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+		queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+		RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	} else {
+		esp_info("Failed to find %s\n", cmd->ssid);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+#endif
+
+
+int cmd_assoc_request(struct esp_wifi_device *priv,
+		struct cfg80211_assoc_request *req)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_sta_assoc *cmd;
+	struct cfg80211_bss *bss;
+	struct esp_adapter *adapter = NULL;
+	u16 cmd_len;
+
+	if (!priv || !req || !req->bss || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type != ESP_STA_IF) {
+		esp_err("Invalid interface\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err("%u cleanup in progress, return failure", __LINE__);
+		return -EFAULT;
+	}
+
+	bss = req->bss;
+	adapter = priv->adapter;
+
+	cmd_len = sizeof(struct cmd_sta_assoc) + req->ie_len;
+
+	cmd_node = prepare_command_request(adapter, CMD_STA_ASSOC, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd = (struct cmd_sta_assoc *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd->assoc_ie_len = req->ie_len;
+	memcpy(cmd->assoc_ie, req->ie, req->ie_len);
+
+	/* Make a copy of assoc req IEs */
+	if (priv->assoc_req_ie) {
+		kfree(priv->assoc_req_ie);
+		priv->assoc_req_ie = NULL;
+	}
+
+	priv->assoc_req_ie = kmemdup(req->ie, req->ie_len, GFP_ATOMIC);
+
+	if (!priv->assoc_req_ie) {
+		esp_err("Failed to allocate buffer for assoc request IEs\n");
+		return -ENOMEM;
+	}
+
+	priv->assoc_req_ie_len = req->ie_len;
+
+	esp_info("Association request: "MACSTR" %d %d\n",
+			MAC2STR(bss->bssid), bss->channel->hw_value, cmd->assoc_ie_len);
+
+	queue_cmd_node(adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_auth_request(struct esp_wifi_device *priv,
+		struct cfg80211_auth_request *req)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_sta_auth *cmd;
+	struct cfg80211_bss *bss;
+	/*struct cfg80211_bss *bss1;*/
+	const u8 *ssid_eid = NULL;
+	uint8_t ssid_len;
+	struct esp_adapter *adapter = NULL;
+	u16 cmd_len;
+	const struct cfg80211_bss_ies *ies;
+	/* u8 retry = 2; */
+
+	if (!priv || !req || !req->bss || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type != ESP_STA_IF) {
+		esp_err("Invalid interface\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err(":%u cleanup in progress, return failure", __LINE__);
+		return -EFAULT;
+	}
+
+	bss = req->bss;
+
+	priv->bss = req->bss;
+
+	if (bss->proberesp_ies)
+		ies = bss->proberesp_ies;
+	else if (bss->beacon_ies)
+		ies = bss->beacon_ies;
+	else
+		ies = bss->ies;
+
+	ssid_eid = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);
+	if (!ssid_eid) {
+		esp_err("\n ssid NULL in proberesp");
+		return -EINVAL;
+	} else {
+		ssid_len = *(ssid_eid + 1);
+		ssid_eid = ssid_eid + 2;
+	}
+
+	adapter = priv->adapter;
+
+	cmd_len = sizeof(struct cmd_sta_auth) + req->auth_data_len;
+
+	cmd_node = prepare_command_request(adapter, CMD_STA_AUTH, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+	cmd = (struct cmd_sta_auth *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_FT 2
+#define WLAN_AUTH_SAE 3
+	if (req->auth_type == NL80211_AUTHTYPE_FT) {
+		cmd->auth_type = WLAN_AUTH_FT;
+	} else if (req->auth_type == NL80211_AUTHTYPE_SAE) {
+		cmd->auth_type = WLAN_AUTH_SAE;
+	} else if (req->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) {
+		cmd->auth_type = WLAN_AUTH_OPEN;
+	} else {
+		cmd->auth_type = req->auth_type;
+	}
+	memcpy(cmd->ssid, ssid_eid, ssid_len);
+	memcpy(cmd->bssid, bss->bssid, MAC_ADDR_LEN);
+	cmd->channel = bss->channel->hw_value;
+	cmd->auth_data_len = req->auth_data_len;
+	memcpy(cmd->auth_data, req->auth_data, req->auth_data_len);
+
+	if (req->key_len) {
+		memcpy(cmd->key, req->key, req->key_len);
+		cmd->key_len = req->key_len;
+	}
+	esp_info("Authentication request: "MACSTR" %d %d %d %d\n",
+			MAC2STR(cmd->bssid), cmd->channel, cmd->auth_type, cmd->auth_data_len,
+			(u32) req->ie_len);
+#if 0
+	do {
+		bss1 = cfg80211_get_bss(adapter->wiphy, bss->channel, bss->bssid,
+				NULL, 0, IEEE80211_BSS_TYPE_ESS, IEEE80211_PRIVACY_ANY);
+
+		if (bss1) {
+			break;
+		} else {
+			esp_info("No BSS in the list.. scanning..\n");
+			internal_scan_request(priv, cmd->ssid, cmd->channel, true);
+		}
+
+		retry--;
+	} while (retry);
+#endif
+	queue_cmd_node(adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_mgmt_request(struct esp_wifi_device *priv,
+		     struct cfg80211_mgmt_tx_params *req)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_mgmt_tx *cmd;
+	struct esp_adapter *adapter = NULL;
+	u16 cmd_len;
+
+	if (!priv || !req || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err("%u cleanup in progress, return failure", __LINE__);
+		return -EFAULT;
+	}
+	adapter = priv->adapter;
+
+	cmd_len = sizeof(struct cmd_mgmt_tx) + req->len;
+
+	cmd_node = prepare_command_request(adapter, CMD_MGMT_TX, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+	cmd = (struct cmd_mgmt_tx *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	memcpy(cmd->buf, req->buf, req->len);
+	cmd->len = req->len;
+	cmd->offchan = req->offchan;
+	cmd->wait = req->wait;
+	cmd->no_cck = req->no_cck;
+	cmd->dont_wait_for_ack = req->dont_wait_for_ack;
+
+	//esp_info("Sending mgmt Tx request of len=%d\n", req->len);
+
+	queue_cmd_node(adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+
+
+int cmd_set_default_key(struct esp_wifi_device *priv, u8 key_index)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_key_operation *cmd;
+	struct wifi_sec_key *key = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+#if 0
+	if (key_index > ESP_MAX_KEY_INDEX) {
+		esp_err("invalid key index[%u] > max[%u]\n",
+				key_index, ESP_MAX_KEY_INDEX);
+		return -EINVAL;
+	}
+#endif
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err(":%u cleanup in progress, return", __LINE__);
+		return 0;
+	}
+
+	cmd_len = sizeof(struct cmd_key_operation);
+
+	/* get new cmd node */
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_DEFAULT_KEY, cmd_len);
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	/* cmd specific update */
+	cmd = (struct cmd_key_operation *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+	key = &cmd->key;
+
+	key->index = key_index;
+	key->set_cur = 1;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_del_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_key_operation *cmd;
+	struct wifi_sec_key *key = NULL;
+	const u8 *mac = NULL;
+	const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+#if 0
+	if (key_index > ESP_MAX_KEY_INDEX) {
+		esp_err("invalid key index[%u] > max[%u]\n",
+				key_index, ESP_MAX_KEY_INDEX);
+		return -EINVAL;
+	}
+#endif
+
+	mac = pairwise ? mac_addr : bc_mac;
+
+	cmd_len = sizeof(struct cmd_key_operation);
+
+	/* get new cmd node */
+	cmd_node = prepare_command_request(priv->adapter, CMD_DEL_KEY, cmd_len);
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	/* cmd specific update */
+	cmd = (struct cmd_key_operation *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+	key = &cmd->key;
+
+	if (mac && !is_multicast_ether_addr(mac))
+		memcpy((char *)&key->mac_addr, (void *)mac, MAC_ADDR_LEN);
+
+	key->index = key_index;
+	key->del = 1;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_add_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr, struct key_params *params)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_key_operation *cmd;
+	struct wifi_sec_key *key = NULL;
+	const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	const u8 *mac = NULL;
+
+	esp_verbose("key_idx: %u pairwise: %u params->key_len: %u\n"
+                     "params->seq_len:%u params->mode: 0x%x\n"
+                     "params->cipher: 0x%x\n",
+                     key_index, pairwise, params->key_len, params->seq_len,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 1, 21))
+		     params->mode,
+#else
+		     0,
+#endif
+		     params->cipher);
+	if (!priv || !priv->adapter || !params ||
+	    !params->key || !params->key_len) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+#if 0
+	if (key_index > ESP_MAX_KEY_INDEX) {
+		esp_err("invalid key index[%u] > max[%u]\n",
+				key_index, ESP_MAX_KEY_INDEX);
+		return -EINVAL;
+	}
+#endif
+
+	if (params->key_len > sizeof(key->data)) {
+		esp_err("Too long key length (%u)\n", params->key_len);
+		return -EINVAL;
+	}
+
+	if (params->seq_len > sizeof(key->seq)) {
+		esp_err("Too long key seq length (%u)\n", params->seq_len);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err("%u cleanup in progress, return failure", __LINE__);
+		return -EFAULT;
+	}
+
+	mac = pairwise ? mac_addr : bc_mac;
+	if (mac) {
+		esp_hex_dump_verbose("mac: ", mac, MAC_ADDR_LEN);
+	}
+
+	cmd_len = sizeof(struct cmd_key_operation);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_ADD_KEY, cmd_len);
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd = (struct cmd_key_operation *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+	key = &cmd->key;
+
+	if (mac && !is_multicast_ether_addr(mac))
+		memcpy((char *)&key->mac_addr, (void *)mac, MAC_ADDR_LEN);
+
+	key->index = key_index;
+
+	key->len = params->key_len;
+	if (params->key && key->len)
+		memcpy(key->data, params->key, key->len);
+
+	key->seq_len = params->seq_len;
+	if (params->seq && key->seq_len)
+		memcpy(key->seq, params->seq, key->seq_len);
+
+	key->algo = wpa_cipher_to_alg(params->cipher);
+#if 0
+	if (key->algo == WIFI_WPA_ALG_NONE) {
+		esp_info("CIPHER NONE does not use pairwise keys\n");
+		return 0;
+	}
+#endif
+
+       /* Supplicant swaps tx/rx Mic keys whereas esp needs it normal format */
+       if (key->algo == WIFI_WPA_ALG_TKIP) {
+               u8 buf[8];
+               memcpy(buf, &key->data[16], 8);
+               memcpy(&key->data[16], &key->data[24], 8);
+               memcpy(&key->data[24], buf, 8);
+               memset(buf, 0, 8);
+       }
+
+	esp_verbose("algo: %u idx: %u seq_len: %u len:%u\n",
+			key->algo, key->index, key->seq_len, key->len);
+	esp_hex_dump_verbose("mac", key->mac_addr, 6);
+	esp_hex_dump_verbose("seq", key->seq, key->seq_len);
+	esp_hex_dump_verbose("key_data", key->data, key->len);
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_update_fw_time(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+        struct timespec64 ts;
+	struct command_node *cmd_node = NULL;
+	struct cmd_set_time *val;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+
+        ktime_get_real_ts64(&ts);
+	cmd_len = sizeof(struct cmd_set_time);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_TIME, cmd_len);
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+	val = (struct cmd_set_time *) (cmd_node->cmd_skb->data +
+				sizeof(struct esp_payload_header));
+
+	val->sec = ts.tv_sec;
+        val->usec = ts.tv_nsec / 1000;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_init_interface(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_INIT_INTERFACE, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_deinit_interface(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter)
+		return -EINVAL;
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err("%u cleanup in progress, return\n", __LINE__);
+		return 0;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_DEINIT_INTERFACE, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int internal_scan_request(struct esp_wifi_device *priv, char *ssid,
+		uint8_t channel, uint8_t is_blocking)
+{
+	int ret = 0;
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct scan_request *scan_req;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (priv->scan_in_progress) {
+		esp_err("Scan in progress.. return\n");
+		return -EBUSY;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err("%u cleanup in progress, return", __LINE__);
+		return -EBUSY;
+	}
+
+	cmd_len = sizeof(struct scan_request);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SCAN_REQUEST, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	scan_req = (struct scan_request *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+
+	if (ssid) {
+		memcpy(scan_req->ssid, ssid, MAX_SSID_LEN);
+	}
+
+	scan_req->channel = channel;
+
+	priv->scan_in_progress = true;
+
+	if (is_blocking)
+		priv->waiting_for_scan_done = true;
+
+	/* Enqueue command */
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	ret = wait_and_decode_cmd_resp(priv, cmd_node);
+
+	if (!ret && is_blocking) {
+		/* Wait for scan done */
+		wait_event_interruptible_timeout(priv->wait_for_scan_completion,
+				priv->waiting_for_scan_done != true, COMMAND_RESPONSE_TIMEOUT);
+	}
+
+	return ret;
+}
+
+int cmd_scan_request(struct esp_wifi_device *priv, struct cfg80211_scan_request *request)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct scan_request *scan_req;
+
+	if (!priv || !priv->adapter || !request) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		esp_err("%u cleanup in progress, return", __LINE__);
+		return -EBUSY;
+	}
+
+	if (priv->scan_in_progress || priv->request) {
+		esp_err("Scan in progress.. return\n");
+		return -EBUSY;
+	}
+
+	cmd_len = sizeof(struct scan_request);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SCAN_REQUEST, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	scan_req = (struct scan_request *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+
+	/* TODO: Handle case of multiple SSIDs or channels */
+	if (request->ssids && request->ssids[0].ssid_len) {
+		memcpy(scan_req->ssid, request->ssids[0].ssid, MAX_SSID_LEN);
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 8, 0)
+	scan_req->duration = request->duration;
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
+	memcpy(scan_req->bssid, request->bssid, MAC_ADDR_LEN);
+#endif
+
+	priv->scan_in_progress = true;
+	priv->request = request;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_process_ota_start(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_START_OTA_UPDATE, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+
+}
+
+int cmd_process_ota_write(struct esp_wifi_device *priv, char *ota_chunk, ssize_t nread)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_ota_update_request * cmd_ota_req = NULL;
+
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct cmd_ota_update_request) + nread;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_START_OTA_WRITE, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_ota_req = (struct cmd_ota_update_request *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+
+	cmd_ota_req->ota_binary_len = nread;
+	memcpy(cmd_ota_req->ota_binary, ota_chunk, nread);
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+
+}
+
+int cmd_process_ota_end(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_START_OTA_END, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+
+}
+
+int cmd_init_raw_tp_task_timer(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	if (raw_tp_mode == ESP_TEST_RAW_TP_ESP_TO_HOST) {
+		cmd_node = prepare_command_request(priv->adapter, CMD_RAW_TP_ESP_TO_HOST, cmd_len);
+	} else if (raw_tp_mode == ESP_TEST_RAW_TP_HOST_TO_ESP) {
+		cmd_node = prepare_command_request(priv->adapter, CMD_RAW_TP_HOST_TO_ESP, cmd_len);
+	}
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_get_rssi(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type != ESP_STA_IF) {
+		esp_err("Invalid interface\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header) + sizeof(int32_t);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_STA_RSSI, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_get_mac(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_GET_MAC, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_set_mac(struct esp_wifi_device *priv, uint8_t *mac_addr)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_config_mac_address *cmd;;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct cmd_config_mac_address);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_MAC, cmd_len);
+
+	cmd = (struct cmd_config_mac_address *) (cmd_node->cmd_skb->data +
+				sizeof(struct esp_payload_header));
+
+	memcpy(cmd->mac_addr, mac_addr, MAC_ADDR_LEN);
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	return 0;
+}
+
+int cmd_set_mode(struct esp_wifi_device *priv, uint8_t mode)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_config_mode *cmd_mode;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_MODE,
+			sizeof(struct cmd_config_mode));
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_mode = (struct cmd_config_mode *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_mode->mode = mode;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	return 0;
+}
+
+int cmd_set_ie(struct esp_wifi_device *priv, enum ESP_IE_TYPE type, const uint8_t *ie, size_t ie_len)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_config_ie *cmd_ie;
+	size_t cmd_len;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_len = sizeof(struct cmd_config_ie) + ie_len;
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_IE, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_ie = (struct cmd_config_ie *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_ie->ie_type = type;
+	cmd_ie->ie_len = ie_len;
+	memcpy(cmd_ie->ie, ie, ie_len);
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	return 0;
+}
+
+
+int cmd_set_ap_config(struct esp_wifi_device *priv, struct esp_ap_config *ap_config)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_ap_config *cmd_config;
+	size_t cmd_len;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type != ESP_AP_IF) {
+		esp_err("Invalid interface\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_len = sizeof(struct cmd_ap_config);
+	cmd_node = prepare_command_request(priv->adapter, CMD_AP_CONFIG, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_config = (struct cmd_ap_config *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	memcpy(&cmd_config->ap_config, ap_config, sizeof(struct esp_ap_config));
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	return 0;
+}
+
+int esp_cfg_cleanup(struct esp_adapter *adapter)
+{
+	struct esp_wifi_device *priv = NULL;
+	uint8_t iface_idx = 0;
+
+	for (iface_idx = 0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+		priv = adapter->priv[iface_idx];
+		if (!priv)
+			continue;
+
+		if (priv->wdev.iftype == NL80211_IFTYPE_STATION)
+			esp_mark_scan_done_and_disconnect(priv, false);
+
+		esp_port_close(priv);
+	}
+
+	return 0;
+}
+
+int esp_commands_teardown(struct esp_adapter *adapter)
+{
+	if (!adapter) {
+		return -EINVAL;
+	}
+
+	if (!test_bit(ESP_CMD_INIT_DONE, &adapter->state_flags))
+		return 0;
+
+	set_bit(ESP_CLEANUP_IN_PROGRESS, &adapter->state_flags);
+	clear_bit(ESP_CMD_INIT_DONE, &adapter->state_flags);
+	destroy_cmd_wq(adapter);
+	free_esp_cmd_pool(adapter);
+
+	return 0;
+}
+
+int esp_commands_setup(struct esp_adapter *adapter)
+{
+	if (!adapter) {
+		esp_err("no adapter\n");
+		return -EINVAL;
+	}
+
+	init_waitqueue_head(&adapter->wait_for_cmd_resp);
+
+	spin_lock_init(&adapter->cmd_lock);
+
+	INIT_LIST_HEAD(&adapter->cmd_pending_queue);
+	INIT_LIST_HEAD(&adapter->cmd_free_queue);
+
+	spin_lock_init(&adapter->cmd_pending_queue_lock);
+	spin_lock_init(&adapter->cmd_free_queue_lock);
+
+	RET_ON_FAIL(create_cmd_wq(adapter));
+
+	RET_ON_FAIL(alloc_esp_cmd_pool(adapter));
+
+	set_bit(ESP_CMD_INIT_DONE, &adapter->state_flags);
+	return 0;
+}
+
+int cmd_set_wow_config(struct esp_wifi_device *priv, struct cfg80211_wowlan *wowlan)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_wow_config *config;;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct cmd_wow_config);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_WOW_CONFIG, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	config = (struct cmd_wow_config *) (cmd_node->cmd_skb->data +
+				sizeof(struct esp_payload_header));
+
+	config->any = wowlan->any;
+	config->disconnect = wowlan->disconnect;
+	config->magic_pkt = wowlan->magic_pkt;
+	config->four_way_handshake = wowlan->four_way_handshake;
+	config->eap_identity_req = wowlan->eap_identity_req;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_set_tx_power(struct esp_wifi_device *priv, int power)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_set_get_val *val;;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_len = sizeof(struct cmd_set_get_val);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_TXPOWER, cmd_len);
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+	val = (struct cmd_set_get_val *) (cmd_node->cmd_skb->data +
+				sizeof(struct esp_payload_header));
+
+	val->value = power;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_add_station(struct esp_wifi_device *priv, const uint8_t *mac,
+		    struct station_parameters *sta, bool is_changed)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_ap_add_sta_config *cmd_config;
+	size_t cmd_len;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	struct link_station_parameters *rate_params = &sta->link_sta_params;
+#else
+	struct station_parameters *rate_params = sta;
+#endif
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (priv->if_type != ESP_AP_IF) {
+		esp_err("Invalid interface\n");
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_len = sizeof(struct cmd_ap_add_sta_config);
+	cmd_node = prepare_command_request(priv->adapter, CMD_AP_STATION, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_config = (struct cmd_ap_add_sta_config *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	memcpy(cmd_config->sta_param.mac, mac, 6);
+	if (is_changed)
+		cmd_config->sta_param.cmd = CHANGE_STA;
+	else
+		cmd_config->sta_param.cmd = ADD_STA;
+	cmd_config->sta_param.sta_flags_mask = sta->sta_flags_mask;
+	cmd_config->sta_param.sta_flags_set = sta->sta_flags_set;
+	cmd_config->sta_param.sta_modify_mask = sta->sta_modify_mask;
+	cmd_config->sta_param.listen_interval = sta->listen_interval;
+	cmd_config->sta_param.aid = sta->aid;
+
+	if (sta->ext_capab_len && sta->ext_capab) {
+		if (sta->ext_capab_len > 4)
+			sta->ext_capab_len = 4;
+		memcpy(cmd_config->sta_param.ext_capab, sta->ext_capab, sta->ext_capab_len);
+	}
+
+	if (rate_params->supported_rates_len && rate_params->supported_rates) {
+		cmd_config->sta_param.supported_rates[0] = WLAN_EID_SUPP_RATES;
+		cmd_config->sta_param.supported_rates[1] = 10;
+		memcpy(&cmd_config->sta_param.supported_rates[2], rate_params->supported_rates, 10);
+	}
+
+	if (rate_params->ht_capa) {
+		cmd_config->sta_param.ht_caps[0] = WLAN_EID_HT_CAPABILITY;
+		cmd_config->sta_param.ht_caps[1] = 26;
+		memcpy(&cmd_config->sta_param.ht_caps[2], rate_params->ht_capa, 26);
+	}
+	if (rate_params->vht_capa) {
+		cmd_config->sta_param.vht_caps[0] = WLAN_EID_VHT_CAPABILITY;
+		cmd_config->sta_param.vht_caps[1] = 12;
+		memcpy(&cmd_config->sta_param.vht_caps[2], rate_params->vht_capa, 12);
+	}
+	if (rate_params->he_capa) {
+		cmd_config->sta_param.he_caps[0] = WLAN_EID_EXTENSION;
+		cmd_config->sta_param.he_caps[1] = 25;
+		cmd_config->sta_param.he_caps[2] = WLAN_EID_EXT_HE_CAPABILITY;
+		memcpy(&cmd_config->sta_param.he_caps[3], rate_params->he_capa, 24);
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_get_tx_power(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header) + sizeof(int32_t);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_GET_TXPOWER, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_get_reg_domain(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct cmd_reg_domain);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_GET_REG_DOMAIN, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_set_reg_domain(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_reg_domain *cmd;
+
+	if (!priv || !priv->adapter) {
+		esp_err("Invalid argument\n");
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct cmd_reg_domain);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_REG_DOMAIN, cmd_len);
+
+	if (!cmd_node) {
+		esp_err("Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd = (struct cmd_reg_domain *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	strscpy(cmd->country_code, priv->country_code, MAX_COUNTRY_LEN);
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_debugfs.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_debugfs.c
new file mode 100644
index 0000000..4399cab
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_debugfs.c
@@ -0,0 +1,287 @@
+#include "utils.h"
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+
+#define DEBUGFS_DIR_NAME "esp32"
+#define LOG_LEVEL "log_level"
+#define VERSION "version"
+
+#define DEBUGFS_TODO 0
+
+#if DEBUGFS_TODO
+#define DEBUGFS_LOG_LEVEL "debugfs_log_level"
+#define HOST_LOGS "logs"
+#define FW_LOGS "fw_logs"
+#define FW_LOGS_LEVEL "fw_logs_level"
+#endif
+
+#define LOG_BUFFER_SIZE 2048
+
+struct esp32_debugfs {
+	struct dentry *debugfs_dir;
+	struct dentry *log_level_file; /* log level for host dmesg */
+	struct dentry *version;
+#if DEBUGFS_TODO
+	struct dentry *host_log_level_file; /* log level for host logs in debugfs logger */
+	struct dentry *host_log_file; /* debugfs host logger */
+
+	struct dentry *fw_log_level_file; /* debugfs firmware log level */
+	struct dentry *fw_log_file; /* debugfs firmware logger */
+#endif
+};
+struct esp32_debugfs drv_debugfs;
+
+
+// Define a variable to store the logging level
+extern int log_level;
+
+#if DEBUGFS_TODO
+int debugfs_log_level;
+
+static char log_buffer[LOG_BUFFER_SIZE] = "";
+static size_t log_length = 0;
+static size_t write_pos = 0;
+#endif
+#ifndef VERSION_BUFFER_SIZE
+#define VERSION_BUFFER_SIZE 50
+#endif
+extern char version_str[VERSION_BUFFER_SIZE];
+
+// Read operation for the debugfs file
+static ssize_t log_level_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	// Convert the log level integer to a string
+	char level_str[32];
+	snprintf(level_str, sizeof(level_str), "%d\n", log_level);
+
+	// Copy the string to userspace
+	return simple_read_from_buffer(buf, count, ppos, level_str, strlen(level_str));
+}
+
+static ssize_t version_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	return simple_read_from_buffer(buf, count, ppos, version_str, strlen(version_str));
+}
+
+// Write operation for the debugfs file
+static ssize_t log_level_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	char level_str[32];
+
+	// Read the user input
+	if (count >= sizeof(level_str))
+		return -EINVAL;
+
+	if (copy_from_user(level_str, buf, count))
+		return -EFAULT;
+
+	level_str[count] = '\0';
+
+	// Convert the input string to an integer
+	if (kstrtoint(level_str, 10, &log_level))
+		return -EINVAL;
+
+	esp_err("Updated log level to %d\n", log_level);
+
+	return count;
+}
+
+#if DEBUGFS_TODO
+// Read operation for the debugfs file
+static ssize_t debugfs_log_level_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	// Convert the log level integer to a string
+	char level_str[32];
+	snprintf(level_str, sizeof(level_str), "%d\n", debugfs_log_level);
+
+	// Copy the string to userspace
+	return simple_read_from_buffer(buf, count, ppos, level_str, strlen(level_str));
+}
+
+// Write operation for the debugfs file
+static ssize_t debugfs_log_level_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	char level_str[32];
+
+	// Read the user input
+	if (count >= sizeof(level_str))
+		return -EINVAL;
+
+	if (copy_from_user(level_str, buf, count))
+		return -EFAULT;
+
+	level_str[count] = '\0';
+
+	// Convert the input string to an integer
+	if (kstrtoint(level_str, 10, &debugfs_log_level))
+		return -EINVAL;
+
+	esp_err("Updated debugfs log level to %d\n", debugfs_log_level);
+
+	return count;
+}
+
+// Read operation for the log output file
+static ssize_t log_output_read(struct file *file, char __user *user_buffer, size_t count, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	if (log_length > 0) {
+		ret = simple_read_from_buffer(user_buffer, count, ppos, log_buffer, log_length);
+		if (ret > 0) {
+			// Update read position
+			*ppos += ret;
+			// Clear buffer if no more data is available
+			if (*ppos >= log_length) {
+				log_length = 0;
+				write_pos = 0;
+			}
+		}
+	}
+	return ret;
+}
+
+static int va_format_to_char(char *buf, size_t size, const char *fmt, va_list args)
+{
+	return vsnprintf(buf, size, fmt, args);
+}
+
+void write_to_buffer(const char *fmt, ...)
+{
+	size_t space_left = LOG_BUFFER_SIZE - log_length;
+	va_list args;
+	int len;
+
+	va_start(args, fmt);
+	len = va_format_to_char(log_buffer + write_pos, LOG_BUFFER_SIZE - write_pos, fmt, args);
+	va_end(args);
+
+	if (len > space_left)
+		len = space_left;
+
+	if (len > 0) {
+		write_pos += len;
+		log_length += len;
+		if (write_pos >= LOG_BUFFER_SIZE)
+			write_pos = 0;  // Wrap around if buffer is full
+	}
+}
+
+// File operations for the debugfs file
+static const struct file_operations debugfs_log_level_ops = {
+	.read = debugfs_log_level_read,
+	.write = debugfs_log_level_write,
+};
+
+// File operations for the debugfs file
+static const struct file_operations debugfs_log_output_ops = {
+	.read = log_output_read,
+};
+
+// File operations for the debugfs file
+static const struct file_operations debugfs_fw_log_level_ops = {
+	.read = debugfs_fw_log_level_read,
+	.write = debugfs_fw_log_level_write,
+};
+
+static const struct file_operations debugfs_fw_log_output_ops = {
+	.read = log_output_read,
+};
+#endif
+
+// File operations for the debugfs file
+static const struct file_operations log_level_ops = {
+	.read = log_level_read,
+	.write = log_level_write,
+};
+
+static const struct file_operations version_ops = {
+	.read = version_read,
+};
+
+// Module initialization function
+int debugfs_init(void)
+{
+	struct esp32_debugfs *debugfs = &drv_debugfs;
+	int ret = -ENODEV;
+	// Create debugfs directory
+	debugfs->debugfs_dir = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL);
+
+	if (!debugfs->debugfs_dir) {
+		esp_err("Failed to create debugfs %s directory\n", DEBUGFS_DIR_NAME);
+		goto cleanup;
+	}
+
+	// Create debugfs file
+	debugfs->log_level_file = debugfs_create_file(LOG_LEVEL, 0644, debugfs->debugfs_dir, NULL, &log_level_ops);
+	if (!debugfs->log_level_file) {
+		esp_err("Failed to create debugfs %s file\n", LOG_LEVEL);
+		goto cleanup;
+	}
+
+	debugfs->version = debugfs_create_file(VERSION, 0644, debugfs->debugfs_dir, NULL, &version_ops);
+	if (!debugfs->version) {
+		esp_err("Failed to create debugfs %s file\n", VERSION);
+		goto cleanup;
+	}
+
+#if DEBUGFS_TODO
+	debugfs->host_log_level_file = debugfs_create_file(DEBUGFS_LOG_LEVEL, 0644, debugfs_dir, NULL, &debugfs_log_level_ops);
+	if (!debugfs->debugfs_log_level_file) {
+		esp_err("Failed to create debugfs %s file\n", DEBUGFS_LOG_LEVEL);
+		goto cleanup;
+	}
+
+	debugfs->host_log_file = debugfs_create_file(HOST_LOGS, 0644, debugfs_dir, NULL, &debugfs_log_output_ops);
+	if (!debugfs->host_log_file) {
+		esp_err("Failed to create debugfs %s file\n", HOST_LOGS);
+		goto cleanup;
+	}
+
+	debugfs->fw_log_file = debugfs_create_file(FW_LOGS, 0644, debugfs_dir, NULL, &debugfs_fw_log_output_ops);
+	if (!debugfs->fw_log_file) {
+		esp_err("Failed to create debugfs %s file\n", FW_LOGS);
+		goto cleanup;
+	}
+
+	debugfs->fw_log_level_file = debugfs_create_file(FW_LOGS_LEVEL, 0644, debugfs_dir, NULL, &debugfs_fw_log_output_ops);
+	if (!debugfs->fw_log_level_file) {
+		esp_err("Failed to create debugfs %s file\n", FW_LOGS_LEVEL);
+		goto cleanup;
+	}
+
+#endif
+	return 0;
+cleanup:
+	debugfs_exit();
+	return ret;
+}
+
+void debugfs_exit(void)
+{
+	struct esp32_debugfs *debugfs = &drv_debugfs;
+#if DEBUGFS_TODO
+	// Remove debugfs file and directory
+	if (debugfs->fw_log_file)
+		debugfs_remove(debugfs->fw_log_file);
+	if (debugfs->fw_log_level_file)
+		debugfs_remove(debugfs->fw_log_level_file);
+	if (debugfs->host_log_file)
+		debugfs_remove(debugfs->host_log_file);
+	if (debugfs->host_log_level_file)
+		debugfs_remove(debugfs->host_log_level_file);
+#endif
+	if (debugfs->log_level_file) {
+		debugfs_remove(debugfs->log_level_file);
+		debugfs->log_level_file = NULL;
+	}
+	if (debugfs->version) {
+		debugfs_remove(debugfs->version);
+		debugfs->version = NULL;
+	}
+	if (debugfs->debugfs_dir) {
+		debugfs_remove(debugfs->debugfs_dir);
+		debugfs->debugfs_dir = NULL;
+	}
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_log.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_log.c
new file mode 100644
index 0000000..e9f2876
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_log.c
@@ -0,0 +1,66 @@
+#include <linux/types.h>
+#include <linux/printk.h>
+
+#include "utils.h"
+
+#define esp_fmt(fmt) "%s: %s: " fmt, KBUILD_MODNAME, function
+extern int log_level;
+static char *get_kern_log_level(int level)
+{
+	char *kern_level;
+
+	switch(level) {
+	case ESP_ERR:
+		kern_level = KERN_ERR;
+		break;
+	case ESP_WARNING:
+		kern_level = KERN_WARNING;
+		break;
+	case ESP_INFO:
+		kern_level = KERN_INFO;
+		break;
+	case ESP_DEBUG:
+		kern_level = KERN_DEBUG;
+		break;
+	case ESP_VERBOSE:
+		kern_level = KERN_DEBUG;
+		break;
+	default:
+		kern_level = KERN_DEBUG;
+		break;
+	}
+
+	return kern_level;
+}
+
+void esp_logger(int level, const char *function, const char* fmt, ...)
+{
+	char *kern_level;
+	struct va_format vaf;
+	va_list args;
+
+	if (level > log_level)
+		return;
+
+	kern_level = get_kern_log_level(level);
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	printk("%s%s: %s: %pV", kern_level, KBUILD_MODNAME, function, &vaf);
+
+	va_end(args);
+}
+
+void esp_hex_dump(const char *prefix_str, const void *buf, size_t len)
+{
+	print_hex_dump(KERN_INFO, prefix_str, DUMP_PREFIX_ADDRESS, 16, 1, buf, len, 1);
+}
+
+void esp_hex_dump_verbose(const char *prefix_str, const void *buf, size_t len)
+{
+	if (log_level >= ESP_VERBOSE)
+		print_hex_dump(KERN_INFO, prefix_str, DUMP_PREFIX_ADDRESS, 16, 1, buf, len, 1);
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c
new file mode 100644
index 0000000..61c3773
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c
@@ -0,0 +1,197 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+
+#include "utils.h"
+#include "esp_stats.h"
+#include "esp_kernel_port.h"
+
+#if TEST_RAW_TP
+
+#include "esp_api.h"
+#include <linux/timer.h>
+#include <linux/kthread.h>
+
+static struct task_struct *raw_tp_tx_thread;
+static int test_raw_tp;
+static int test_raw_tp__host_to_esp;
+static struct timer_list log_raw_tp_stats_timer;
+static u8 log_raw_tp_stats_timer_running;
+static unsigned long test_raw_tp_len;
+static u32 raw_tp_timer_count;
+static u8 traffic_open_init_done;
+static struct completion traffic_open;
+
+static void log_raw_tp_stats_timer_cb(struct timer_list *timer)
+{
+	unsigned long actual_bandwidth = 0;
+
+	mod_timer(&log_raw_tp_stats_timer, jiffies + msecs_to_jiffies(1000));
+	actual_bandwidth = (test_raw_tp_len*8)/1024;
+	esp_info("%u-%u sec       %lu kbits/sec\n\r",
+			raw_tp_timer_count,
+			raw_tp_timer_count + 1, actual_bandwidth);
+
+	raw_tp_timer_count++;
+	test_raw_tp_len = 0;
+}
+
+static int raw_tp_tx_process(void *data)
+{
+	int ret = 0;
+	struct sk_buff *tx_skb = NULL;
+	struct esp_payload_header *payload_header = NULL;
+	struct esp_adapter *adapter = NULL;
+	struct esp_wifi_device *priv = NULL;
+	struct esp_skb_cb *cb = NULL;
+	u8 pad_len = 0;
+	u16 total_len = 0;
+
+	pad_len = sizeof(struct esp_payload_header);
+	total_len = TEST_RAW_TP__BUF_SIZE + pad_len;
+	pad_len += SKB_DATA_ADDR_ALIGNMENT - (total_len % SKB_DATA_ADDR_ALIGNMENT);
+
+	msleep(2000);
+	adapter = esp_get_adapter();
+	priv = adapter->priv[0];
+
+	while (!kthread_should_stop()) {
+
+		if (esp_is_tx_queue_paused(priv)) {
+
+			tx_skb = esp_alloc_skb(TEST_RAW_TP__BUF_SIZE);
+			if (!tx_skb) {
+				esp_info("%u esp_alloc_skb failed\n", __LINE__);
+				msleep(10);
+				continue;
+			}
+			memset(tx_skb->data, 0, TEST_RAW_TP__BUF_SIZE);
+			tx_skb->len = TEST_RAW_TP__BUF_SIZE;
+			cb = (struct esp_skb_cb *) tx_skb->cb;
+			cb->priv = priv;
+
+			payload_header = (struct esp_payload_header *) tx_skb->data;
+			memset(payload_header, 0, pad_len);
+
+			payload_header->if_type = ESP_TEST_IF;
+			payload_header->if_num = 0;
+			payload_header->len = cpu_to_le16(TEST_RAW_TP__BUF_SIZE);
+			payload_header->offset = cpu_to_le16(pad_len);
+
+			if (adapter->capabilities & ESP_CHECKSUM_ENABLED) {
+				payload_header->checksum =
+					cpu_to_le16(compute_checksum(tx_skb->data,
+								(TEST_RAW_TP__BUF_SIZE + pad_len)));
+			}
+			ret = esp_send_packet(esp_get_adapter(), tx_skb);
+			if (!ret)
+				test_raw_tp_len += TEST_RAW_TP__BUF_SIZE;
+
+		} else {
+			if (traffic_open_init_done)
+				wait_for_completion_interruptible(&traffic_open);
+		}
+	}
+	esp_info("raw tp tx thrd stopped\n");
+	return 0;
+}
+
+static void process_raw_tp_flags(void)
+{
+	test_raw_tp_cleanup();
+
+	if (test_raw_tp) {
+
+		timer_setup(&log_raw_tp_stats_timer, log_raw_tp_stats_timer_cb, 0);
+		mod_timer(&log_raw_tp_stats_timer, jiffies + msecs_to_jiffies(1000));
+		log_raw_tp_stats_timer_running = 1;
+
+		if (test_raw_tp__host_to_esp) {
+
+			raw_tp_tx_thread = kthread_run(raw_tp_tx_process, NULL, "raw tp thrd");
+			if (!raw_tp_tx_thread)
+				esp_err("Failed to create send traffic thread\n");
+
+		}
+		if (!traffic_open_init_done) {
+			init_completion(&traffic_open);
+			traffic_open_init_done = 1;
+		}
+	}
+}
+
+
+static void start_test_raw_tp(int raw_tp__host_to_esp)
+{
+	test_raw_tp = 1;
+	test_raw_tp__host_to_esp = raw_tp__host_to_esp;
+}
+
+static void stop_test_raw_tp(void)
+{
+	test_raw_tp = 0;
+	test_raw_tp__host_to_esp = 0;
+}
+
+void esp_raw_tp_queue_resume(void)
+{
+	if (traffic_open_init_done)
+		if (!completion_done(&traffic_open))
+			complete_all(&traffic_open);
+}
+
+void test_raw_tp_cleanup(void)
+{
+	int ret = 0;
+
+	if (log_raw_tp_stats_timer_running) {
+		ret = del_timer(&log_raw_tp_stats_timer);
+		if (!ret) {
+			log_raw_tp_stats_timer_running = 0;
+		}
+		raw_tp_timer_count = 0;
+	}
+
+	if (traffic_open_init_done)
+		if (!completion_done(&traffic_open))
+			complete_all(&traffic_open);
+
+	if (raw_tp_tx_thread) {
+		ret = kthread_stop(raw_tp_tx_thread);
+		if (ret) {
+			msleep(10);
+			ret = kthread_stop(raw_tp_tx_thread);
+		}
+		if (ret)
+			esp_err("Kthread stop error\n");
+
+		raw_tp_tx_thread = 0;
+	}
+}
+
+void update_test_raw_tp_rx_stats(u16 len)
+{
+	/* if traffic dir is esp to host, increment stats */
+	if (!test_raw_tp__host_to_esp)
+		test_raw_tp_len += len;
+}
+#endif
+
+void process_test_capabilities(u32 raw_tp_mode)
+{
+#if TEST_RAW_TP
+	stop_test_raw_tp();
+	if (raw_tp_mode == ESP_TEST_RAW_TP_ESP_TO_HOST) {
+		start_test_raw_tp(ESP_TEST_RAW_TP__RX);
+		esp_info("start testing of ESP->Host raw throughput\n");
+	} else if (raw_tp_mode == ESP_TEST_RAW_TP_HOST_TO_ESP) {
+		start_test_raw_tp(ESP_TEST_RAW_TP__TX);
+		esp_info("start testing of Host->ESP raw throughput\n");
+	}
+	process_raw_tp_flags();
+#endif
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_utils.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_utils.c
new file mode 100644
index 0000000..9d06e7b
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_utils.c
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#include "utils.h"
+#include "esp_utils.h"
+
+
+int wpa_cipher_to_alg(int cipher)
+{
+	switch (cipher) {
+	case WLAN_CIPHER_SUITE_CCMP:
+		return WIFI_WPA_ALG_CCMP;
+#ifdef CONFIG_GCMP
+	case WLAN_CIPHER_SUITE_GCMP_256:
+	case WLAN_CIPHER_SUITE_GCMP:
+		return WIFI_WPA_ALG_GCMP;
+#endif
+	case WLAN_CIPHER_SUITE_TKIP:
+		return WIFI_WPA_ALG_TKIP;
+	case WLAN_CIPHER_SUITE_WEP104:
+		return WIFI_WPA_ALG_WEP104;
+	case WLAN_CIPHER_SUITE_WEP40:
+		return WIFI_WPA_ALG_WEP40;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		return WIFI_WPA_ALG_IGTK;
+	}
+	return WIFI_WPA_ALG_NONE;
+}
+
+char * esp_chipname_from_id(int chipset_id)
+{
+	if (chipset_id == ESP_FIRMWARE_CHIP_ESP32)
+		return "ESP32";
+	if (chipset_id == ESP_FIRMWARE_CHIP_ESP32S2)
+		return "ESP32-S2";
+	if (chipset_id == ESP_FIRMWARE_CHIP_ESP32S3)
+		return "ESP32-S3";
+	if (chipset_id == ESP_FIRMWARE_CHIP_ESP32C2)
+		return "ESP32-C2";
+	if (chipset_id == ESP_FIRMWARE_CHIP_ESP32C3)
+		return "ESP32-C3";
+	if (chipset_id == ESP_FIRMWARE_CHIP_ESP32C6)
+		return "ESP32-C6";
+	if (chipset_id == ESP_FIRMWARE_CHIP_ESP32C5)
+		return "ESP32-C5";
+
+	return "Unknown Chip";
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h
new file mode 100644
index 0000000..a8098eb
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h
@@ -0,0 +1,457 @@
+// Copyright 2015-2024 Espressif Systems (Shanghai) PTE LTD
+/* SPDX-License-Identifier: GPL-2.0-only OR Apache-2.0 */
+
+#ifndef __ESP_NETWORK_ADAPTER__H
+#define __ESP_NETWORK_ADAPTER__H
+
+#ifndef __packed
+#define __packed        __attribute__((__packed__))
+#endif
+
+#define PRIO_Q_HIGH                     0
+#define PRIO_Q_MID                      1
+#define PRIO_Q_LOW                      2
+#define MAX_PRIORITY_QUEUES             3
+#define MAC_ADDR_LEN                    6
+#define MAX_KEY_LEN                     32
+#define MAX_SEQ_LEN                     10
+#define ESP_MAX_KEY_INDEX               0
+
+/* ESP Payload Header Flags */
+#define MORE_FRAGMENT                   (1 << 0)
+#define MAX_SSID_LEN                    32
+#define OTA_CHUNK_SIZE                  1016
+
+#define MAX_MULTICAST_ADDR_COUNT        8
+
+struct esp_payload_header {
+	uint8_t          if_type:4;
+	uint8_t          if_num:4;
+	uint8_t          flags;
+	uint8_t          packet_type;
+	uint8_t          reserved1;
+	uint16_t         len;
+	uint16_t         offset;
+	uint16_t         checksum;
+	uint8_t          reserved2;
+	/* Position of union field has to always be last,
+	 * this is required for hci_pkt_type */
+	union {
+		uint8_t      reserved3;
+		uint8_t      hci_pkt_type;    /* Packet type for HCI interface */
+		uint8_t      priv_pkt_type;   /* Packet type for priv interface */
+	};
+	/* Do no add anything here */
+} __packed;
+
+struct ieee_mgmt_header {
+	uint16_t   frame_control;
+	uint16_t   dur;
+	uint8_t    da[MAC_ADDR_LEN];
+	uint8_t    sa[MAC_ADDR_LEN];
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint16_t   seq_ctrl;
+} __packed;
+
+enum ESP_INTERFACE_TYPE {
+	ESP_STA_IF,
+	ESP_AP_IF,
+	ESP_HCI_IF,
+	ESP_INTERNAL_IF,
+	ESP_TEST_IF,
+	ESP_MAX_IF,
+};
+
+enum ESP_IE_TYPE{
+	IE_BEACON,
+	IE_PROBE_RESP,
+	IE_ASSOC_RESP,
+	IE_RSN,
+	IE_BEACON_PROBE_HEAD,
+	IE_BEACON_PROBE_TAIL,
+};
+
+enum ESP_PACKET_TYPE {
+	PACKET_TYPE_DATA,
+	PACKET_TYPE_COMMAND_REQUEST,
+	PACKET_TYPE_COMMAND_RESPONSE,
+	PACKET_TYPE_EVENT,
+	PACKET_TYPE_EAPOL,
+};
+
+enum ESP_HOST_INTERRUPT {
+	ESP_OPEN_DATA_PATH,
+	ESP_CLOSE_DATA_PATH,
+	ESP_RESET,
+	ESP_POWER_SAVE_ON,
+	ESP_POWER_SAVE_OFF,
+};
+
+enum ESP_CAPABILITIES {
+	ESP_WLAN_SDIO_SUPPORT = (1 << 0),
+	ESP_BT_UART_SUPPORT = (1 << 1),
+	ESP_BT_SDIO_SUPPORT = (1 << 2),
+	ESP_BLE_ONLY_SUPPORT = (1 << 3),
+	ESP_BR_EDR_ONLY_SUPPORT = (1 << 4),
+	ESP_WLAN_SPI_SUPPORT = (1 << 5),
+	ESP_BT_SPI_SUPPORT = (1 << 6),
+	ESP_CHECKSUM_ENABLED = (1 << 7),
+};
+
+typedef enum {
+	ESP_TEST_RAW_TP_HOST_TO_ESP = (1 << 0),
+	ESP_TEST_RAW_TP_ESP_TO_HOST = (1 << 1)
+} ESP_RAW_TP_MEASUREMENT;
+
+enum ESP_INTERNAL_MSG {
+	ESP_INTERNAL_BOOTUP_EVENT = 1,
+};
+
+enum ESP_BOOTUP_TAG_TYPE {
+	ESP_BOOTUP_CAPABILITY,
+	ESP_BOOTUP_FW_DATA,
+	ESP_BOOTUP_SPI_CLK_MHZ,
+	ESP_BOOTUP_FIRMWARE_CHIP_ID,
+	ESP_BOOTUP_TEST_RAW_TP,
+};
+
+enum COMMAND_CODE {
+	CMD_INIT_INTERFACE = 1,
+	CMD_SET_MAC = 2,
+	CMD_GET_MAC = 3,
+	CMD_SCAN_REQUEST = 4,
+	CMD_STA_CONNECT = 5,
+	CMD_DISCONNECT = 6,
+	CMD_DEINIT_INTERFACE = 7,
+	CMD_ADD_KEY = 8,
+	CMD_DEL_KEY = 9,
+	CMD_SET_DEFAULT_KEY = 10,
+	CMD_STA_AUTH = 11,
+	CMD_STA_ASSOC = 12,
+	CMD_SET_IP_ADDR = 13,
+	CMD_SET_MCAST_MAC_ADDR = 14,
+	CMD_GET_TXPOWER = 15,
+	CMD_SET_TXPOWER = 16,
+	CMD_GET_REG_DOMAIN = 17,
+	CMD_SET_REG_DOMAIN = 18,
+	CMD_RAW_TP_ESP_TO_HOST = 19,
+	CMD_RAW_TP_HOST_TO_ESP = 20,
+	CMD_SET_WOW_CONFIG = 21,
+	CMD_SET_MODE = 22,
+	CMD_SET_IE = 23,
+	CMD_AP_CONFIG = 24,
+	CMD_MGMT_TX = 25,
+	CMD_AP_STATION = 26,
+	CMD_STA_RSSI = 27,
+	CMD_SET_TIME = 28,
+	CMD_START_OTA_UPDATE = 29,
+	CMD_START_OTA_WRITE = 30,
+	CMD_START_OTA_END = 31,
+	CMD_MAX,
+};
+
+enum EVENT_CODE {
+	EVENT_SCAN_RESULT = 1,
+	EVENT_STA_CONNECT,
+	EVENT_STA_DISCONNECT,
+	EVENT_AUTH_RX,
+	EVENT_ASSOC_RX,
+	EVENT_AP_MGMT_RX,
+};
+
+enum COMMAND_RESPONSE_TYPE {
+	CMD_RESPONSE_PENDING,
+	CMD_RESPONSE_FAIL,
+	CMD_RESPONSE_SUCCESS,
+	CMD_RESPONSE_BUSY,
+	CMD_RESPONSE_UNSUPPORTED,
+	CMD_RESPONSE_INVALID,
+};
+
+struct command_header {
+	uint8_t    cmd_code;
+	uint8_t    cmd_status;
+	uint16_t   len;
+	uint16_t   seq_num;
+	uint8_t    reserved1;
+	uint8_t    reserved2;
+} __packed;
+
+struct cmd_ota_update_request {
+	struct command_header header;
+	uint16_t   ota_binary_len;
+	char       ota_binary[];
+} __packed;
+
+struct scan_request {
+	struct     command_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint16_t   duration;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    channel;
+	uint8_t    pad[2];
+} __packed;
+
+struct cmd_config_mac_address {
+	struct     command_header header;
+	uint8_t    mac_addr[MAC_ADDR_LEN];
+	uint8_t    pad[2];
+} __packed;
+
+struct cmd_config_ie {
+	struct     command_header header;
+	uint8_t    ie_type;
+	uint8_t    pad;
+	uint16_t   ie_len;
+	uint8_t    ie[];
+} __packed;
+
+struct esp_ap_config {
+    uint8_t ssid[32];
+    uint8_t ssid_len;
+    uint8_t channel;
+    uint8_t authmode;
+    uint8_t ssid_hidden;
+    uint8_t max_connection;
+    uint8_t pairwise_cipher;
+    uint8_t pmf_cfg;
+    uint8_t sae_pwe_h2e;
+    uint16_t beacon_interval;
+    uint16_t inactivity_timeout;
+    uint8_t privacy;
+} __packed;
+
+struct cmd_ap_config {
+	struct command_header header;
+	struct esp_ap_config ap_config;
+} __packed;
+
+#define ADD_STA 0
+#define CHANGE_STA 1
+#define DEL_STA 2
+
+struct cmd_ap_sta_param {
+	uint8_t mac[6];
+	uint16_t cmd;
+	uint32_t sta_flags_mask, sta_flags_set;
+	uint32_t sta_modify_mask;
+	int32_t listen_interval;
+	uint16_t aid;
+	uint8_t ext_capab[6];
+	uint8_t supported_rates[12];
+	uint8_t ht_caps[28];
+	uint8_t vht_caps[14];
+	uint8_t pad1[2];
+	uint8_t he_caps[27];
+	uint8_t pad2;
+} __packed;
+
+struct cmd_ap_add_sta_config {
+	struct command_header header;
+	struct cmd_ap_sta_param sta_param;
+} __packed;
+
+struct cmd_sta_auth {
+	struct     command_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    channel;
+	uint8_t    auth_type;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    key_len;
+	uint8_t    key[27];
+	uint8_t    auth_data_len;
+	uint8_t    pad[2];
+	uint8_t    auth_data[];
+} __packed;
+
+struct cmd_mgmt_tx {
+        struct     command_header header;
+        uint8_t    channel;
+        uint8_t    offchan;
+        uint32_t   wait;
+        uint8_t    no_cck;
+        uint8_t    dont_wait_for_ack;
+        uint32_t   len;
+        uint8_t    buf[];
+} __packed;
+
+struct cmd_sta_assoc {
+	struct     command_header header;
+	uint8_t    assoc_ie_len;
+	uint8_t    pad[3];
+	uint8_t    assoc_ie[];
+} __packed;
+
+struct cmd_sta_connect {
+	struct     command_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint16_t   assoc_flags;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    channel;
+	uint8_t    is_auth_open;
+	uint8_t    assoc_ie_len;
+	uint8_t    assoc_ie[];
+} __packed;
+
+struct cmd_disconnect {
+	struct     command_header header;
+	uint16_t   reason_code;
+	uint8_t    mac[MAC_ADDR_LEN];
+} __packed;
+
+struct cmd_set_ip_addr {
+	struct command_header header;
+	uint32_t ip;
+} __packed;
+
+struct cmd_set_mcast_mac_addr {
+	struct command_header header;
+	uint8_t count;
+	uint8_t mcast_addr[MAX_MULTICAST_ADDR_COUNT][MAC_ADDR_LEN];
+} __packed;
+
+struct wifi_sec_key {
+	uint32_t   algo;
+	uint32_t   index;
+	uint8_t    data[MAX_KEY_LEN];
+	uint32_t   len;
+	uint8_t    mac_addr[MAC_ADDR_LEN];
+	uint8_t    seq[MAX_SEQ_LEN];
+	uint32_t   seq_len;
+	uint8_t    del;
+	uint8_t    set_cur;
+	uint8_t    pad[2];
+} __packed;
+
+struct cmd_set_get_val {
+	struct     command_header header;
+	uint32_t   value;
+} __packed;
+
+struct cmd_wow_config {
+	struct command_header header;
+	uint8_t any;
+	uint8_t disconnect;
+	uint8_t magic_pkt;
+	uint8_t four_way_handshake;
+	uint8_t eap_identity_req;
+} __packed;
+
+struct cmd_reg_domain {
+	struct     command_header header;
+	char       country_code[4];  /* 4 for padding */
+} __packed;
+
+struct cmd_key_operation {
+	struct     command_header header;
+	struct     wifi_sec_key key;
+} __packed;
+
+struct event_header {
+	uint8_t    event_code;
+	uint8_t    status;
+	uint16_t   len;
+} __packed;
+
+struct scan_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    frame_type;
+	uint8_t    channel;
+	uint32_t   rssi;
+	uint64_t   tsf;
+	uint16_t   frame_len;
+	uint8_t    pad[2];
+	uint8_t    frame[0];
+} __packed;
+
+struct auth_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    frame_type;
+	uint8_t    channel;
+	uint32_t   rssi;
+	uint64_t   tsf;
+	uint16_t   frame_len;
+	uint8_t    pad[2];
+	uint8_t    frame[0];
+} __packed;
+
+struct assoc_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    frame_type;
+	uint8_t    channel;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    pad[1];
+	uint16_t   frame_len;
+	uint32_t   rssi;
+	uint64_t   tsf;
+	uint8_t    frame[0];
+} __packed;
+
+struct mgmt_event {
+        struct     event_header header;
+        int32_t    nf;
+        int32_t    rssi;
+        int32_t    chan;
+        uint32_t   frame_len;
+        uint8_t    frame[0];
+} __packed;
+
+struct disconnect_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    reason;
+} __packed;
+
+struct cmd_config_mode {
+	struct     command_header header;
+	uint16_t   mode;
+	uint8_t    pad[2];
+} __packed;
+
+struct cmd_set_time {
+	struct     command_header header;
+	uint64_t   sec;
+	uint64_t   usec;
+} __packed;
+
+struct esp_internal_bootup_event {
+	struct     event_header header;
+	uint8_t    len;
+	uint8_t    pad[3];
+	uint8_t    data[0];
+} __packed;
+
+struct fw_version {
+	char       project_name[3];
+	uint8_t    major1;
+	uint8_t    major2;
+	uint8_t    minor;
+	uint8_t    revision_patch_1;
+	uint8_t    revision_patch_2;
+} __packed;
+
+struct fw_data {
+	struct     fw_version version;
+	uint32_t   last_reset_reason;
+} __packed;
+
+
+
+static inline uint16_t compute_checksum(uint8_t *buf, uint16_t len)
+{
+	uint16_t checksum = 0;
+	uint16_t i = 0;
+
+	while (i < len) {
+		checksum += buf[i];
+		i++;
+	}
+
+	return checksum;
+}
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h
new file mode 100644
index 0000000..4d99e33
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h
@@ -0,0 +1,182 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef __esp__h_
+#define __esp__h_
+
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/spinlock.h>
+#include <net/cfg80211.h>
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include "adapter.h"
+
+#define ESP_IF_TYPE_SDIO        1
+#define ESP_IF_TYPE_SPI         2
+
+/* Network link status */
+#define ESP_LINK_DOWN           0
+#define ESP_LINK_UP             1
+
+#define ESP_MAX_INTERFACE       1
+//#define ESP_MAX_INTERFACE       2
+#define ESP_STA_NW_IF           0
+#define ESP_AP_NW_IF            1
+
+enum context_state {
+	ESP_CONTEXT_DISABLED = 0,
+	ESP_CONTEXT_RX_READY,
+	ESP_CONTEXT_READY
+};
+
+/* ESP in sdkconfig has CONFIG_IDF_FIRMWARE_CHIP_ID entry.
+ * supported values of CONFIG_IDF_FIRMWARE_CHIP_ID are - */
+enum chipset_type_e {
+	ESP_FIRMWARE_CHIP_UNRECOGNIZED = 0xff,
+	ESP_FIRMWARE_CHIP_ESP32 = 0x0,
+	ESP_FIRMWARE_CHIP_ESP32S2 = 0x2,
+	ESP_FIRMWARE_CHIP_ESP32C3 = 0x5,
+	ESP_FIRMWARE_CHIP_ESP32S3 = 0x9,
+	ESP_FIRMWARE_CHIP_ESP32C2 = 0x0C,
+	ESP_FIRMWARE_CHIP_ESP32C6 = 0x0D,
+	ESP_FIRMWARE_CHIP_ESP32C5 = 0x17,
+};
+
+#define ESP_PAYLOAD_HEADER      8
+struct esp_private;
+struct esp_adapter;
+
+#define ACQUIRE_LOCK            1
+#define LOCK_ALREADY_ACQUIRED   0
+
+#define SKB_DATA_ADDR_ALIGNMENT 4
+#define INTERFACE_HEADER_PADDING (SKB_DATA_ADDR_ALIGNMENT*3)
+
+#define MAX_COUNTRY_LEN 3
+
+enum adapter_flags_e {
+	ESP_CLEANUP_IN_PROGRESS,    /* Driver unloading or ESP reseted */
+	ESP_CMD_INIT_DONE,          /* Cmd component is initialized with esp_commands_setup() */
+	ESP_DRIVER_ACTIVE,          /* kernel module __exit is not yet invoked */
+	ESP_INIT_DONE,              /* Driver init done */
+	ESP_OTA_IN_PROGRESS,        /* Firmware OTA in progress */
+};
+
+enum priv_flags_e {
+	ESP_NETWORK_UP,
+};
+
+struct command_node {
+	struct list_head list;
+	uint8_t cmd_code;
+	struct sk_buff *cmd_skb;
+	struct sk_buff *resp_skb;
+	bool in_cmd_queue;
+};
+
+struct esp_adapter {
+	struct device           *dev;
+	struct wiphy            *wiphy;
+
+	uint8_t                 if_type;
+	atomic_t                state;
+	uint32_t                capabilities;
+
+	/* Possible types:
+	 * struct esp_sdio_context */
+	void                    *if_context;
+
+	struct esp_if_ops       *if_ops;
+
+	/* Private for each interface */
+	struct esp_wifi_device  *priv[ESP_MAX_INTERFACE];
+	struct hci_dev          *hcidev;
+
+	struct workqueue_struct *if_rx_workqueue;
+	struct work_struct      if_rx_work;
+
+	wait_queue_head_t       wait_for_cmd_resp;
+	uint8_t                 cmd_resp;
+
+	/* wpa supplicant commands structures */
+	struct command_node     *cmd_pool;
+	struct list_head        cmd_free_queue;
+	spinlock_t              cmd_free_queue_lock;
+	struct list_head        cmd_pending_queue;
+	spinlock_t              cmd_pending_queue_lock;
+
+	struct command_node     *cur_cmd;
+	spinlock_t              cmd_lock;
+
+	struct work_struct      mac_flter_work;
+
+	struct workqueue_struct *cmd_wq;
+	struct work_struct      cmd_work;
+
+	struct sk_buff_head     events_skb_q;
+	struct workqueue_struct *events_wq;
+	struct work_struct      events_work;
+
+	unsigned long           state_flags;
+	int                     chipset;
+};
+
+struct esp_device {
+	struct device           *dev;
+	struct wiphy            *wiphy;
+	struct esp_adapter      *adapter;
+};
+
+struct esp_wifi_device {
+	struct wireless_dev     wdev;
+	struct net_device       *ndev;
+	struct esp_device       *esp_dev;
+	struct esp_adapter      *adapter;
+
+	struct net_device_stats stats;
+	uint8_t                 mac_address[MAC_ADDR_LEN];
+	uint8_t                 if_type;
+	uint8_t                 if_num;
+
+	uint32_t                ssid_len;
+	uint8_t                 ssid[32];
+
+	/* This is needed to notify scan completion*/
+	struct cfg80211_scan_request *request;
+	struct cfg80211_bss     *bss;
+	uint8_t                 *assoc_req_ie;
+	size_t                  assoc_req_ie_len;
+
+	uint8_t                 scan_in_progress;
+	uint8_t                 waiting_for_scan_done;
+
+	uint8_t                 link_state;
+
+	volatile uint8_t        stop_data;
+	volatile uint8_t        port_open;
+
+	char                    country_code[MAX_COUNTRY_LEN];
+
+	wait_queue_head_t       wait_for_scan_completion;
+	unsigned long           priv_flags;
+	struct notifier_block   nb;
+	uint8_t                 tx_pwr_type;
+	uint8_t                 tx_pwr;
+	uint32_t                rssi;
+	bool                    local_disconnect_req;
+};
+
+
+struct esp_skb_cb {
+	struct esp_wifi_device      *priv;
+};
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h
new file mode 100644
index 0000000..e7a1870
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef _esp_api__h_
+#define _esp_api__h_
+
+#include "esp.h"
+
+#define RET_ON_FAIL(x)                                                \
+	do {                                                          \
+		int ret = (x);                                        \
+		if (!!(ret)) {                                        \
+		    esp_err("%s failure, ret: %d\n", #x, ret);        \
+		    return ret;                                       \
+		}                                                     \
+	} while (0);                                                  \
+
+int esp_add_card(struct esp_adapter *adapter);
+int esp_remove_card(struct esp_adapter *adapter);
+void esp_process_new_packet_intr(struct esp_adapter *adapter);
+struct esp_adapter *esp_get_adapter(void);
+struct esp_wifi_device *get_priv_from_payload_header(struct esp_payload_header *header);
+struct sk_buff *esp_alloc_skb(u32 len);
+int esp_send_packet(struct esp_adapter *adapter, struct sk_buff *skb);
+u8 esp_is_bt_supported_over_sdio(u32 cap);
+void esp_tx_pause(struct esp_wifi_device *priv);
+void esp_tx_resume(struct esp_wifi_device *priv);
+void esp_init_priv(struct net_device *ndev);
+void esp_port_open(struct esp_wifi_device *priv);
+void esp_port_close(struct esp_wifi_device *priv);
+void esp_remove_network_interfaces(struct esp_adapter *adapter);
+void print_capabilities(u32 cap);
+void process_capabilities(struct esp_adapter *adapter);
+int esp_is_tx_queue_paused(struct esp_wifi_device *priv);
+int esp_deinit_module(struct esp_adapter *adapter);
+int esp_validate_chipset(struct esp_adapter *adapter, u8 chipset);
+int esp_adjust_spi_clock(struct esp_adapter *adapter, u8 spi_clk_mhz);
+void process_test_capabilities(u32 raw_tp_mode);
+int esp_init_raw_tp(struct esp_adapter *adapter);
+bool esp_is_valid_hardware_id(int hardware_id);
+char *esp_get_hardware_name(int hardware_id);
+int generate_slave_intr(void *context, u8 data);
+int esp_start_ota(struct esp_adapter *adapter, char *ota_file);
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h
new file mode 100644
index 0000000..45ecfc0
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef __esp_bt_api_h_
+#define __esp_bt_api_h_
+
+#include <linux/version.h>
+#include "esp.h"
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+		#define hci_skb_pkt_type(skb) bt_cb((skb))->pkt_type
+	#else
+	#error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+	#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+		#define HCI_PRIMARY HCI_BREDR
+	#else
+	#error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+	#endif
+#endif
+
+int esp_init_bt(struct esp_adapter *adapter);
+int esp_deinit_bt(struct esp_adapter *adapter);
+void esp_hci_update_tx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len);
+void esp_hci_update_rx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h
new file mode 100644
index 0000000..05f71f2
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef __esp_cfg80211_h_
+#define __esp_cfg80211_h_
+
+#include <linux/version.h>
+
+struct wireless_dev *esp_cfg80211_add_iface(struct wiphy *wiphy,
+			      const char *name,
+			      unsigned char name_assign_type,
+			      enum nl80211_iftype type,
+			      struct vif_params *params);
+int esp_add_wiphy(struct esp_adapter *adapter);
+int esp_remove_wiphy(struct esp_adapter *adapter);
+int esp_mark_disconnect(struct esp_wifi_device *priv, uint16_t reason,
+		uint8_t locally_disconnect);
+int esp_mark_scan_done_and_disconnect(struct esp_wifi_device *priv,
+		uint8_t locally_disconnect);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h
new file mode 100644
index 0000000..1f8e7f5
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef __esp_cmd_h_
+#define __esp_cmd_h_
+
+#include "esp.h"
+
+#define ESP_NUM_OF_CMD_NODES 20
+#define ESP_SIZE_OF_CMD_NODE 2048
+
+#define ESP_CMD_HIGH_PRIO    1
+#define ESP_CMD_DFLT_PRIO    0
+
+struct multicast_list {
+	struct esp_wifi_device *priv;
+	u8 addr_count;
+	u8 mcast_addr[MAX_MULTICAST_ADDR_COUNT][MAC_ADDR_LEN];
+};
+
+
+int esp_commands_setup(struct esp_adapter *adapter);
+int esp_commands_teardown(struct esp_adapter *adapter);
+int esp_cfg_cleanup(struct esp_adapter *adapter);
+int cmd_init_interface(struct esp_wifi_device *priv);
+int cmd_deinit_interface(struct esp_wifi_device *priv);
+int process_cmd_resp(struct esp_adapter *adapter, struct sk_buff *skb);
+int cmd_scan_request(struct esp_wifi_device *priv,
+		struct cfg80211_scan_request *request);
+int cmd_get_mac(struct esp_wifi_device *priv);
+int cmd_set_mac(struct esp_wifi_device *priv, uint8_t *mac_addr);
+int cmd_get_rssi(struct esp_wifi_device *priv);
+int process_cmd_event(struct esp_wifi_device *priv, struct sk_buff *skb);
+int cmd_connect_request(struct esp_wifi_device *priv,
+		struct cfg80211_connect_params *params);
+int cmd_auth_request(struct esp_wifi_device *priv,
+		struct cfg80211_auth_request *req);
+int cmd_assoc_request(struct esp_wifi_device *priv,
+		struct cfg80211_assoc_request *req);
+int cmd_disconnect_request(struct esp_wifi_device *priv, u16 reason_code, const uint8_t *mac);
+int cmd_add_station(struct esp_wifi_device *priv, const uint8_t *mac,
+		    struct station_parameters *sta, bool is_changed);
+int cmd_add_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr, struct key_params *params);
+int cmd_del_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr);
+int cmd_set_default_key(struct esp_wifi_device *priv, u8 key_index);
+int cmd_set_ip_address(struct esp_wifi_device *priv, u32 ip);
+int cmd_set_mcast_mac_list(struct esp_wifi_device *priv, struct multicast_list *list);
+int cmd_set_tx_power(struct esp_wifi_device *priv, int power);
+int cmd_set_wow_config(struct esp_wifi_device *priv, struct cfg80211_wowlan *wowlan);
+int cmd_get_tx_power(struct esp_wifi_device *priv);
+int cmd_set_reg_domain(struct esp_wifi_device *priv);
+int cmd_get_reg_domain(struct esp_wifi_device *priv);
+int cmd_init_raw_tp_task_timer(struct esp_wifi_device *priv);
+int cmd_set_mac(struct esp_wifi_device *priv, uint8_t *mac_addr);
+int cmd_set_mode(struct esp_wifi_device *priv, uint8_t mode);
+int cmd_set_ie(struct esp_wifi_device *priv, enum ESP_IE_TYPE type, const uint8_t *ie, size_t ie_len);
+int cmd_set_ap_config(struct esp_wifi_device *priv, struct esp_ap_config *ap_config);
+int cmd_mgmt_request(struct esp_wifi_device *priv,
+		     struct cfg80211_mgmt_tx_params *req);
+int cmd_sta_change(struct esp_wifi_device *priv,
+		     struct station_parameters *sta_info);
+int cmd_update_fw_time(struct esp_wifi_device *priv);
+int cmd_process_ota_start(struct esp_wifi_device *priv);
+int cmd_process_ota_write(struct esp_wifi_device *priv, char *ota_chunk, ssize_t nread);
+int cmd_process_ota_end(struct esp_wifi_device *priv);
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_fw_version.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_fw_version.h
new file mode 100644
index 0000000..0ab3ca4
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_fw_version.h
@@ -0,0 +1,19 @@
+// Copyright 2024 Espressif Systems (Shanghai) PTE LTD
+/* SPDX-License-Identifier: GPL-2.0-only OR Apache-2.0 */
+
+#ifndef __ESP_FW_VERSION__H
+#define __ESP_FW_VERSION__H
+
+#define PROJECT_NAME                "NG"
+#define PROJECT_VERSION_MAJOR_1     1
+#define PROJECT_VERSION_MAJOR_2     0
+#define PROJECT_VERSION_MINOR       4
+#define PROJECT_REVISION_PATCH_1    0
+#define PROJECT_REVISION_PATCH_2    2
+
+#define STRINGIFY_HELPER(x)	#x
+#define STRINGIFY(x)		STRINGIFY_HELPER(x)
+
+#define RELEASE_VERSION	PROJECT_NAME "-" STRINGIFY(PROJECT_VERSION_MAJOR_1) "." STRINGIFY(PROJECT_VERSION_MAJOR_2) "." STRINGIFY(PROJECT_VERSION_MINOR) "." STRINGIFY(PROJECT_REVISION_PATCH_1) "." STRINGIFY(PROJECT_REVISION_PATCH_2)
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h
new file mode 100644
index 0000000..47ff713
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef __ESP_IF__H_
+#define __ESP_IF__H_
+
+#include "esp.h"
+
+struct esp_if_ops {
+	int (*init)(struct esp_adapter *adapter);
+	struct sk_buff* (*read)(struct esp_adapter *adapter);
+	int (*write)(struct esp_adapter *adapter, struct sk_buff *skb);
+	int (*deinit)(struct esp_adapter *adapter);
+};
+
+int esp_init_interface_layer(struct esp_adapter *adapter);
+void esp_deinit_interface_layer(void);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h
new file mode 100644
index 0000000..35a18da
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h
@@ -0,0 +1,230 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef _esp_kernel_port__h_
+#define _esp_kernel_port__h_
+
+#include "esp.h"
+#include <net/cfg80211.h>
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
+    #define ESP_BT_SEND_FRAME_PROTOTYPE() \
+	int esp_bt_send_frame(struct sk_buff *skb)
+#else
+    #define ESP_BT_SEND_FRAME_PROTOTYPE() \
+	int esp_bt_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0)
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
+  #define ALLOC_NETDEV(size, name, type, setup) \
+    alloc_netdev(size, name, setup)
+#else
+  #define ALLOC_NETDEV(size, name, type, setup) \
+    alloc_netdev(size, name, type, setup)
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0)
+  #define CFG80211_INFORM_BSS(wiphy, chan, type, bssid, tsf, \
+	  cap, beacon_interval, ie, ielen, sig, gfp) \
+  cfg80211_inform_bss(wiphy, chan, bssid, tsf, \
+	  cap, beacon_interval, ie, ielen, sig, gfp)
+#else
+  #define CFG80211_INFORM_BSS(wiphy, chan, type, bssid, tsf, \
+	  cap, beacon_interval, ie, ielen, signal, gfp) \
+  cfg80211_inform_bss(wiphy, chan, type, bssid, tsf, \
+	  cap, beacon_interval, ie, ielen, signal, gfp)
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0)
+enum ieee80211_bss_type {
+	IEEE80211_BSS_TYPE_ESS,
+	IEEE80211_BSS_TYPE_PBSS,
+	IEEE80211_BSS_TYPE_IBSS,
+	IEEE80211_BSS_TYPE_MBSS,
+	IEEE80211_BSS_TYPE_ANY
+};
+
+enum ieee80211_privacy {
+	IEEE80211_PRIVACY_ON,
+	IEEE80211_PRIVACY_OFF,
+	IEEE80211_PRIVACY_ANY
+};
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+  #define CFG80211_DISCONNECTED(dev, reason, ie, ie_len, locally_generated, gfp) \
+    cfg80211_disconnected(dev, reason, ie, ie_len, gfp)
+
+#else
+  #define CFG80211_DISCONNECTED(dev, reason, ie, ie_len, locally_generated, gfp) \
+      cfg80211_disconnected(dev, reason, ie, ie_len, locally_generated, gfp)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
+    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+        #define hci_skb_pkt_type(skb) bt_cb((skb))->pkt_type
+    #else
+	#error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+    #endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
+    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+        #define HCI_PRIMARY HCI_BREDR
+    #else
+	#error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+    #endif
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+
+    #define ESP_MARK_SCAN_DONE(PrIv, abort) do {                               \
+									       \
+	if (PrIv->request) {                                                   \
+	    cfg80211_scan_done(PrIv->request, abort);                          \
+	    PrIv->request = NULL;                                              \
+	}                                                                      \
+									       \
+	PrIv->scan_in_progress = false;                                        \
+									       \
+    } while (0);
+
+#else
+
+    #define ESP_MARK_SCAN_DONE(PrIv, abort) do {                               \
+									       \
+	struct cfg80211_scan_info info = {                                     \
+	    .aborted = abort,                                                  \
+	};                                                                     \
+									       \
+	if (PrIv->request) {                                                   \
+	    cfg80211_scan_done(PrIv->request, &info);                          \
+	    PrIv->request = NULL;                                              \
+	}                                                                      \
+									       \
+	PrIv->scan_in_progress = false;                                        \
+									       \
+    } while (0);
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0)
+static inline void *skb_put_data(struct sk_buff *skb, const void *data,
+				 unsigned int len)
+{
+	void *tmp = skb_put(skb, len);
+
+	memcpy(tmp, data, len);
+
+	return tmp;
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+#define do_exit(code)	kthread_complete_and_exit(NULL, code)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0))
+#define NETIF_RX_NI(skb)	netif_rx(skb)
+#else
+#define NETIF_RX_NI(skb)	netif_rx_ni(skb)
+#endif
+
+static inline
+void CFG80211_RX_ASSOC_RESP(struct net_device *dev,
+			    struct cfg80211_bss *bss,
+			    const u8 *buf, size_t len,
+			    int uapsd_queues,
+			    const u8 *req_ies, size_t req_ies_len)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0))
+	struct cfg80211_rx_assoc_resp_data resp = {0};
+#else
+	struct cfg80211_rx_assoc_resp resp = {0};
+#endif
+
+	resp.links[0].bss = bss;
+	resp.buf = (u8 *)buf;
+	resp.len =  len;
+	resp.req_ies = req_ies;
+	resp.uapsd_queues = uapsd_queues;
+	resp.req_ies_len = req_ies_len;
+
+	cfg80211_rx_assoc_resp(dev, &resp);
+#else
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 21))
+	cfg80211_rx_assoc_resp(dev, bss, buf, len, uapsd_queues, req_ies, req_ies_len);
+	#else
+	cfg80211_rx_assoc_resp(dev, bss, buf, len, uapsd_queues);
+	#endif
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+static inline bool wireless_dev_current_bss_exists(struct wireless_dev *wdev)
+{
+	if (wdev->links[0].client.current_bss)
+		return true;
+	return false;
+}
+#define INT_LINK_ID int link_id,
+#define ZERO_LINK_ID 0,
+#else
+static inline bool wireless_dev_current_bss_exists(struct wireless_dev *wdev)
+{
+	if (wdev->current_bss)
+		return true;
+	return false;
+}
+#define INT_LINK_ID
+#define ZERO_LINK_ID
+#endif
+
+/* In kernel version 5.15 and later, eth_hw_addr_set() is provided by the kernel.
+ * However, in LTS kernels, this function has been backported in later releases.
+ * To maintain compatibility with older kernels (pre-5.15), we define a macro
+ * ETH_HW_ADDR_SET that either uses ether_addr_copy function equivalent (ether_addr_copy)
+ * for kernels < 5.15 or the kernel-provided eth_hw_addr_set() for 5.15 and above.
+ */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0))
+/* For kernel versions < 5.15, use ether_addr_copy() to set the hardware address. */
+#define ETH_HW_ADDR_SET(dev, addr) ether_addr_copy((dev)->dev_addr, (addr))
+#else
+/* For kernel versions >= 5.15, use the kernel-provided eth_hw_addr_set(). */
+#define ETH_HW_ADDR_SET(dev, addr) eth_hw_addr_set(dev, addr)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 9, 0))
+#define spi_master			spi_controller
+#define spi_master_put(_ctlr)		spi_controller_put(_ctlr)
+#endif
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 15, 0)
+  #define del_timer timer_delete_sync
+#endif
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h
new file mode 100644
index 0000000..cacc70a
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef __ESP_STAT__H__
+#define __ESP_STAT__H__
+
+#include "esp.h"
+
+#ifdef CONFIG_ESP_HOSTED_NG_TEST_RAW_TP
+#define TEST_RAW_TP	1
+#else
+#define TEST_RAW_TP	0
+#endif
+
+#if TEST_RAW_TP
+
+#define TEST_RAW_TP__BUF_SIZE    1460
+
+#define ESP_TEST_RAW_TP__RX      0
+#define ESP_TEST_RAW_TP__TX      1
+
+void esp_raw_tp_queue_resume(void);
+
+void test_raw_tp_cleanup(void);
+void update_test_raw_tp_rx_stats(u16 len);
+#endif	//TEST_RAW_TP
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_utils.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_utils.h
new file mode 100644
index 0000000..6d0b6b4
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_utils.h
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef __esp_utils_h_
+#define __esp_utils_h_
+
+#include "esp.h"
+
+#define WPA_CIPHER_NONE                 BIT(0)
+#define WPA_CIPHER_WEP40                BIT(7)
+#define WPA_CIPHER_WEP104               BIT(8)
+#define WPA_CIPHER_TKIP                 BIT(1)
+#define WPA_CIPHER_CCMP                 BIT(3)
+#define WPA_CIPHER_AES_128_CMAC         BIT(5)
+#define WPA_CIPHER_SMS4                 BIT(10)
+#define WPA_CIPHER_GCMP                 BIT(11)
+#define WPA_CIPHER_GCMP_256             BIT(12)
+#define WPA_CIPHER_BIP_GMAC_128         BIT(13)
+#define WPA_CIPHER_BIP_GMAC_256         BIT(14)
+
+enum wpa_alg {
+    WIFI_WPA_ALG_NONE   = 0,
+    WIFI_WPA_ALG_WEP40  = 1,
+    WIFI_WPA_ALG_TKIP   = 2,
+    WIFI_WPA_ALG_CCMP   = 3,
+    WIFI_WAPI_ALG_SMS4  = 4,
+    WIFI_WPA_ALG_WEP104 = 5,
+    WIFI_WPA_ALG_WEP    = 6,
+    WIFI_WPA_ALG_IGTK   = 7,
+    WIFI_WPA_ALG_PMK    = 8,
+    WIFI_WPA_ALG_GCMP   = 9,
+};
+
+int wpa_cipher_to_alg(int cipher);
+
+char * esp_chipname_from_id(int chipset_id);
+
+typedef enum {
+    WIFI_MODE_NULL = 0,  /**< Null mode */
+    WIFI_MODE_STA,       /**< Wi-Fi station mode */
+    WIFI_MODE_AP,        /**< Wi-Fi soft-AP mode */
+    WIFI_MODE_APSTA,     /**< Wi-Fi station + soft-AP mode */
+    WIFI_MODE_MAX
+} esp_wifi_mode_t;
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/main.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/main.h
new file mode 100644
index 0000000..87165e0
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/main.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+#ifndef _ESP_MAIN_H_
+#define _ESP_MAIN_H_
+
+int esp_init(void);
+void esp_exit(void);
+
+#endif // _ESP_MAIN_H_
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/utils.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/utils.h
new file mode 100644
index 0000000..23dae83
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/utils.h
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef _UTIL_H_
+#define _UTIL_H_
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+
+#ifndef NUMBER_1M
+#define NUMBER_1M 1000000
+#endif
+
+#ifndef MAC2STR
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#endif
+#ifndef MACSTR
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+#endif
+
+enum esp_log_level {
+	ESP_ERR,
+	ESP_WARNING,
+	ESP_INFO,
+	ESP_DEBUG,
+	ESP_VERBOSE,
+};
+
+void esp_logger(int level, const char *function, const char* format, ...);
+void esp_hex_dump(const char *prefix_str, const void *buf, size_t len);
+void esp_hex_dump_verbose(const char *prefix_str, const void *buf, size_t len);
+
+int debugfs_init(void);
+void debugfs_exit(void);
+
+#define esp_err(format, ...) esp_logger(ESP_ERR, __func__, format, ##__VA_ARGS__)
+#define esp_warn(format, ...) esp_logger(ESP_WARNING, __func__, format, ##__VA_ARGS__)
+#define esp_info(format, ...) esp_logger(ESP_INFO, __func__, format, ##__VA_ARGS__)
+#define esp_dbg(format, ...) esp_logger(ESP_DEBUG, __func__, format, ##__VA_ARGS__)
+#define esp_verbose(format, ...) esp_logger(ESP_VERBOSE, __func__, format, ##__VA_ARGS__)
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/main.c b/drivers/net/wireless/espressif/esp_hosted_ng/main.c
new file mode 100644
index 0000000..d23f931
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/main.c
@@ -0,0 +1,1099 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#include "utils.h"
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/igmp.h>
+
+#include "esp.h"
+#include "esp_if.h"
+#include "esp_bt_api.h"
+#include "esp_api.h"
+#include "esp_cmd.h"
+#include "esp_kernel_port.h"
+#include "esp_fw_version.h"
+
+#include "esp_cfg80211.h"
+#include "esp_stats.h"
+
+#include "main.h"
+
+static char *ota_file = NULL;
+extern u8 ap_bssid[MAC_ADDR_LEN];
+extern volatile u8 host_sleep;
+u32 raw_tp_mode = 0;
+int log_level = CONFIG_ESP_HOSTED_NG_LOG_LEVEL;
+#define VERSION_BUFFER_SIZE 50
+char version_str[VERSION_BUFFER_SIZE];
+
+#define CONFIG_ALLOW_MULTICAST_WAKEUP	1
+
+static void deinit_adapter(void);
+
+
+struct multicast_list mcast_list = {0};
+struct esp_adapter adapter;
+/*struct esp_device esp_dev;*/
+
+struct esp_adapter *esp_get_adapter(void)
+{
+	return &adapter;
+}
+
+void esp_process_new_packet_intr(struct esp_adapter *adapter)
+{
+	if (adapter)
+		queue_work(adapter->if_rx_workqueue, &adapter->if_rx_work);
+}
+
+static int process_tx_packet(struct sk_buff *skb)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct esp_skb_cb *cb = NULL;
+	struct esp_payload_header *payload_header = NULL;
+	struct sk_buff *new_skb = NULL;
+	int ret = 0;
+	u8 pad_len = 0, realloc_skb = 0;
+	u16 len = 0;
+	u16 total_len = 0;
+	static u8 c;
+	u8 *pos = NULL;
+
+	c++;
+	/* Get the priv */
+	cb = (struct esp_skb_cb *) skb->cb;
+	priv = cb->priv;
+
+	if (!priv) {
+		dev_kfree_skb(skb);
+		esp_info("No priv\n");
+		return NETDEV_TX_OK;
+	}
+
+	if (netif_queue_stopped((const struct net_device *) priv->ndev)) {
+		esp_info("Netif queue stopped\n");
+		return NETDEV_TX_BUSY;
+	}
+
+	if (host_sleep) {
+		return NETDEV_TX_BUSY;
+	}
+
+	len = skb->len;
+
+	/* Create space for payload header */
+	pad_len = sizeof(struct esp_payload_header);
+
+	total_len = len + pad_len;
+
+	/* Align buffer length */
+	pad_len += SKB_DATA_ADDR_ALIGNMENT - (total_len % SKB_DATA_ADDR_ALIGNMENT);
+
+	if (skb_headroom(skb) < pad_len) {
+		/* Headroom is not sufficient */
+		realloc_skb = 1;
+	}
+
+	if (realloc_skb || !IS_ALIGNED((unsigned long) skb->data, SKB_DATA_ADDR_ALIGNMENT)) {
+		/* Realloc SKB */
+		if (skb_linearize(skb)) {
+			priv->stats.tx_errors++;
+			dev_kfree_skb(skb);
+			esp_err("Failed to linearize SKB");
+			return NETDEV_TX_OK;
+		}
+
+		new_skb = esp_alloc_skb(skb->len + pad_len);
+
+		if (!new_skb) {
+			esp_err("Failed to allocate SKB");
+			priv->stats.tx_errors++;
+			dev_kfree_skb(skb);
+			return NETDEV_TX_OK;
+		}
+
+		pos = new_skb->data;
+		pos += pad_len;
+
+		/* Populate new SKB */
+		skb_copy_from_linear_data(skb, pos, skb->len);
+		skb_put(new_skb, skb->len + pad_len);
+
+		/* Replace old SKB */
+		dev_kfree_skb_any(skb);
+		skb = new_skb;
+	} else {
+		/* Realloc is not needed, Make space for interface header */
+		skb_push(skb, pad_len);
+	}
+
+	/* Set payload header */
+	payload_header = (struct esp_payload_header *) skb->data;
+	memset(payload_header, 0, pad_len);
+
+	payload_header->if_type = priv->if_type;
+	payload_header->if_num = priv->if_num;
+	payload_header->len = cpu_to_le16(len);
+	payload_header->offset = cpu_to_le16(pad_len);
+	payload_header->packet_type = PACKET_TYPE_DATA;
+
+	if (adapter.capabilities & ESP_CHECKSUM_ENABLED)
+		payload_header->checksum = cpu_to_le16(compute_checksum(skb->data, (len + pad_len)));
+
+	if (!priv->stop_data) {
+		ret = esp_send_packet(priv->adapter, skb);
+
+		if (ret) {
+			esp_verbose("Failed to send SKB");
+			priv->stats.tx_errors++;
+		} else {
+			priv->stats.tx_packets++;
+			priv->stats.tx_bytes += skb->len;
+		}
+	} else {
+		dev_kfree_skb_any(skb);
+		priv->stats.tx_dropped++;
+	}
+
+	return 0;
+}
+
+void esp_port_open(struct esp_wifi_device *priv)
+{
+	priv->port_open = 1;
+	priv->stop_data = 0;
+}
+
+void esp_port_close(struct esp_wifi_device *priv)
+{
+	if (!priv)
+		return;
+
+	priv->port_open = 0;
+	priv->stop_data = 1;
+}
+
+void print_capabilities(u32 cap)
+{
+	esp_info("Capabilities: 0x%x. Features supported are:\n", cap);
+	if (cap & ESP_WLAN_SDIO_SUPPORT)
+		esp_info("\t * WLAN on SDIO\n");
+	else if (cap & ESP_WLAN_SPI_SUPPORT)
+		esp_info("\t * WLAN on SPI\n");
+
+	if ((cap & ESP_BT_UART_SUPPORT) ||
+		    (cap & ESP_BT_SDIO_SUPPORT) ||
+		    (cap & ESP_BT_SPI_SUPPORT)) {
+		esp_info("\t * BT/BLE\n");
+		if (cap & ESP_BT_UART_SUPPORT)
+			esp_info("\t   - HCI over UART\n");
+		if (cap & ESP_BT_SDIO_SUPPORT)
+			esp_info("\t   - HCI over SDIO\n");
+		if (cap & ESP_BT_SPI_SUPPORT)
+			esp_info("\t   - HCI over SPI\n");
+
+		if ((cap & ESP_BLE_ONLY_SUPPORT) && (cap & ESP_BR_EDR_ONLY_SUPPORT))
+			esp_info("\t   - BT/BLE dual mode\n");
+		else if (cap & ESP_BLE_ONLY_SUPPORT)
+			esp_info("\t   - BLE only\n");
+		else if (cap & ESP_BR_EDR_ONLY_SUPPORT)
+			esp_info("\t   - BR EDR only\n");
+	}
+}
+
+static void init_bt(struct esp_adapter *adapter)
+{
+
+	if ((adapter->capabilities & ESP_BT_SPI_SUPPORT) ||
+		(adapter->capabilities & ESP_BT_SDIO_SUPPORT)) {
+		msleep(200);
+		esp_info("ESP Bluetooth init\n");
+		esp_init_bt(adapter);
+	}
+}
+
+static int check_esp_version(struct fw_version *ver)
+{
+	snprintf(version_str, VERSION_BUFFER_SIZE, "%s-%u.%u.%u.%u.%u",
+		ver->project_name, ver->major1, ver->major2, ver->minor, ver->revision_patch_1, ver->revision_patch_2);
+
+	if (strncmp(RELEASE_VERSION, version_str, strlen(version_str)) != 0) {
+		esp_err("Firmware version: %s, Host version: %s\n", version_str, RELEASE_VERSION);
+		esp_err("Incompatible ESP Host-firmware release detected, Please use correct ESP-Hosted branch/compatible release\n");
+		return -1;
+	}
+	esp_info("ESP-Hosted Version: %s\n", version_str);
+	return 0;
+}
+
+static void print_reset_reason(uint32_t reason)
+{
+	switch (reason)
+	{
+		case 1: esp_info("POWERON_RESET\n"); break;          /**<1, Vbat power on reset*/
+		case 3: esp_info("SW_RESET\n"); break;               /**<3, Software reset digital core*/
+		case 4: esp_info("OWDT_RESET\n"); break;             /**<4, Legacy watch dog reset digital core*/
+		case 5: esp_info("DEEPSLEEP_RESET\n"); break;        /**<5, Deep Sleep reset digital core*/
+		case 6: esp_info("SDIO_RESET\n"); break;             /**<6, Reset by SLC module, reset digital core*/
+		case 7: esp_info("TG0WDT_SYS_RESET\n"); break;       /**<7, Timer Group0 Watch dog reset digital core*/
+		case 8: esp_info("TG1WDT_SYS_RESET\n"); break;       /**<8, Timer Group1 Watch dog reset digital core*/
+		case 9: esp_info("RTCWDT_SYS_RESET\n"); break;       /**<9, RTC Watch dog Reset digital core*/
+		case 10: esp_info("INTRUSION_RESET\n"); break;       /**<10, Instrusion tested to reset CPU*/
+		case 11: esp_info("TGWDT_CPU_RESET\n"); break;       /**<11, Time Group reset CPU*/
+		case 12: esp_info("SW_CPU_RESET\n"); break;          /**<12, Software reset CPU*/
+		case 13: esp_info("RTCWDT_CPU_RESET\n"); break;      /**<13, RTC Watch dog Reset CPU*/
+		case 14: esp_info("EXT_CPU_RESET\n"); break;         /**<14, for APP CPU, reseted by PRO CPU*/
+		case 15: esp_info("RTCWDT_BROWN_OUT_RESET\n"); break;/**<15, Reset when the vdd voltage is not stable*/
+		case 16: esp_info("RTCWDT_RTC_RESET\n"); break;      /**<16, RTC Watch dog reset digital core and rtc module*/
+		default: esp_info("Unknown[%u]\n", reason); break;
+	}
+}
+
+static int process_fw_data(struct fw_data *fw_p, int tag_len)
+{
+	if (tag_len != sizeof(struct fw_data)) {
+		esp_err("Length not matching to firmware data size\n");
+		return -1;
+	}
+
+	esp_info("ESP chipset's last reset cause:\n");
+	print_reset_reason(le32_to_cpu(fw_p->last_reset_reason));
+
+	return check_esp_version(&fw_p->version);
+}
+
+static int process_event_esp_bootup(struct esp_adapter *adapter, u8 *evt_buf, u8 len)
+{
+	int len_left = len, tag_len, ret = 0;
+	u8 *pos;
+	struct fw_data *fw_p;
+
+	if (!adapter || !evt_buf)
+		return -1;
+
+	if (len_left >= 64) {
+		esp_info("ESP init event len looks unexpected: %u (>=64)\n", len_left);
+		esp_info("You probably facing timing mismatch at transport layer\n");
+	}
+
+	clear_bit(ESP_INIT_DONE, &adapter->state_flags);
+	/* Deinit module if already initialized */
+#if TEST_RAW_TP
+	if (raw_tp_mode != 0) {
+		test_raw_tp_cleanup();
+	}
+#endif
+	esp_deinit_module(adapter);
+
+	pos = evt_buf;
+
+	while (len_left > 0) {
+		tag_len = *(pos + 1);
+
+		esp_info("Bootup Event tag: %d\n", *pos);
+
+		switch (*pos) {
+		case ESP_BOOTUP_CAPABILITY:
+			adapter->capabilities = *(pos + 2);
+			break;
+		case ESP_BOOTUP_FIRMWARE_CHIP_ID:
+			ret = esp_validate_chipset(adapter, *(pos + 2));
+			break;
+		case ESP_BOOTUP_FW_DATA:
+			fw_p = (struct fw_data *)(pos + 2);
+			ret = process_fw_data(fw_p, tag_len);
+			break;
+		case ESP_BOOTUP_SPI_CLK_MHZ:
+			ret = esp_adjust_spi_clock(adapter, *(pos + 2));
+			break;
+		default:
+			esp_warn("Unsupported tag=%x in bootup event\n", *pos);
+		}
+
+		if (ret < 0) {
+			esp_err("failed to process tag=%x in bootup event\n", *pos);
+			return -1;
+		}
+		pos += (tag_len + 2);
+		len_left -= (tag_len + 2);
+	}
+
+	if (adapter->capabilities & ESP_WLAN_SDIO_SUPPORT ||
+		adapter->capabilities & ESP_BT_SDIO_SUPPORT) {
+			atomic_set(&adapter->state, ESP_CONTEXT_READY);
+	}
+	if (esp_add_card(adapter)) {
+		if (adapter->capabilities & ESP_WLAN_SDIO_SUPPORT ||
+		    adapter->capabilities & ESP_BT_SDIO_SUPPORT) {
+			atomic_set(&adapter->state, ESP_CONTEXT_DISABLED);
+			generate_slave_intr(&adapter->if_context, BIT(ESP_CLOSE_DATA_PATH));
+		}
+		esp_err("network interface init failed\n");
+		return -1;
+	}
+	init_bt(adapter);
+
+	if (ota_file && strlen(ota_file) != 0) {
+		esp_info("OTA update requested: bin(%s)\n", ota_file);
+		esp_start_ota(adapter, ota_file);
+		ota_file = NULL;
+		return 0;
+	}
+
+	if (raw_tp_mode !=0) {
+#if TEST_RAW_TP
+		process_test_capabilities(raw_tp_mode);
+		esp_init_raw_tp(adapter);
+#else
+		esp_err("RAW TP mode selected but not enabled\n");
+		return -1;
+#endif
+	}
+	set_bit(ESP_INIT_DONE, &adapter->state_flags);
+	print_capabilities(adapter->capabilities);
+
+	return 0;
+}
+
+static int esp_open(struct net_device *ndev)
+{
+	return 0;
+}
+
+static int esp_stop(struct net_device *ndev)
+{
+	struct esp_wifi_device *priv = netdev_priv(ndev);
+
+	if (!priv)
+		return 0;
+
+	esp_mark_scan_done_and_disconnect(priv, false);
+	esp_port_close(priv);
+	return 0;
+}
+
+static struct net_device_stats *esp_get_stats(struct net_device *ndev)
+{
+	struct esp_wifi_device *priv = netdev_priv(ndev);
+
+	if (!priv)
+		return NULL;
+
+	return &priv->stats;
+}
+
+static int esp_set_mac_address(struct net_device *ndev, void *data)
+{
+	struct esp_wifi_device *priv = netdev_priv(ndev);
+	struct sockaddr *sa = (struct sockaddr *)data;
+	int ret;
+
+	if (!priv || !priv->adapter)
+		return -EINVAL;
+
+	esp_info("%u "MACSTR"\n", __LINE__, MAC2STR(sa->sa_data));
+
+	ret = cmd_set_mac(priv, sa->sa_data);
+
+	if (ret == 0)
+		ETH_HW_ADDR_SET(ndev, priv->mac_address/*mac_addr->sa_data*/);
+
+	return ret;
+}
+
+static void esp_set_rx_mode(struct net_device *ndev)
+{
+        struct esp_adapter *adapter = esp_get_adapter();
+
+	schedule_work(&adapter->mac_flter_work);
+}
+
+static int esp_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct esp_skb_cb *cb = NULL;
+
+	if (!skb || !ndev)
+		return NETDEV_TX_OK;
+
+	priv = netdev_priv(ndev);
+	if (!priv) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	if (!priv->port_open) {
+		priv->stats.tx_dropped++;
+		esp_verbose("Port not yet open\n");
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	if (!skb->len || (skb->len > ETH_FRAME_LEN)) {
+		esp_err("Bad len %d\n", skb->len);
+		priv->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	cb = (struct esp_skb_cb *) skb->cb;
+	cb->priv = priv;
+
+	return process_tx_packet(skb);
+}
+
+static const struct net_device_ops esp_netdev_ops = {
+	.ndo_open = esp_open,
+	.ndo_stop = esp_stop,
+	.ndo_start_xmit = esp_hard_start_xmit,
+	.ndo_set_mac_address = esp_set_mac_address,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_get_stats = esp_get_stats,
+	.ndo_set_rx_mode = esp_set_rx_mode,
+};
+
+
+void esp_init_priv(struct net_device *ndev)
+{
+	ndev->netdev_ops = &esp_netdev_ops;
+	ndev->needed_headroom = roundup(sizeof(struct esp_payload_header) +
+			INTERFACE_HEADER_PADDING, 4);
+}
+
+static int esp_add_network_ifaces(struct esp_adapter *adapter)
+{
+	struct wireless_dev *wdev = NULL;
+
+	if (!adapter) {
+		esp_info("adapter not yet init\n");
+		return -EINVAL;
+	}
+
+	rtnl_lock();
+	wdev = esp_cfg80211_add_iface(adapter->wiphy, "wlan%d", 1, NL80211_IFTYPE_STATION, NULL);
+	rtnl_unlock();
+
+	/* Return success if network added successfully */
+	if (wdev)
+		return 0;
+
+	return -1;
+}
+
+int esp_start_ota(struct esp_adapter *adapter, char *ota_file)
+{
+	struct file *file;
+	ssize_t nread;
+	int ret = 0;
+	char *ota_chunk = kmalloc(OTA_CHUNK_SIZE, GFP_KERNEL);;
+
+	if (!ota_chunk) {
+		esp_err("Failed to allocate buffer for ota_chunk\n");
+		return -ENOMEM;
+	}
+
+	memset(ota_chunk, 0, OTA_CHUNK_SIZE);
+
+	file = filp_open(ota_file, O_RDONLY, 0);
+
+	if (IS_ERR(file)) {
+		esp_err("Error reading ota bin, or ota bin not found at %s \n", ota_file);
+		kfree(ota_chunk);
+		return -EINVAL;
+	}
+
+	set_bit(ESP_OTA_IN_PROGRESS, &adapter->state_flags);
+	if (cmd_process_ota_start(adapter->priv[ESP_STA_NW_IF]) != 0) {
+		esp_err("OTA Start failed\n");
+		ret = EINVAL;
+		goto done;
+	}
+
+	while ((nread = kernel_read(file, ota_chunk, OTA_CHUNK_SIZE, &file->f_pos)) > 0) {
+		if (cmd_process_ota_write(adapter->priv[ESP_STA_NW_IF], ota_chunk, nread) !=0) {
+			esp_err("OTA Write failed\n");
+			ret = EINVAL;
+			goto done;
+		}
+		if (nread < OTA_CHUNK_SIZE) {
+			break;
+		}
+	}
+
+	if (nread < 0) {
+		esp_err("Failed to read ota binary file %s \n", ota_file);
+		ret = EINVAL;
+		goto done;
+	}
+
+
+	ret = cmd_process_ota_end(adapter->priv[ESP_STA_NW_IF]);
+	if (ret != 0) {
+		esp_err("cmd_process_ota_end failed %d \n", ret);
+	}
+
+done:
+	kfree(ota_chunk);
+	filp_close(file, NULL);
+	clear_bit(ESP_OTA_IN_PROGRESS, &adapter->state_flags);
+	return ret;
+}
+
+int esp_init_raw_tp(struct esp_adapter *adapter)
+{
+	RET_ON_FAIL(cmd_init_raw_tp_task_timer(adapter->priv[ESP_STA_NW_IF]));
+	return 0;
+}
+
+int esp_add_card(struct esp_adapter *adapter)
+{
+	RET_ON_FAIL(esp_commands_setup(adapter));
+	RET_ON_FAIL(esp_add_wiphy(adapter));
+	RET_ON_FAIL(esp_add_network_ifaces(adapter));
+	clear_bit(ESP_CLEANUP_IN_PROGRESS, &adapter->state_flags);
+
+	return 0;
+}
+
+static int esp_remove_network_ifaces(struct esp_adapter *adapter)
+{
+	uint8_t iface_idx = 0;
+	struct net_device *ndev = NULL;
+	struct esp_wifi_device *priv = NULL;
+
+	for (iface_idx = 0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+
+		priv = adapter->priv[iface_idx];
+		if (!priv)
+			continue;
+		if (!test_bit(ESP_NETWORK_UP, &priv->priv_flags))
+			continue;
+
+		ndev = priv->ndev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		if (ndev)
+			ndev->needs_free_netdev = true;
+		rtnl_lock();
+		wiphy_lock(adapter->wiphy);
+		cfg80211_unregister_wdev(&priv->wdev);
+		wiphy_unlock(adapter->wiphy);
+		rtnl_unlock();
+#else
+		if (ndev && ndev->reg_state == NETREG_REGISTERED) {
+			unregister_netdev(ndev);
+			free_netdev(ndev);
+			ndev = NULL;
+		}
+#endif
+		adapter->priv[iface_idx] = NULL;
+	}
+
+	return 0;
+}
+
+static int stop_network_iface(struct esp_wifi_device *priv)
+{
+	struct net_device *ndev;
+
+	if (!priv)
+		return 0;
+
+	if (!test_bit(ESP_NETWORK_UP, &priv->priv_flags))
+		return 0;
+
+	esp_mark_scan_done_and_disconnect(priv, false);
+	esp_port_close(priv);
+
+	/* stop and unregister network */
+	ndev = priv->ndev;
+
+	if (ndev) {
+		netif_carrier_off(ndev);
+		netif_device_detach(ndev);
+
+		unregister_inetaddr_notifier(&(priv->nb));
+	}
+
+	return 0;
+}
+
+static int esp_stop_network_ifaces(struct esp_adapter *adapter)
+{
+	uint8_t iface_idx = 0;
+
+	for (iface_idx = 0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+		stop_network_iface(adapter->priv[iface_idx]);
+	}
+
+	rtnl_lock();
+	if (adapter->wiphy)
+		cfg80211_shutdown_all_interfaces(adapter->wiphy);
+
+	rtnl_unlock();
+
+	return 0;
+}
+
+int esp_remove_card(struct esp_adapter *adapter)
+{
+	if (!adapter) {
+		return 0;
+	}
+
+	esp_stop_network_ifaces(adapter);
+	esp_cfg_cleanup(adapter);
+	/* BT may have been initialized after fw bootup event, deinit it */
+	esp_deinit_bt(adapter);
+
+	if (adapter->if_rx_workqueue) {
+		flush_workqueue(adapter->if_rx_workqueue);
+	}
+	esp_commands_teardown(adapter);
+	esp_remove_network_ifaces(adapter);
+	esp_remove_wiphy(adapter);
+
+	return 0;
+}
+
+struct esp_wifi_device *get_priv_from_payload_header(
+		struct esp_payload_header *header)
+{
+	struct esp_wifi_device *priv = NULL;
+	u8 i = 0;
+
+	if (!header)
+		return NULL;
+
+	for (i = 0; i < ESP_MAX_INTERFACE; i++) {
+		priv = adapter.priv[i];
+
+		if (!priv) {
+			esp_err("dropping pkt, driver not initialized\n");
+			continue;
+		}
+
+		if (priv->if_num == header->if_num) {
+			return priv;
+		} else {
+			esp_err("dropping pkt, priv iftype=%d ifnum=%d, header iftype=%d ifnum=%d\n", priv->if_type, priv->if_num, header->if_type, header->if_num);
+		}
+	}
+	return NULL;
+}
+
+static void process_esp_bootup_event(struct esp_adapter *adapter,
+		struct esp_internal_bootup_event *evt)
+{
+	if (!adapter || !evt) {
+		esp_err("Invalid arguments\n");
+		return;
+	}
+
+	if (evt->header.status) {
+		esp_err("Incorrect ESP bootup event\n");
+		return;
+	}
+
+	esp_info("Received ESP bootup event\n");
+	process_event_esp_bootup(adapter, evt->data, evt->len);
+}
+
+static int process_internal_event(struct esp_adapter *adapter,
+		struct sk_buff *skb)
+{
+	struct event_header *header = NULL;
+
+	if (!skb || !adapter) {
+		esp_err("Incorrect event data!\n");
+		return -1;
+	}
+
+	header = (struct event_header *) (skb->data);
+
+	switch (header->event_code) {
+
+	case ESP_INTERNAL_BOOTUP_EVENT:
+		process_esp_bootup_event(adapter,
+			(struct esp_internal_bootup_event *)(skb->data));
+		break;
+
+	default:
+		esp_info("%u unhandled internal event[%u]\n",
+				__LINE__, header->event_code);
+		break;
+	}
+
+	return 0;
+}
+
+static void process_rx_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct esp_payload_header *payload_header = NULL;
+	u16 len = 0, offset = 0;
+	u16 rx_checksum = 0, checksum = 0;
+	struct hci_dev *hdev = adapter->hcidev;
+	u8 *type = NULL;
+
+	if (!skb)
+		return;
+
+	/* get the paload header */
+	payload_header = (struct esp_payload_header *) skb->data;
+
+	len = le16_to_cpu(payload_header->len);
+	offset = le16_to_cpu(payload_header->offset);
+
+	if (payload_header->reserved2 == 0xFF) {
+		esp_hex_dump("Wake up packet: ", skb->data, len+offset);
+	}
+
+	if (adapter->capabilities & ESP_CHECKSUM_ENABLED) {
+		rx_checksum = le16_to_cpu(payload_header->checksum);
+		payload_header->checksum = 0;
+
+		checksum = compute_checksum(skb->data, (len + offset));
+
+		if (checksum != rx_checksum) {
+			dev_kfree_skb_any(skb);
+			return;
+		}
+	}
+
+	/* chop off the header from skb */
+	skb_pull(skb, offset);
+
+	if (payload_header->if_type == ESP_STA_IF || payload_header->if_type == ESP_AP_IF) {
+
+		/* retrieve priv based on payload header contents */
+		priv = get_priv_from_payload_header(payload_header);
+
+		if (!priv) {
+			dev_kfree_skb_any(skb);
+			return;
+		}
+
+		if (payload_header->packet_type == PACKET_TYPE_EAPOL) {
+			esp_dbg("Rx PACKET_TYPE_EAPOL!!!!\n");
+			esp_port_open(priv);
+			skb->dev = priv->ndev;
+			skb->protocol = eth_type_trans(skb, priv->ndev);
+			netif_rx(skb);
+
+		} else if (payload_header->packet_type == PACKET_TYPE_DATA) {
+
+			skb->dev = priv->ndev;
+			skb->protocol = eth_type_trans(skb, priv->ndev);
+			skb->ip_summed = CHECKSUM_NONE;
+
+			priv->stats.rx_bytes += skb->len;
+			/* Forward skb to kernel */
+			NETIF_RX_NI(skb);
+			priv->stats.rx_packets++;
+		} else if (payload_header->packet_type == PACKET_TYPE_COMMAND_RESPONSE) {
+			process_cmd_resp(priv->adapter, skb);
+		} else if (payload_header->packet_type == PACKET_TYPE_EVENT) {
+			process_cmd_event(priv, skb);
+			dev_kfree_skb_any(skb);
+		}
+
+	} else if (payload_header->if_type == ESP_HCI_IF) {
+		if (hdev) {
+
+			type = skb->data;
+			hci_skb_pkt_type(skb) = *type;
+			skb_pull(skb, 1);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0))
+			if (hci_recv_frame(hdev, skb)) {
+#else
+			if (hci_recv_frame(skb)) {
+#endif
+				hdev->stat.err_rx++;
+			} else {
+				esp_hci_update_rx_counter(hdev, *type, skb->len);
+			}
+		}
+	} else if (payload_header->if_type == ESP_INTERNAL_IF) {
+
+		/* Queue event skb for processing in events workqueue */
+		skb_queue_tail(&adapter->events_skb_q, skb);
+
+		if (adapter->events_wq)
+			queue_work(adapter->events_wq, &adapter->events_work);
+		else
+			dev_kfree_skb_any(skb);
+
+	} else if (payload_header->if_type == ESP_TEST_IF) {
+#if TEST_RAW_TP
+		if (raw_tp_mode != 0) {
+			update_test_raw_tp_rx_stats(len);
+		}
+#endif
+		dev_kfree_skb_any(skb);
+	} else {
+		dev_kfree_skb_any(skb);
+	}
+}
+
+char *esp_get_hardware_name(int hardware_id)
+{
+	if(hardware_id == ESP_FIRMWARE_CHIP_ESP32)
+		return "ESP32";
+	else if(hardware_id == ESP_FIRMWARE_CHIP_ESP32S2)
+		return "ESP32S2";
+	else if(hardware_id == ESP_FIRMWARE_CHIP_ESP32C3)
+		return "ESP32C3";
+	else if(hardware_id == ESP_FIRMWARE_CHIP_ESP32S3)
+		return "ESP32S3";
+	else if(hardware_id == ESP_FIRMWARE_CHIP_ESP32C2)
+		return "ESP32C2";
+	else if(hardware_id == ESP_FIRMWARE_CHIP_ESP32C6)
+		return "ESP32C6";
+	else if(hardware_id == ESP_FIRMWARE_CHIP_ESP32C5)
+		return "ESP32C5";
+	else
+		return "N/A";
+}
+
+bool esp_is_valid_hardware_id(int hardware_id)
+{
+	switch(hardware_id) {
+	case ESP_FIRMWARE_CHIP_ESP32:
+	case ESP_FIRMWARE_CHIP_ESP32S2:
+	case ESP_FIRMWARE_CHIP_ESP32C3:
+	case ESP_FIRMWARE_CHIP_ESP32S3:
+	case ESP_FIRMWARE_CHIP_ESP32C2:
+	case ESP_FIRMWARE_CHIP_ESP32C6:
+	case ESP_FIRMWARE_CHIP_ESP32C5:
+		return true;
+	default:
+		return false;
+	}
+}
+
+int esp_is_tx_queue_paused(struct esp_wifi_device *priv)
+{
+	if (!priv || !priv->ndev)
+		return 0;
+
+	if ((priv->ndev &&
+		    !netif_queue_stopped((const struct net_device *)priv->ndev)))
+		return 1;
+    return 0;
+}
+
+void esp_tx_pause(struct esp_wifi_device *priv)
+{
+	if (!priv || !priv->ndev)
+		return;
+
+	if (!netif_queue_stopped((const struct net_device *)priv->ndev)) {
+		netif_stop_queue(priv->ndev);
+	}
+}
+
+void esp_tx_resume(struct esp_wifi_device *priv)
+{
+	if (!priv || !priv->ndev)
+		return;
+
+	if (netif_queue_stopped((const struct net_device *)priv->ndev)) {
+		netif_wake_queue(priv->ndev);
+	}
+}
+
+struct sk_buff *esp_alloc_skb(u32 len)
+{
+	struct sk_buff *skb = NULL;
+
+	u8 offset;
+
+	skb = netdev_alloc_skb(NULL, len + INTERFACE_HEADER_PADDING);
+
+	if (skb) {
+		/* Align SKB data pointer */
+		offset = ((unsigned long)skb->data) & (SKB_DATA_ADDR_ALIGNMENT - 1);
+
+		if (offset)
+			skb_reserve(skb, INTERFACE_HEADER_PADDING - offset);
+	}
+
+	return skb;
+}
+
+
+static int esp_get_packets(struct esp_adapter *adapter)
+{
+	struct sk_buff *skb = NULL;
+
+	if (!adapter || !adapter->if_ops || !adapter->if_ops->read)
+		return -EINVAL;
+
+	while ((skb = adapter->if_ops->read(adapter)))
+		process_rx_packet(adapter, skb);
+
+	return 0;
+}
+
+int esp_send_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	if (!adapter || !adapter->if_ops || !adapter->if_ops->write) {
+		esp_err("%u adapter: %p\n", __LINE__, adapter);
+		return -EINVAL;
+	}
+
+	return adapter->if_ops->write(adapter, skb);
+}
+
+static void esp_if_rx_work(struct work_struct *work)
+{
+	/* read inbound packet and forward it to network/serial interface */
+	esp_get_packets(&adapter);
+}
+
+static void update_mac_filter(struct work_struct *work)
+{
+	struct esp_adapter *adapter = esp_get_adapter();
+	struct esp_wifi_device *priv = adapter->priv[0];
+	struct net_device *ndev;
+	struct netdev_hw_addr *mac_addr;
+	u32 count = 0;
+
+	if (!priv)
+		return;
+
+	ndev = priv->ndev;
+	if (!ndev)
+		return;
+
+	if (!priv->port_open) {
+		esp_verbose("Port is not open yet, skipping mac filter update\n");
+		return;
+	}
+
+#if CONFIG_ALLOW_MULTICAST_WAKEUP
+	netdev_for_each_mc_addr(mac_addr, ndev) {
+		if (count < MAX_MULTICAST_ADDR_COUNT) {
+			esp_verbose("%d: "MACSTR"\n", count+1, MAC2STR(mac_addr->addr));
+			memcpy(&mcast_list.mcast_addr[count++], mac_addr->addr, ETH_ALEN);
+		}
+	}
+
+	mcast_list.priv = priv;
+	mcast_list.addr_count = count;
+
+	esp_verbose("Setting Multicast list\n");
+	cmd_set_mcast_mac_list(mcast_list.priv, &mcast_list);
+#else
+  esp_info("Not setting FW multicast addresses\n");
+#endif
+}
+
+static void esp_events_work(struct work_struct *work)
+{
+	struct sk_buff *skb = NULL;
+
+	while ((skb = skb_dequeue(&adapter.events_skb_q)) != NULL) {
+		if (skb->data) {
+			process_internal_event(&adapter, skb);
+		}
+		dev_kfree_skb_any(skb);
+	}
+}
+
+static struct esp_adapter *init_adapter(void)
+{
+	memset(&adapter, 0, sizeof(adapter));
+
+	/* Prepare interface RX work */
+	adapter.if_rx_workqueue = alloc_workqueue("ESP_IF_RX_WORK_QUEUE", 0, 0);
+
+	if (!adapter.if_rx_workqueue) {
+		deinit_adapter();
+		return NULL;
+	}
+
+	INIT_WORK(&adapter.if_rx_work, esp_if_rx_work);
+
+	skb_queue_head_init(&adapter.events_skb_q);
+
+	adapter.events_wq = alloc_workqueue("ESP_EVENTS_WORKQUEUE", WQ_HIGHPRI, 0);
+
+	if (!adapter.events_wq) {
+		deinit_adapter();
+		return NULL;
+	}
+
+	INIT_WORK(&adapter.events_work, esp_events_work);
+
+	INIT_WORK(&adapter.mac_flter_work, update_mac_filter);
+
+	return &adapter;
+}
+
+static void deinit_adapter(void)
+{
+	if (adapter.if_context)
+		atomic_set(&adapter.state, ESP_CONTEXT_DISABLED);
+
+	skb_queue_purge(&adapter.events_skb_q);
+
+	if (adapter.events_wq)
+		destroy_workqueue(adapter.events_wq);
+
+	if (adapter.if_rx_workqueue)
+		destroy_workqueue(adapter.if_rx_workqueue);
+}
+
+int esp_init(void)
+{
+	int ret = 0;
+	struct esp_adapter *adapter = NULL;
+
+	esp_dbg("begin\n");
+
+	adapter = init_adapter();
+
+	if (!adapter)
+		return -EFAULT;
+
+	/* Init transport layer */
+	ret = esp_init_interface_layer(adapter);
+
+	if (ret != 0) {
+		deinit_adapter();
+		return ret;
+	}
+
+	ret = debugfs_init();
+
+	esp_info("end %d\n", ret);
+	return ret;
+}
+
+void esp_exit(void)
+{
+	uint8_t iface_idx = 0;
+#if TEST_RAW_TP
+	if (raw_tp_mode != 0) {
+		test_raw_tp_cleanup();
+	}
+#endif
+	for (iface_idx = 0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+		cmd_deinit_interface(adapter.priv[iface_idx]);
+	}
+	clear_bit(ESP_DRIVER_ACTIVE, &adapter.state_flags);
+
+	esp_deinit_interface_layer();
+	deinit_adapter();
+
+	debugfs_exit();
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c
new file mode 100644
index 0000000..85ccf18
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c
@@ -0,0 +1,958 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/mutex.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include "esp_api.h"
+#include "esp_bt_api.h"
+#include "esp_fw_version.h"
+#include "esp_if.h"
+#include "esp_kernel_port.h"
+#include "esp_sdio_api.h"
+#include "esp_stats.h"
+#include "esp_utils.h"
+#include "main.h"
+#include "utils.h"
+
+extern u32 raw_tp_mode;
+#define MAX_WRITE_RETRIES       2
+#define TX_MAX_PENDING_COUNT    200
+#define TX_RESUME_THRESHOLD     (TX_MAX_PENDING_COUNT/5)
+
+#define CHECK_SDIO_RW_ERROR(ret) do {			\
+	if (ret)						\
+	esp_err("CMD53 read/write error at %d\n", __LINE__);	\
+} while (0);
+
+static atomic_t tx_pending;
+static atomic_t queue_items[MAX_PRIORITY_QUEUES];
+
+struct task_struct *tx_thread;
+
+volatile u8 host_sleep;
+
+static int init_context(struct esp_sdio_context *context);
+static struct sk_buff *read_packet(struct esp_adapter *adapter);
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb);
+
+static void esp_process_interrupt(struct esp_sdio_context *context, u32 int_status)
+{
+	if (!context) {
+		return;
+	}
+
+	if (int_status & ESP_SLAVE_RX_NEW_PACKET_INT) {
+		esp_process_new_packet_intr(context->adapter);
+	}
+}
+
+static void esp_handle_isr(struct sdio_func *func)
+{
+	struct esp_sdio_context *context;
+	u32 *int_status;
+	int ret;
+
+	if (!func) {
+		return;
+	}
+
+	if (host_sleep)
+		return;
+
+	context = sdio_get_drvdata(func);
+
+	if (!(context) ||
+	    !(context->adapter) ||
+	    (atomic_read(&context->adapter->state) < ESP_CONTEXT_RX_READY)) {
+		return;
+	}
+
+	int_status = kmalloc(sizeof(u32), GFP_ATOMIC);
+
+	if (!int_status) {
+		return;
+	}
+
+	/* Read interrupt status register */
+	ret = esp_read_reg(context, ESP_SLAVE_INT_ST_REG,
+			(u8 *) int_status, sizeof(*int_status), ACQUIRE_LOCK);
+	CHECK_SDIO_RW_ERROR(ret);
+
+	esp_process_interrupt(context, *int_status);
+
+	/* Clear interrupt status */
+	ret = esp_write_reg(context, ESP_SLAVE_INT_CLR_REG,
+			(u8 *) int_status, sizeof(*int_status), ACQUIRE_LOCK);
+	CHECK_SDIO_RW_ERROR(ret);
+
+	kfree(int_status);
+}
+
+int generate_slave_intr(void *context, u8 data)
+{
+	u8 *val;
+	int ret = 0;
+
+	context = (struct esp_sdio_context*) context;
+	if (!context)
+		return -EINVAL;
+
+	val = kmalloc(sizeof(u8), GFP_KERNEL);
+
+	if (!val) {
+		return -ENOMEM;
+	}
+
+	*val = data;
+
+	ret = esp_write_reg(context, ESP_SLAVE_SCRATCH_REG_7, val,
+			sizeof(*val), ACQUIRE_LOCK);
+
+	kfree(val);
+
+	return ret;
+}
+
+static void deinit_sdio_func(struct sdio_func *func)
+{
+	sdio_set_drvdata(func, NULL);
+	sdio_claim_host(func);
+	/* Release IRQ */
+	sdio_release_irq(func);
+	/* Disable sdio function */
+	sdio_disable_func(func);
+	sdio_release_host(func);
+}
+
+static int esp_slave_get_tx_buffer_num(struct esp_sdio_context *context, u32 *tx_num, u8 is_lock_needed)
+{
+	u32 *len = NULL;
+	int ret = 0;
+
+	len = kmalloc(sizeof(u32), GFP_KERNEL);
+
+	if (!len) {
+		return -ENOMEM;
+	}
+
+	ret = esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (u8 *) len, sizeof(*len), is_lock_needed);
+
+	if (ret) {
+		kfree(len);
+		return ret;
+	}
+
+	*len = (*len >> 16) & ESP_TX_BUFFER_MASK;
+	*len = (*len + ESP_TX_BUFFER_MAX - context->tx_buffer_count) % ESP_TX_BUFFER_MAX;
+
+	*tx_num = *len;
+
+	kfree(len);
+	return ret;
+}
+
+int esp_deinit_module(struct esp_adapter *adapter)
+{
+	/* Second & onward bootup cleanup is not required for SDIO:
+	 * As Removal of SDIO triggers complete Deinit and SDIO insertion/
+	 * detection, triggers probing which does initialization.
+	 */
+	return 0;
+}
+
+static int esp_get_len_from_slave(struct esp_sdio_context *context, u32 *rx_size, u8 is_lock_needed)
+{
+	u32 *len;
+	u32 temp;
+	int ret = 0;
+
+	len = kmalloc(sizeof(u32), GFP_KERNEL);
+
+	if (!len) {
+		return -ENOMEM;
+	}
+
+	ret = esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+			(u8 *) len, sizeof(*len), is_lock_needed);
+
+	if (ret) {
+		kfree(len);
+		return ret;
+	}
+
+	*len &= ESP_SLAVE_LEN_MASK;
+
+	if (*len >= context->rx_byte_count)
+		*len = (*len + ESP_RX_BYTE_MAX - context->rx_byte_count) % ESP_RX_BYTE_MAX;
+	else {
+		/* Handle a case of roll over */
+		temp = ESP_RX_BYTE_MAX - context->rx_byte_count;
+		*len = temp + *len;
+
+		if (*len > ESP_RX_BUFFER_SIZE) {
+			esp_info("Len from slave[%d] exceeds max [%d]\n",
+					*len, ESP_RX_BUFFER_SIZE);
+		}
+	}
+	*rx_size = *len;
+
+	kfree(len);
+	return 0;
+}
+
+
+#if 0
+static void flush_sdio(struct esp_sdio_context *context)
+{
+	struct sk_buff *skb;
+
+	if (!context || !context->adapter)
+		return;
+
+	while (1) {
+		skb = read_packet(context->adapter);
+
+		if (!skb) {
+			break;
+		}
+
+		if (skb->len)
+			esp_info("Flushed %d bytes\n", skb->len);
+		dev_kfree_skb(skb);
+		skb = NULL;
+	}
+}
+#endif
+
+static void esp_remove(struct sdio_func *func)
+{
+	struct esp_sdio_context *context;
+	uint8_t prio_q_idx = 0;
+
+	context = sdio_get_drvdata(func);
+
+	if (func->num != 1) {
+		return;
+	}
+
+	if (context) {
+		for (prio_q_idx = 0; prio_q_idx < MAX_PRIORITY_QUEUES; prio_q_idx++)
+			skb_queue_purge(&(context->tx_q[prio_q_idx]));
+	}
+
+	if (tx_thread)
+		kthread_stop(tx_thread);
+
+	if (context) {
+		generate_slave_intr(context, BIT(ESP_CLOSE_DATA_PATH));
+		msleep(100);
+
+		if (context->adapter) {
+			esp_remove_card(context->adapter);
+
+			if (context->adapter->hcidev) {
+				esp_deinit_bt(context->adapter);
+			}
+		}
+
+
+		if (context->func) {
+			deinit_sdio_func(context->func);
+			context->func = NULL;
+			context->adapter->dev = NULL;
+		}
+		memset(context, 0, sizeof(struct esp_sdio_context));
+	}
+	esp_dbg("ESP SDIO cleanup completed\n");
+}
+
+static struct esp_if_ops if_ops = {
+	.read		= read_packet,
+	.write		= write_packet,
+};
+
+static int get_firmware_data(struct esp_sdio_context *context)
+{
+	u32 *val;
+	int ret = 0;
+
+	val = kmalloc(sizeof(u32), GFP_KERNEL);
+
+	if (!val) {
+		return -ENOMEM;
+	}
+
+	/* Initialize rx_byte_count */
+	ret = esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+			(u8 *) val, sizeof(*val), ACQUIRE_LOCK);
+	if (ret) {
+		kfree(val);
+		return ret;
+	}
+
+	esp_info("Rx Pre ====== %d\n", context->rx_byte_count);
+	context->rx_byte_count = *val & ESP_SLAVE_LEN_MASK;
+	esp_info("Rx Pos ======  %d\n", context->rx_byte_count);
+
+	/* Initialize tx_buffer_count */
+	ret = esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (u8 *) val,
+			sizeof(*val), ACQUIRE_LOCK);
+
+	if (ret) {
+		kfree(val);
+		return ret;
+	}
+
+	*val = ((*val >> 16) & ESP_TX_BUFFER_MASK);
+	esp_info("Tx Pre ======  %d\n", context->tx_buffer_count);
+
+	if (*val >= ESP_MAX_BUF_CNT)
+		context->tx_buffer_count = (*val) - ESP_MAX_BUF_CNT;
+	else
+		context->tx_buffer_count = 0;
+	esp_info("Tx Pos ======  %d\n", context->tx_buffer_count);
+
+	kfree(val);
+	return ret;
+}
+
+static int init_context(struct esp_sdio_context *context)
+{
+	int ret = 0;
+	uint8_t prio_q_idx = 0;
+
+	if (!context) {
+		return -EINVAL;
+	}
+
+	ret = get_firmware_data(context);
+	if (ret)
+		return ret;
+
+	context->adapter = esp_get_adapter();
+
+	if (unlikely(!context->adapter))
+		esp_err("Failed to get adapter\n");
+
+	for (prio_q_idx = 0; prio_q_idx < MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_head_init(&(context->tx_q[prio_q_idx]));
+		atomic_set(&queue_items[prio_q_idx], 0);
+	}
+
+	context->adapter->if_type = ESP_IF_TYPE_SDIO;
+
+	return 0;
+}
+
+static struct sk_buff *read_packet(struct esp_adapter *adapter)
+{
+	u32 len_from_slave, data_left, len_to_read, size, num_blocks;
+	int ret = 0;
+	struct sk_buff *skb;
+	u8 *pos;
+	struct esp_sdio_context *context;
+
+	if (!adapter || !adapter->if_context) {
+		esp_err("INVALID args\n");
+		return NULL;
+	}
+
+	context = adapter->if_context;
+
+	if (!context || !context->func) {
+		esp_err("Invalid context/state\n");
+		return NULL;
+	}
+
+	sdio_claim_host(context->func);
+
+	data_left = len_to_read = len_from_slave = num_blocks = 0;
+
+	/* Read length */
+	ret = esp_get_len_from_slave(context, &len_from_slave, LOCK_ALREADY_ACQUIRED);
+
+	if (ret || !len_from_slave) {
+		sdio_release_host(context->func);
+		return NULL;
+	}
+
+	size = ESP_BLOCK_SIZE * 4;
+
+	if (len_from_slave > size) {
+		esp_info("Rx large packet: %d\n", len_from_slave);
+	}
+
+	skb = esp_alloc_skb(len_from_slave);
+
+	if (!skb) {
+		esp_err("SKB alloc failed\n");
+		sdio_release_host(context->func);
+		return NULL;
+	}
+
+	skb_put(skb, len_from_slave);
+	pos = skb->data;
+
+	data_left = len_from_slave;
+
+	do {
+		num_blocks = data_left/ESP_BLOCK_SIZE;
+
+#if 0
+		if (!context->rx_byte_count) {
+			start_time = ktime_get_ns();
+		}
+#endif
+
+		if (num_blocks) {
+			len_to_read = num_blocks * ESP_BLOCK_SIZE;
+			ret = esp_read_block(context,
+					ESP_SLAVE_CMD53_END_ADDR - len_to_read,
+					pos, len_to_read, LOCK_ALREADY_ACQUIRED);
+		} else {
+			len_to_read = data_left;
+			/* 4 byte aligned length */
+			ret = esp_read_block(context,
+					ESP_SLAVE_CMD53_END_ADDR - len_to_read,
+					pos, (len_to_read + 3) & (~3), LOCK_ALREADY_ACQUIRED);
+		}
+
+		if (ret) {
+			esp_err("Failed to read data - %d [%u - %d]\n", ret, num_blocks, len_to_read);
+			atomic_set(&context->adapter->state, ESP_CONTEXT_DISABLED);
+			dev_kfree_skb(skb);
+			skb = NULL;
+			sdio_release_host(context->func);
+			return NULL;
+		}
+
+		data_left -= len_to_read;
+		pos += len_to_read;
+		context->rx_byte_count += len_to_read;
+		context->rx_byte_count = context->rx_byte_count % ESP_RX_BYTE_MAX;
+
+	} while (data_left > 0);
+
+	sdio_release_host(context->func);
+
+	return skb;
+}
+
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	u32 max_pkt_size = ESP_RX_BUFFER_SIZE - sizeof(struct esp_payload_header);
+	struct esp_payload_header *payload_header = (struct esp_payload_header *) skb->data;
+	struct esp_skb_cb *cb = NULL;
+	uint8_t prio = PRIO_Q_LOW;
+	struct esp_sdio_context *context;
+
+	if (!adapter || !adapter->if_context || !skb || !skb->data || !skb->len) {
+		esp_err("Invalid args\n");
+		if (skb) {
+			dev_kfree_skb(skb);
+			skb = NULL;
+		}
+
+		return -EINVAL;
+	}
+
+	context = adapter->if_context;
+
+	if (skb->len > max_pkt_size) {
+		esp_err("Drop pkt of len[%u] > max SDIO transport len[%u]\n",
+				skb->len, max_pkt_size);
+		dev_kfree_skb(skb);
+		skb = NULL;
+		return -EPERM;
+	}
+
+	cb = (struct esp_skb_cb *)skb->cb;
+	if (cb && cb->priv && (atomic_read(&tx_pending) >= TX_MAX_PENDING_COUNT)) {
+		esp_tx_pause(cb->priv);
+		dev_kfree_skb(skb);
+		skb = NULL;
+/*		esp_err("TX Pause busy");*/
+		return -EBUSY;
+	}
+
+	/* Enqueue SKB in tx_q */
+	atomic_inc(&tx_pending);
+
+	/* Notify to process queue */
+	if (payload_header->if_type == ESP_INTERNAL_IF)
+		prio = PRIO_Q_HIGH;
+	else if (payload_header->if_type == ESP_HCI_IF)
+		prio = PRIO_Q_MID;
+	else
+		prio = PRIO_Q_LOW;
+
+	atomic_inc(&queue_items[prio]);
+	skb_queue_tail(&(context->tx_q[prio]), skb);
+
+	return 0;
+}
+
+static int is_sdio_write_buffer_available(struct esp_sdio_context *context, u32 buf_needed)
+{
+#define BUFFER_AVAILABLE        1
+#define BUFFER_UNAVAILABLE      0
+
+	int ret = 0;
+	static u32 buf_available;
+	u8 retry = MAX_WRITE_RETRIES;
+
+	/*If buffer needed are less than buffer available
+	  then only read for available buffer number from slave*/
+	if (buf_available < buf_needed) {
+		while (retry) {
+			ret = esp_slave_get_tx_buffer_num(context, &buf_available, ACQUIRE_LOCK);
+
+			if (buf_available < buf_needed) {
+
+				/* Release SDIO and retry after delay*/
+				retry--;
+				usleep_range(10, 50);
+				continue;
+			}
+
+			break;
+		}
+	}
+
+	if (buf_available >= buf_needed)
+		buf_available -= buf_needed;
+
+	if (!retry) {
+		/* No buffer available at slave */
+		return BUFFER_UNAVAILABLE;
+	}
+
+	return BUFFER_AVAILABLE;
+}
+
+static int tx_process(void *data)
+{
+	int ret = 0;
+	u32 block_cnt = 0;
+	u32 buf_needed = 0;
+	u8 *pos = NULL;
+	u32 data_left, len_to_send, pad;
+	struct sk_buff *tx_skb = NULL;
+	struct esp_adapter *adapter = (struct esp_adapter *) data;
+	struct esp_sdio_context *context;
+	struct esp_skb_cb *cb = NULL;
+	u8 retry;
+
+	context = adapter->if_context;
+
+	while (!kthread_should_stop()) {
+
+		if (atomic_read(&adapter->state) < ESP_CONTEXT_READY) {
+			msleep(10);
+			esp_dbg("not ready\n");
+			continue;
+		}
+
+		if (host_sleep) {
+			/* TODO: Use wait_event_interruptible_timeout */
+			msleep(100);
+			continue;
+		}
+
+		if (atomic_read(&queue_items[PRIO_Q_HIGH]) > 0) {
+			tx_skb = skb_dequeue(&(context->tx_q[PRIO_Q_HIGH]));
+			if (!tx_skb) {
+				continue;
+			}
+			atomic_dec(&queue_items[PRIO_Q_HIGH]);
+		} else if (atomic_read(&queue_items[PRIO_Q_MID]) > 0) {
+			tx_skb = skb_dequeue(&(context->tx_q[PRIO_Q_MID]));
+			if (!tx_skb) {
+				continue;
+			}
+			atomic_dec(&queue_items[PRIO_Q_MID]);
+		} else if (atomic_read(&queue_items[PRIO_Q_LOW]) > 0) {
+			tx_skb = skb_dequeue(&(context->tx_q[PRIO_Q_LOW]));
+			if (!tx_skb) {
+				continue;
+			}
+			atomic_dec(&queue_items[PRIO_Q_LOW]);
+		} else {
+			/* esp_verbose("not ready high=%d mid=%d low=%d\n",
+					atomic_read(&queue_items[PRIO_Q_HIGH]),
+					atomic_read(&queue_items[PRIO_Q_MID]),
+					atomic_read(&queue_items[PRIO_Q_LOW])); */
+			msleep(1);
+			continue;
+		}
+
+		if (atomic_read(&tx_pending))
+			atomic_dec(&tx_pending);
+
+		retry = MAX_WRITE_RETRIES;
+
+		/* resume network tx queue if bearable load */
+		cb = (struct esp_skb_cb *)tx_skb->cb;
+		if (cb && cb->priv && atomic_read(&tx_pending) < TX_RESUME_THRESHOLD) {
+			esp_tx_resume(cb->priv);
+#if TEST_RAW_TP
+			if (raw_tp_mode != 0) {
+				esp_raw_tp_queue_resume();
+			}
+#endif
+		}
+
+		buf_needed = (tx_skb->len + ESP_RX_BUFFER_SIZE - 1) / ESP_RX_BUFFER_SIZE;
+
+		/*If SDIO slave buffer is available to write then only write data
+		else wait till buffer is available*/
+		ret = is_sdio_write_buffer_available(context, buf_needed);
+		if (!ret) {
+			dev_kfree_skb(tx_skb);
+			continue;
+		}
+
+		pos = tx_skb->data;
+		data_left = len_to_send = 0;
+
+		data_left = tx_skb->len;
+		pad = ESP_BLOCK_SIZE - (data_left % ESP_BLOCK_SIZE);
+		data_left += pad;
+
+
+		do {
+			block_cnt = data_left / ESP_BLOCK_SIZE;
+			len_to_send = data_left;
+			ret = esp_write_block(context, ESP_SLAVE_CMD53_END_ADDR - len_to_send,
+					pos, (len_to_send + 3) & (~3), ACQUIRE_LOCK);
+
+			if (ret) {
+				esp_err("Failed to send data: %d %d %d\n", ret, len_to_send, data_left);
+				break;
+			}
+
+			data_left -= len_to_send;
+			pos += len_to_send;
+		} while (data_left);
+
+		if (ret) {
+			/* drop the packet */
+			dev_kfree_skb(tx_skb);
+			continue;
+		}
+
+		context->tx_buffer_count += buf_needed;
+		context->tx_buffer_count = context->tx_buffer_count % ESP_TX_BUFFER_MAX;
+
+		dev_kfree_skb(tx_skb);
+		tx_skb = NULL;
+	}
+
+	do_exit(0);
+	return 0;
+}
+
+static struct esp_sdio_context *init_sdio_func(struct sdio_func *func, int *sdio_ret)
+{
+	struct esp_sdio_context *context;
+	int ret = 0;
+
+	if (!func)
+		return NULL;
+
+	context = devm_kzalloc(&func->dev, sizeof(*context), GFP_KERNEL);
+	if (!context) {
+		*sdio_ret = -ENOMEM;
+		return NULL;
+	}
+
+	ret = device_property_read_u32(&func->dev, "sdio-clk-mhz",
+					&context->sdio_clk_mhz);
+	if (ret < 0)
+		esp_warn("sdio-clk-mhz was not specified\n");
+
+	context->func = func;
+
+	sdio_claim_host(func);
+
+	/* Enable Function */
+	ret = sdio_enable_func(func);
+	if (ret) {
+		esp_err("sdio_enable_func ret: %d\n", ret);
+		if (sdio_ret)
+			*sdio_ret = ret;
+		sdio_release_host(func);
+
+		return NULL;
+	}
+
+	/* Register IRQ */
+	ret = sdio_claim_irq(func, esp_handle_isr);
+	if (ret) {
+		esp_err("sdio_claim_irq ret: %d\n", ret);
+		sdio_disable_func(func);
+
+		if (sdio_ret)
+			*sdio_ret = ret;
+		sdio_release_host(func);
+
+		return NULL;
+	}
+
+	/* Set private data */
+	sdio_set_drvdata(func, context);
+
+	sdio_release_host(func);
+
+	return context;
+}
+
+static int esp_probe(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	struct esp_sdio_context *context;
+	int ret = 0;
+
+	esp_dbg("Probing ESP-SDIO driver...\n");
+
+	if (func->num != 1) {
+		return -EINVAL;
+	}
+
+	esp_info("ESP network device detected\n");
+
+	context = init_sdio_func(func, &ret);;
+	atomic_set(&tx_pending, 0);
+
+	if (!context) {
+		if (ret)
+			return ret;
+		else
+			return -EINVAL;
+	}
+
+	if (context->sdio_clk_mhz) {
+		struct mmc_host *host = func->card->host;
+		u32 hz = context->sdio_clk_mhz * NUMBER_1M;
+		/* Expansion of mmc_set_clock that isnt exported */
+		if (hz < host->f_min)
+			hz = host->f_min;
+		if (hz > host->f_max)
+			hz = host->f_max;
+		host->ios.clock = hz;
+		host->ops->set_ios(host, &host->ios);
+	}
+
+	ret = init_context(context);
+	if (ret) {
+		deinit_sdio_func(func);
+		return ret;
+	}
+
+	tx_thread = kthread_run(tx_process, context->adapter, "esp_TX");
+
+	if (!tx_thread)
+		esp_err("Failed to create esp_sdio TX thread\n");
+
+	atomic_set(&context->adapter->state, ESP_CONTEXT_RX_READY);
+	generate_slave_intr(context, BIT(ESP_OPEN_DATA_PATH));
+
+
+	esp_dbg("ESP SDIO probe completed\n");
+
+	return 0;
+}
+
+static int esp_suspend(struct device *dev)
+{
+	struct sdio_func	*func;
+	struct esp_sdio_context	*context;
+
+	if (!dev) {
+		esp_info("Failed to inform ESP that host is suspending\n");
+		return -1;
+	}
+
+	func = dev_to_sdio_func(dev);
+
+	esp_info("----> Host Suspend\n");
+	msleep(1000);
+
+	context = sdio_get_drvdata(func);
+
+	if (!context) {
+		esp_info("Failed to inform ESP that host is suspending\n");
+		return -1;
+	}
+
+	host_sleep = 1;
+
+	generate_slave_intr(context, BIT(ESP_POWER_SAVE_ON));
+	msleep(10);
+
+	sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+#if 0
+	/* Enale OOB IRQ and host wake up */
+	enable_irq(SDIO_OOB_IRQ);
+	enable_irq_wake(SDIO_OOB_IRQ);
+#endif
+	return 0;
+}
+
+static int esp_resume(struct device *dev)
+{
+	struct sdio_func	*func;
+	struct esp_sdio_context *context;
+
+	if (!dev) {
+		esp_info("Failed to inform ESP that host is awake\n");
+		return -1;
+	}
+
+	func = dev_to_sdio_func(dev);
+
+	esp_info("-----> Host Awake\n");
+#if 0
+	/* Host woke up.. Disable OOB IRQ */
+	disable_irq_wake(SDIO_OOB_IRQ);
+	disable_irq(SDIO_OOB_IRQ);
+#endif
+
+
+	context = sdio_get_drvdata(func);
+
+	if (!context) {
+		esp_info("Failed to inform ESP that host is awake\n");
+		return -1;
+	}
+
+	/*     generate_slave_intr(context, BIT(ESP_RESET));*/
+	get_firmware_data(context);
+	msleep(100);
+	generate_slave_intr(context, BIT(ESP_POWER_SAVE_OFF));
+	host_sleep = 0;
+	return 0;
+}
+
+static const struct dev_pm_ops esp_pm_ops = {
+	.suspend = esp_suspend,
+	.resume = esp_resume,
+};
+
+static const struct sdio_device_id esp_sdio_ids[] = {
+	{ SDIO_DEVICE(ESP_VENDOR_ID_1, ESP_DEVICE_ID_ESP32_1) },
+	{ SDIO_DEVICE(ESP_VENDOR_ID_1, ESP_DEVICE_ID_ESP32_2) },
+	{ SDIO_DEVICE(ESP_VENDOR_ID_2, ESP_DEVICE_ID_ESP32C6_1) },
+	{ SDIO_DEVICE(ESP_VENDOR_ID_2, ESP_DEVICE_ID_ESP32C6_2) },
+	{}
+};
+MODULE_DEVICE_TABLE(sdio, esp_sdio_ids);
+
+static const struct of_device_id esp_sdio_of_match[] = {
+	{ .compatible = "espressif,esp32-sdio", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, esp_sdio_of_match);
+
+/* SDIO driver structure to be registered with kernel */
+static struct sdio_driver esp_sdio_driver = {
+	.drv = {
+		.name = "esp32_sdio",
+		.pm = &esp_pm_ops,
+		.of_match_table = of_match_ptr(esp_sdio_of_match),
+	},
+	.name	  = "esp32_sdio",
+	.id_table = esp_sdio_ids,
+	.probe	  = esp_probe,
+	.remove	  = esp_remove,
+};
+
+int esp_init_interface_layer(struct esp_adapter *adapter)
+{
+	int ret;
+
+	if (!adapter)
+		return -EINVAL;
+
+	adapter->if_ops = &if_ops;
+	adapter->if_type = ESP_IF_TYPE_SDIO;
+
+	ret = sdio_register_driver(&esp_sdio_driver);
+	if (ret < 0) {
+		esp_err("Unable to register SDIO driver: ret=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int esp_validate_chipset(struct esp_adapter *adapter, u8 chipset)
+{
+	int ret = -1;
+
+	switch(chipset) {
+	case ESP_FIRMWARE_CHIP_ESP32:
+	case ESP_FIRMWARE_CHIP_ESP32C6:
+		adapter->chipset = chipset;
+		esp_info("Chipset=%s ID=%02x detected over SDIO\n", esp_chipname_from_id(chipset), chipset);
+		ret = 0;
+		break;
+	case ESP_FIRMWARE_CHIP_ESP32S2:
+	case ESP_FIRMWARE_CHIP_ESP32S3:
+	case ESP_FIRMWARE_CHIP_ESP32C2:
+	case ESP_FIRMWARE_CHIP_ESP32C3:
+		esp_err("Chipset=%s ID=%02x not supported for SDIO\n", esp_chipname_from_id(chipset), chipset);
+		adapter->chipset = ESP_FIRMWARE_CHIP_UNRECOGNIZED;
+		break;
+	default:
+		esp_err("Unrecognized Chipset ID=%02x\n", chipset);
+		adapter->chipset = ESP_FIRMWARE_CHIP_UNRECOGNIZED;
+		break;
+	}
+
+	return ret;
+}
+
+int esp_adjust_spi_clock(struct esp_adapter *adapter, u8 spi_clk_mhz)
+{
+	/* SPI bus specific call, silently discard */
+	return 0;
+}
+
+void esp_deinit_interface_layer(void)
+{
+	sdio_unregister_driver(&esp_sdio_driver);
+}
+
+static int __init esp_sdio_init(void)
+{
+	return esp_init();
+}
+
+static void __exit esp_sdio_exit(void)
+{
+	esp_exit();
+}
+
+module_init(esp_sdio_init);
+module_exit(esp_sdio_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Amey Inamdar <amey.inamdar@espressif.com>");
+MODULE_AUTHOR("Mangesh Malusare <mangesh.malusare@espressif.com>");
+MODULE_AUTHOR("Yogesh Mantri <yogesh.mantri@espressif.com>");
+MODULE_AUTHOR("Kapil Gupta <kapil.gupta@espressif.com>");
+MODULE_AUTHOR("Sergey Suloev <ssuloev@orpaltech.ru>");
+MODULE_VERSION(RELEASE_VERSION);
+MODULE_DESCRIPTION("SDIO Driver for ESP-Hosted solution");
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c
new file mode 100644
index 0000000..889ee8f
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#include "utils.h"
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include "esp_sdio_api.h"
+
+static int esp_read_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		esp_err("Invalid or incomplete arguments!\n");
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	*data = sdio_readb(func, reg, &ret);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_write_byte(struct esp_sdio_context *context, u32 reg, u8 data, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func) {
+		esp_err("Invalid or incomplete arguments!\n");
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	sdio_writeb(func, data, reg, &ret);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_read_multi_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		esp_err("Invalid or incomplete arguments!\n");
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	ret = sdio_memcpy_fromio(func, data, reg, size);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_write_multi_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		esp_err("Invalid or incomplete arguments!\n");
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	ret = sdio_memcpy_toio(func, reg, data, size);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+int esp_read_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	/* Need to apply address mask when reading/writing slave registers */
+	reg &= ESP_ADDRESS_MASK;
+
+	if (size <= 1) {
+		return esp_read_byte(context, reg, data, is_lock_needed);
+	} else {
+		return esp_read_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_read_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	if (size <= 1) {
+		return esp_read_byte(context, reg, data, is_lock_needed);
+	} else {
+		return esp_read_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_write_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	/* Need to apply address mask when reading/writing slave registers */
+	reg &= ESP_ADDRESS_MASK;
+
+	if (size <= 1) {
+		return esp_write_byte(context, reg, *data, is_lock_needed);
+	} else {
+		return esp_write_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_write_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	if (size <= 1) {
+		return esp_write_byte(context, reg, *data, is_lock_needed);
+	} else {
+		return esp_write_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h
new file mode 100644
index 0000000..a078924
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef _ESP_SDIO_API_H_
+#define _ESP_SDIO_API_H_
+#include "esp_sdio_decl.h"
+
+int esp_read_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_read_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_write_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_write_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h
new file mode 100644
index 0000000..5794595
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#ifndef _ESP_DECL_H_
+#define _ESP_DECL_H_
+
+#include "esp.h"
+
+/* Interrupt Status */
+#define ESP_SLAVE_BIT0_INT             BIT(0)
+#define ESP_SLAVE_BIT1_INT             BIT(1)
+#define ESP_SLAVE_BIT2_INT             BIT(2)
+#define ESP_SLAVE_BIT3_INT             BIT(3)
+#define ESP_SLAVE_BIT4_INT             BIT(4)
+#define ESP_SLAVE_BIT5_INT             BIT(5)
+#define ESP_SLAVE_BIT6_INT             BIT(6)
+#define ESP_SLAVE_BIT7_INT             BIT(7)
+#define ESP_SLAVE_RX_UNDERFLOW_INT     BIT(16)
+#define ESP_SLAVE_TX_OVERFLOW_INT      BIT(17)
+#define ESP_SLAVE_RX_NEW_PACKET_INT    BIT(23)
+
+
+#define ESP_SLAVE_CMD53_END_ADDR       0x1F800
+#define ESP_SLAVE_LEN_MASK             0xFFFFF
+#define ESP_BLOCK_SIZE                 512
+#define ESP_RX_BYTE_MAX                0x100000
+#define ESP_RX_BUFFER_SIZE             2048
+
+#define ESP_TX_BUFFER_MASK             0xFFF
+#define ESP_TX_BUFFER_MAX              0x1000
+#define ESP_MAX_BUF_CNT                10
+
+#define ESP_SLAVE_SLCHOST_BASE         0x3FF55000
+
+#define ESP_SLAVE_SCRATCH_REG_7        (ESP_SLAVE_SLCHOST_BASE + 0x8C)
+/* SLAVE registers */
+/* Interrupt Registers */
+#define ESP_SLAVE_INT_RAW_REG          (ESP_SLAVE_SLCHOST_BASE + 0x50)
+#define ESP_SLAVE_INT_ST_REG           (ESP_SLAVE_SLCHOST_BASE + 0x58)
+#define ESP_SLAVE_INT_CLR_REG          (ESP_SLAVE_SLCHOST_BASE + 0xD4)
+
+/* Data path registers*/
+#define ESP_SLAVE_PACKET_LEN_REG       (ESP_SLAVE_SLCHOST_BASE + 0x60)
+#define ESP_SLAVE_TOKEN_RDATA          (ESP_SLAVE_SLCHOST_BASE + 0x44)
+
+/* Scratch registers*/
+#define ESP_SLAVE_SCRATCH_REG_0        (ESP_SLAVE_SLCHOST_BASE + 0x6C)
+#define ESP_SLAVE_SCRATCH_REG_1        (ESP_SLAVE_SLCHOST_BASE + 0x70)
+#define ESP_SLAVE_SCRATCH_REG_2        (ESP_SLAVE_SLCHOST_BASE + 0x74)
+#define ESP_SLAVE_SCRATCH_REG_3        (ESP_SLAVE_SLCHOST_BASE + 0x78)
+#define ESP_SLAVE_SCRATCH_REG_4        (ESP_SLAVE_SLCHOST_BASE + 0x7C)
+#define ESP_SLAVE_SCRATCH_REG_6        (ESP_SLAVE_SLCHOST_BASE + 0x88)
+#define ESP_SLAVE_SCRATCH_REG_8        (ESP_SLAVE_SLCHOST_BASE + 0x9C)
+#define ESP_SLAVE_SCRATCH_REG_9        (ESP_SLAVE_SLCHOST_BASE + 0xA0)
+#define ESP_SLAVE_SCRATCH_REG_10       (ESP_SLAVE_SLCHOST_BASE + 0xA4)
+#define ESP_SLAVE_SCRATCH_REG_11       (ESP_SLAVE_SLCHOST_BASE + 0xA8)
+#define ESP_SLAVE_SCRATCH_REG_12       (ESP_SLAVE_SLCHOST_BASE + 0xAC)
+#define ESP_SLAVE_SCRATCH_REG_13       (ESP_SLAVE_SLCHOST_BASE + 0xB0)
+#define ESP_SLAVE_SCRATCH_REG_14       (ESP_SLAVE_SLCHOST_BASE + 0xB4)
+#define ESP_SLAVE_SCRATCH_REG_15       (ESP_SLAVE_SLCHOST_BASE + 0xB8)
+
+#define ESP_ADDRESS_MASK              0x3FF
+
+#define ESP_VENDOR_ID_1             0x6666
+#define ESP_DEVICE_ID_ESP32_1       0x2222
+#define ESP_DEVICE_ID_ESP32_2       0x3333
+
+#define ESP_VENDOR_ID_2             0x0092
+#define ESP_DEVICE_ID_ESP32C6_1     0x6666
+#define ESP_DEVICE_ID_ESP32C6_2     0x7777
+
+struct esp_sdio_context {
+	struct esp_adapter     *adapter;
+	struct sdio_func       *func;
+	struct sk_buff_head    tx_q[MAX_PRIORITY_QUEUES];
+	u32                    rx_byte_count;
+	u32                    tx_buffer_count;
+	u32			sdio_clk_mhz;
+};
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c
new file mode 100644
index 0000000..52b59d7
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c
@@ -0,0 +1,639 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/spi/spi.h>
+#include "esp_api.h"
+#include "esp_bt_api.h"
+#include "esp_cfg80211.h"
+#include "esp_fw_version.h"
+#include "esp_if.h"
+#include "esp_kernel_port.h"
+#include "esp_spi.h"
+#include "esp_stats.h"
+#include "esp_utils.h"
+#include "utils.h"
+#include "main.h"
+
+#define TX_MAX_PENDING_COUNT    100
+#define TX_RESUME_THRESHOLD     (TX_MAX_PENDING_COUNT/5)
+
+#ifdef CONFIG_ESP_HOSTED_NG_NO_CS_CHANGE
+#define ALLOW_CS_CHANGE	0
+#else
+#define ALLOW_CS_CHANGE	1
+#endif
+
+#ifdef CONFIG_ESP_HOSTED_NG_NO_ADJUST_SPI_CLOCK
+#define ALLOW_ADJUST_SPI_CLOCK	0
+#else
+#define ALLOW_ADJUST_SPI_CLOCK	1
+#endif
+
+extern u32 raw_tp_mode;
+static struct sk_buff *read_packet(struct esp_adapter *adapter);
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb);
+static void adjust_spi_clock(struct esp_spi_context *spi_ctx, u8 spi_clk_mhz);
+
+volatile u8 data_path;
+volatile u8 host_sleep;
+static atomic_t tx_pending;
+
+static struct esp_if_ops if_ops = {
+	.read		= read_packet,
+	.write		= write_packet,
+};
+
+static DEFINE_MUTEX(spi_lock);
+
+static void open_data_path(void)
+{
+	atomic_set(&tx_pending, 0);
+	msleep(200);
+	data_path = OPEN_DATAPATH;
+}
+
+static void close_data_path(void)
+{
+	data_path = CLOSE_DATAPATH;
+	msleep(200);
+}
+
+static irqreturn_t spi_data_ready_interrupt_handler(int irq, void *dev_id)
+{
+	struct esp_spi_context *spi_ctx = dev_id;
+
+	/* ESP peripheral has queued buffer for transmission */
+	if (spi_ctx->spi_workqueue)
+		queue_work(spi_ctx->spi_workqueue, &spi_ctx->spi_work);
+
+	return IRQ_HANDLED;
+ }
+
+static irqreturn_t spi_interrupt_handler(int irq, void *dev_id)
+{
+	struct esp_spi_context *spi_ctx = dev_id;
+
+	/* ESP peripheral is ready for next SPI transaction */
+	if (spi_ctx->spi_workqueue)
+		queue_work(spi_ctx->spi_workqueue, &spi_ctx->spi_work);
+
+	return IRQ_HANDLED;
+}
+
+static struct sk_buff *read_packet(struct esp_adapter *adapter)
+{
+	struct esp_spi_context *context;
+	struct sk_buff *skb = NULL;
+
+	if (!data_path) {
+		return NULL;
+	}
+
+	if (!adapter || !adapter->if_context) {
+		esp_err("Invalid args\n");
+		return NULL;
+	}
+
+	context = adapter->if_context;
+
+	if (context->spi) {
+		skb = skb_dequeue(&(context->rx_q[PRIO_Q_HIGH]));
+		if (!skb)
+			skb = skb_dequeue(&(context->rx_q[PRIO_Q_MID]));
+		if (!skb)
+			skb = skb_dequeue(&(context->rx_q[PRIO_Q_LOW]));
+	} else {
+		esp_err("Invalid args\n");
+		return NULL;
+	}
+
+	return skb;
+}
+
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	u32 max_pkt_size = SPI_BUF_SIZE - sizeof(struct esp_payload_header);
+	struct esp_payload_header *payload_header = (struct esp_payload_header *) skb->data;
+	struct esp_skb_cb *cb = NULL;
+	struct esp_spi_context *context;
+
+	if (!adapter || !adapter->if_context || !skb || !skb->data || !skb->len) {
+		esp_err("Invalid args\n");
+		if (skb) {
+			dev_kfree_skb(skb);
+			skb = NULL;
+		}
+		return -EINVAL;
+	}
+
+	context = adapter->if_context;
+
+	if (skb->len > max_pkt_size) {
+		esp_err("Drop pkt of len[%u] > max spi transport len[%u]\n",
+				skb->len, max_pkt_size);
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+
+	if (!data_path) {
+		esp_info("%u datapath closed\n", __LINE__);
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+
+	cb = (struct esp_skb_cb *)skb->cb;
+	if (cb && cb->priv && (atomic_read(&tx_pending) >= TX_MAX_PENDING_COUNT)) {
+		esp_tx_pause(cb->priv);
+		dev_kfree_skb(skb);
+		skb = NULL;
+		esp_verbose("TX Pause busy");
+		if (context->spi_workqueue)
+			queue_work(context->spi_workqueue, &context->spi_work);
+		return -EBUSY;
+	}
+
+	/* Enqueue SKB in tx_q */
+	if (payload_header->if_type == ESP_INTERNAL_IF) {
+		skb_queue_tail(&context->tx_q[PRIO_Q_HIGH], skb);
+	} else if (payload_header->if_type == ESP_HCI_IF) {
+		skb_queue_tail(&context->tx_q[PRIO_Q_MID], skb);
+	} else {
+		skb_queue_tail(&context->tx_q[PRIO_Q_LOW], skb);
+		atomic_inc(&tx_pending);
+	}
+
+	if (context->spi_workqueue)
+		queue_work(context->spi_workqueue, &context->spi_work);
+
+	return 0;
+}
+
+int esp_validate_chipset(struct esp_adapter *adapter, u8 chipset)
+{
+	int ret = 0;
+
+	switch(chipset) {
+	case ESP_FIRMWARE_CHIP_ESP32:
+	case ESP_FIRMWARE_CHIP_ESP32S2:
+	case ESP_FIRMWARE_CHIP_ESP32S3:
+	case ESP_FIRMWARE_CHIP_ESP32C2:
+	case ESP_FIRMWARE_CHIP_ESP32C3:
+	case ESP_FIRMWARE_CHIP_ESP32C6:
+	case ESP_FIRMWARE_CHIP_ESP32C5:
+		adapter->chipset = chipset;
+		esp_info("Chipset=%s ID=%02x detected over SPI\n", esp_chipname_from_id(chipset), chipset);
+		break;
+	default:
+		esp_err("Unrecognized chipset ID=%02x\n", chipset);
+		adapter->chipset = ESP_FIRMWARE_CHIP_UNRECOGNIZED;
+		break;
+	}
+
+	return ret;
+}
+
+int esp_deinit_module(struct esp_adapter *adapter)
+{
+	/* Second & onward bootup cleanup:
+	 *
+	 * SPI is software and not a hardware based module.
+	 * When bootup event is received, we should discard all prior commands,
+	 * old messages pending at network and re-initialize everything.
+	 */
+	struct esp_spi_context *spi_ctx = adapter->if_context;
+	uint8_t prio_q_idx, iface_idx;
+
+	for (prio_q_idx = 0; prio_q_idx < MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_purge(&spi_ctx->tx_q[prio_q_idx]);
+	}
+
+	for (iface_idx = 0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+		struct esp_wifi_device *priv = adapter->priv[iface_idx];
+		esp_mark_scan_done_and_disconnect(priv, true);
+	}
+
+	esp_remove_card(adapter);
+
+	for (prio_q_idx = 0; prio_q_idx < MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_head_init(&spi_ctx->tx_q[prio_q_idx]);
+	}
+
+	return 0;
+}
+
+static int process_rx_buf(struct esp_spi_context *spi_ctx, struct sk_buff *skb)
+{
+	struct esp_payload_header *header;
+	u16 len = 0;
+	u16 offset = 0;
+
+	if (!skb)
+		return -EINVAL;
+
+	esp_verbose("SPI RX buf: IF type = %d\n", header->if_type);
+	esp_hex_dump_verbose("SPI RX buf: ", skb->data , min(skb->len, 32));
+
+	header = (struct esp_payload_header *) skb->data;
+
+	if (header->if_type >= ESP_MAX_IF) {
+		return -EINVAL;
+	}
+
+	offset = le16_to_cpu(header->offset);
+
+	/* Validate received SKB. Check len and offset fields */
+	if (offset != sizeof(struct esp_payload_header)) {
+		esp_info("offset_rcv[%d] != exp[%d], drop\n",
+				(int)offset, (int)sizeof(struct esp_payload_header));
+		return -EINVAL;
+	}
+
+	len = le16_to_cpu(header->len);
+	if (!len) {
+		return -EINVAL;
+	}
+
+	len += sizeof(struct esp_payload_header);
+
+	if (len > SPI_BUF_SIZE) {
+		return -EINVAL;
+	}
+
+	/* Trim SKB to actual size */
+	skb_trim(skb, len);
+
+
+	if (!data_path) {
+		esp_verbose("%u datapath closed\n", __LINE__);
+		return -EPERM;
+	}
+
+	/* enqueue skb for read_packet to pick it */
+	if (header->if_type == ESP_INTERNAL_IF)
+		skb_queue_tail(&spi_ctx->rx_q[PRIO_Q_HIGH], skb);
+	else if (header->if_type == ESP_HCI_IF)
+		skb_queue_tail(&spi_ctx->rx_q[PRIO_Q_MID], skb);
+	else
+		skb_queue_tail(&spi_ctx->rx_q[PRIO_Q_LOW], skb);
+
+	/* indicate reception of new packet */
+	esp_process_new_packet_intr(spi_ctx->adapter);
+
+	return 0;
+}
+
+static void esp_spi_work(struct work_struct *work)
+{
+	struct esp_spi_context *spi_ctx;
+	struct spi_transfer trans;
+	struct sk_buff *tx_skb = NULL, *rx_skb = NULL;
+	struct esp_skb_cb *cb = NULL;
+	u8 *rx_buf = NULL;
+	int ret = 0;
+	volatile int trans_ready, rx_pending;
+
+	mutex_lock(&spi_lock);
+
+	spi_ctx = container_of(work, struct esp_spi_context, spi_work);
+
+	trans_ready = gpiod_get_value(spi_ctx->handshake);
+	rx_pending = gpiod_get_value(spi_ctx->data_ready);
+
+	esp_verbose("SPI work: handshake %d, data_ready %d, data_path %d\n",
+		trans_ready, rx_pending, data_path);
+
+	if (trans_ready) {
+		if (data_path) {
+			tx_skb = skb_dequeue(&spi_ctx->tx_q[PRIO_Q_HIGH]);
+			if (!tx_skb)
+				tx_skb = skb_dequeue(&spi_ctx->tx_q[PRIO_Q_MID]);
+			if (!tx_skb)
+				tx_skb = skb_dequeue(&spi_ctx->tx_q[PRIO_Q_LOW]);
+			if (tx_skb) {
+				if (atomic_read(&tx_pending))
+					atomic_dec(&tx_pending);
+
+				/* resume network tx queue if bearable load */
+				cb = (struct esp_skb_cb *)tx_skb->cb;
+				if (cb && cb->priv && atomic_read(&tx_pending) < TX_RESUME_THRESHOLD) {
+					esp_tx_resume(cb->priv);
+#if TEST_RAW_TP
+					if (raw_tp_mode != 0) {
+						esp_raw_tp_queue_resume();
+					}
+#endif
+				}
+			}
+		}
+
+		if (rx_pending || tx_skb) {
+			memset(&trans, 0, sizeof(trans));
+			trans.speed_hz = spi_ctx->spi_clk_mhz * NUMBER_1M;
+
+			/* Setup and execute SPI transaction
+			 *	Tx_buf: Check if tx_q has valid buffer for transmission,
+			 *		else keep it blank
+			 *
+			 *	Rx_buf: Allocate memory for incoming data. This will be freed
+			 *		immediately if received buffer is invalid.
+			 *		If it is a valid buffer, upper layer will free it.
+			 * */
+
+			/* Configure TX buffer if available */
+
+			if (tx_skb) {
+				trans.tx_buf = tx_skb->data;
+				esp_hex_dump_verbose("tx: ", trans.tx_buf, 32);
+			} else {
+				tx_skb = esp_alloc_skb(SPI_BUF_SIZE);
+				trans.tx_buf = skb_put(tx_skb, SPI_BUF_SIZE);
+				memset((void *)trans.tx_buf, 0, SPI_BUF_SIZE);
+			}
+
+			/* Configure RX buffer */
+			rx_skb = esp_alloc_skb(SPI_BUF_SIZE);
+			rx_buf = skb_put(rx_skb, SPI_BUF_SIZE);
+
+			memset(rx_buf, 0, SPI_BUF_SIZE);
+
+			trans.rx_buf = rx_buf;
+			trans.len = SPI_BUF_SIZE;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)) && ALLOW_CS_CHANGE
+			if (spi_ctx->adapter->chipset == ESP_FIRMWARE_CHIP_ESP32) {
+				trans.cs_change = 1;
+			}
+#endif
+
+			ret = spi_sync_transfer(spi_ctx->spi, &trans, 1);
+			if (ret) {
+				esp_err("SPI Transaction failed: %d", ret);
+				dev_kfree_skb(rx_skb);
+				dev_kfree_skb(tx_skb);
+			} else {
+
+				/* Free rx_skb if received data is not valid */
+				if (process_rx_buf(spi_ctx, rx_skb)) {
+					dev_kfree_skb(rx_skb);
+				}
+
+				if (tx_skb)
+					dev_kfree_skb(tx_skb);
+			}
+		}
+	}
+
+	mutex_unlock(&spi_lock);
+}
+
+static void adjust_spi_clock(struct esp_spi_context *spi_ctx, u8 spi_clk_mhz)
+{
+#if ALLOW_ADJUST_SPI_CLOCK
+	if ((spi_clk_mhz) && (spi_clk_mhz != spi_ctx->spi_clk_mhz)) {
+		esp_info("ESP Reconfigure SPI CLK to %u MHz\n", spi_clk_mhz);
+		spi_ctx->spi_clk_mhz = spi_clk_mhz;
+		spi_ctx->spi->max_speed_hz = spi_clk_mhz * NUMBER_1M;
+	}
+#endif
+}
+
+static void esp_hw_reset(struct esp_spi_context *spi_ctx)
+{
+	// Set HOST's resetpin to LOW
+	gpiod_set_value(spi_ctx->reset, 0);
+	usleep_range(2000,4000);
+
+	// Set HOST's resetpin to HIGH
+	gpiod_set_value(spi_ctx->reset, 1);
+	// Wait for ESP to start
+	msleep(200);
+}
+
+static int esp_spi_probe(struct spi_device *spi)
+{
+	int ret, irq;
+	uint8_t prio_q_idx = 0;
+	struct device *dev = &spi->dev;
+	struct esp_spi_context *spi_ctx;
+
+	esp_dbg("Probing ESP SPI-driver...\n");
+
+	spi_ctx = devm_kzalloc(dev, sizeof(*spi_ctx), GFP_KERNEL);
+	if (!spi_ctx)
+		return -ENOMEM;
+	spi_set_drvdata(spi, spi_ctx);
+
+	spi_ctx->spi = spi;
+	spi_ctx->spi_clk_mhz = spi->max_speed_hz / NUMBER_1M;
+	spi_ctx->adapter = esp_get_adapter();
+	spi_ctx->adapter->if_context = spi_ctx;
+	spi_ctx->adapter->dev = dev;
+
+	spi_ctx->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(spi_ctx->reset)) {
+		ret = PTR_ERR(spi_ctx->reset);
+		if (ret != -EPROBE_DEFER)
+			esp_err("Couldn't get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	spi_ctx->spi_workqueue = create_workqueue("ESP_SPI_WORK_QUEUE");
+	if (!spi_ctx->spi_workqueue) {
+		esp_err("SPI workqueue failed to create\n");
+		return -EFAULT;
+	}
+	INIT_WORK(&spi_ctx->spi_work, esp_spi_work);
+
+	for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_head_init(&spi_ctx->tx_q[prio_q_idx]);
+		skb_queue_head_init(&spi_ctx->rx_q[prio_q_idx]);
+	}
+
+	spi_ctx->handshake = devm_gpiod_get(dev, "handshake", GPIOD_IN);
+	if (IS_ERR(spi_ctx->handshake)) {
+		ret = PTR_ERR(spi_ctx->handshake);
+		if (ret != -EPROBE_DEFER)
+			esp_err("Couldn't get handshake GPIO: %d\n", ret);
+		return ret;
+	}
+
+	spi_ctx->data_ready = devm_gpiod_get(dev, "dataready", GPIOD_IN);
+	if (IS_ERR(spi_ctx->data_ready)) {
+		ret = PTR_ERR(spi_ctx->data_ready);
+		if (ret != -EPROBE_DEFER)
+			esp_err("Couldn't get data-ready GPIO: %d\n", ret);
+		return ret;
+	}
+
+	irq = gpiod_to_irq(spi_ctx->handshake);
+	if (irq < 0) {
+		esp_err("Can't get IRQ for Handshake GPIO\n");
+		return -EINVAL;
+	}
+	ret = devm_request_irq(dev, irq, spi_interrupt_handler,
+				IRQF_SHARED | IRQF_TRIGGER_RISING,
+				"ESP_SPI",
+				spi_ctx);
+	if (ret < 0) {
+		esp_err("Failed to request IRQ for SPI: %d\n", ret);
+		return ret;
+	}
+
+	irq = gpiod_to_irq(spi_ctx->data_ready);
+	if (irq < 0) {
+		esp_err("Can't get IRQ for Data-Ready GPIO\n");
+		return -EINVAL;
+	}
+	ret = devm_request_irq(dev, irq, spi_data_ready_interrupt_handler,
+				IRQF_SHARED | IRQF_TRIGGER_RISING,
+				"ESP_SPI_DATA_READY",
+				spi_ctx);
+	if (ret < 0) {
+		esp_err("Failed to request IRQ for Data-Ready GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = device_property_read_u32(dev, "raw-tp-mode", &raw_tp_mode);
+	if (ret < 0)
+		esp_warn("raw-tp-mode was not specified\n");
+
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		esp_err("spi_setup() failed: %d\n", ret);
+		return ret;
+	}
+
+	esp_info("ESP32 peripheral is registered to SPI bus [%d], "
+		"chip select [%d], SPI Clock [%d], SPI mode [0x%02x]\n",
+		spi->controller->bus_num, spi->chip_select[0],
+		spi_ctx->spi_clk_mhz, spi->mode);
+
+	esp_hw_reset(spi_ctx);
+
+	open_data_path();
+
+	atomic_set(&spi_ctx->adapter->state, ESP_CONTEXT_READY);
+
+	esp_dbg("ESP SPI-driver probe success\n");
+	return 0;
+}
+
+static void esp_spi_remove(struct spi_device *spi)
+{
+	struct esp_spi_context *spi_ctx = spi_get_drvdata(spi);
+	uint8_t prio_q_idx = 0;
+
+	if (spi_ctx->adapter)
+		atomic_set(&spi_ctx->adapter->state, ESP_CONTEXT_DISABLED);
+
+	disable_irq(gpiod_to_irq(spi_ctx->handshake));
+	disable_irq(gpiod_to_irq(spi_ctx->data_ready));
+
+	close_data_path();
+
+	for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_purge(&spi_ctx->tx_q[prio_q_idx]);
+		skb_queue_purge(&spi_ctx->rx_q[prio_q_idx]);
+	}
+
+	if (spi_ctx->spi_workqueue) {
+		flush_workqueue(spi_ctx->spi_workqueue);
+		destroy_workqueue(spi_ctx->spi_workqueue);
+		spi_ctx->spi_workqueue = NULL;
+	}
+
+	esp_remove_card(spi_ctx->adapter);
+
+	if (spi_ctx->adapter && spi_ctx->adapter->hcidev)
+		esp_deinit_bt(spi_ctx->adapter);
+}
+
+static const struct spi_device_id esp_spi_ids[] = {
+	{ "esp32-spi", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, esp_spi_ids);
+
+static const struct of_device_id esp_dt_of_match[] = {
+	{ .compatible = "espressif,esp32-spi" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, esp_dt_of_match);
+
+static struct spi_driver esp_spi_driver = {
+	.driver = {
+		.name = "esp32_spi",
+		.of_match_table = of_match_ptr(esp_dt_of_match),
+	},
+	.id_table = esp_spi_ids,
+	.probe = esp_spi_probe,
+	.remove = esp_spi_remove,
+};
+
+int generate_slave_intr(void *context, u8 data)
+{
+	return 0;
+}
+
+int esp_adjust_spi_clock(struct esp_adapter *adapter, u8 spi_clk_mhz)
+{
+	struct esp_spi_context *spi_ctx = adapter->if_context;
+
+	adjust_spi_clock(spi_ctx, spi_clk_mhz);
+
+	return 0;
+}
+
+int esp_init_interface_layer(struct esp_adapter *adapter)
+{
+	int ret;
+
+	if (!adapter)
+		return -EINVAL;
+
+	adapter->if_ops = &if_ops;
+	adapter->if_type = ESP_IF_TYPE_SPI;
+
+	ret = spi_register_driver(&esp_spi_driver);
+	if (ret < 0) {
+		esp_err("Unable to register SPI driver: ret=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+void esp_deinit_interface_layer(void)
+{
+	spi_unregister_driver(&esp_spi_driver);
+}
+
+static int __init esp_spi_init(void)
+{
+	return esp_init();
+}
+
+static void __exit esp_spi_exit(void)
+{
+	esp_exit();
+}
+
+module_init(esp_spi_init);
+module_exit(esp_spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Amey Inamdar <amey.inamdar@espressif.com>");
+MODULE_AUTHOR("Mangesh Malusare <mangesh.malusare@espressif.com>");
+MODULE_AUTHOR("Yogesh Mantri <yogesh.mantri@espressif.com>");
+MODULE_AUTHOR("Kapil Gupta <kapil.gupta@espressif.com>");
+MODULE_AUTHOR("Sergey Suloev <ssuloev@orpaltech.ru>");
+MODULE_VERSION(RELEASE_VERSION);
+MODULE_DESCRIPTION("SPI Driver for ESP-Hosted solution");
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h
new file mode 100644
index 0000000..819c7fd
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD
+ *
+ */
+
+#ifndef _ESP_SPI_H_
+#define _ESP_SPI_H_
+
+#include "esp.h"
+
+#define SPI_BUF_SIZE		1600
+
+struct esp_spi_context {
+	struct esp_adapter	*adapter;
+	struct spi_device	*spi;
+	struct gpio_desc	*reset;
+	struct gpio_desc	*handshake;
+	struct gpio_desc	*data_ready;
+	struct sk_buff_head	tx_q[MAX_PRIORITY_QUEUES];
+	struct sk_buff_head	rx_q[MAX_PRIORITY_QUEUES];
+	struct workqueue_struct	*spi_workqueue;
+	struct work_struct	spi_work;
+	uint8_t			spi_clk_mhz;
+	uint8_t			reserved[2];
+};
+
+enum {
+	CLOSE_DATAPATH,
+	OPEN_DATAPATH,
+};
+
+
+#endif
-- 
2.43.0

