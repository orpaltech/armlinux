From ec88e00ad57bef367d27f77ca556c10a95433941 Mon Sep 17 00:00:00 2001
From: ssuloev <ssuloev@orpaltech.com>
Date: Sun, 21 May 2023 00:10:20 +0300
Subject: [PATCH] net/wireless: Add Espressif ESP-Hosted-NG driver

---
 drivers/net/wireless/Kconfig                  |    1 +
 drivers/net/wireless/Makefile                 |    1 +
 drivers/net/wireless/espressif/Kconfig        |   17 +
 drivers/net/wireless/espressif/Makefile       |    2 +
 .../wireless/espressif/esp_hosted_ng/Kconfig  |   35 +
 .../wireless/espressif/esp_hosted_ng/Makefile |   32 +
 .../wireless/espressif/esp_hosted_ng/esp_bt.c |  263 +++
 .../espressif/esp_hosted_ng/esp_cfg80211.c    |  597 +++++++
 .../espressif/esp_hosted_ng/esp_cmd.c         | 1424 +++++++++++++++++
 .../espressif/esp_hosted_ng/esp_main.c        |    1 +
 .../espressif/esp_hosted_ng/esp_stats.c       |  211 +++
 .../espressif/esp_hosted_ng/esp_wpa_utils.c   |   75 +
 .../espressif/esp_hosted_ng/include/adapter.h |  310 ++++
 .../espressif/esp_hosted_ng/include/esp.h     |  174 ++
 .../espressif/esp_hosted_ng/include/esp_api.h |   54 +
 .../esp_hosted_ng/include/esp_bt_api.h        |   48 +
 .../esp_hosted_ng/include/esp_cfg80211.h      |   37 +
 .../espressif/esp_hosted_ng/include/esp_cmd.h |   62 +
 .../espressif/esp_hosted_ng/include/esp_if.h  |   35 +
 .../esp_hosted_ng/include/esp_kernel_port.h   |  244 +++
 .../esp_hosted_ng/include/esp_stats.h         |   44 +
 .../esp_hosted_ng/include/esp_wpa_utils.h     |   53 +
 .../wireless/espressif/esp_hosted_ng/main.c   |  893 +++++++++++
 .../wireless/espressif/esp_hosted_ng/main.h   |   23 +
 .../espressif/esp_hosted_ng/sdio/esp_sdio.c   | 1003 ++++++++++++
 .../esp_hosted_ng/sdio/esp_sdio_api.c         |  160 ++
 .../esp_hosted_ng/sdio/esp_sdio_api.h         |   29 +
 .../esp_hosted_ng/sdio/esp_sdio_decl.h        |  100 ++
 .../espressif/esp_hosted_ng/spi/esp_spi.c     |  712 +++++++++
 .../espressif/esp_hosted_ng/spi/esp_spi.h     |   50 +
 30 files changed, 6690 insertions(+)
 create mode 100644 drivers/net/wireless/espressif/Kconfig
 create mode 100644 drivers/net/wireless/espressif/Makefile
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/Kconfig
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/Makefile
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_main.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/esp_wpa_utils.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/include/esp_wpa_utils.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/main.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/main.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c
 create mode 100644 drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h

diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index cb1c150..764fe6e 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -37,6 +37,7 @@ source "drivers/net/wireless/st/Kconfig"
 source "drivers/net/wireless/ti/Kconfig"
 source "drivers/net/wireless/zydas/Kconfig"
 source "drivers/net/wireless/quantenna/Kconfig"
+source "drivers/net/wireless/espressif/Kconfig"
 
 config PCMCIA_RAYCS
 	tristate "Aviator/Raytheon 2.4GHz wireless support"
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index a61cf6c..e22e7fa 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_WLAN_VENDOR_SILABS) += silabs/
 obj-$(CONFIG_WLAN_VENDOR_ST) += st/
 obj-$(CONFIG_WLAN_VENDOR_TI) += ti/
 obj-$(CONFIG_WLAN_VENDOR_ZYDAS) += zydas/
+obj-$(CONFIG_WLAN_VENDOR_ESPRESSIF) += espressif/
 
 # 16-bit wireless PCMCIA client drivers
 obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
diff --git a/drivers/net/wireless/espressif/Kconfig b/drivers/net/wireless/espressif/Kconfig
new file mode 100644
index 0000000..b6342a5
--- /dev/null
+++ b/drivers/net/wireless/espressif/Kconfig
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config WLAN_VENDOR_ESPRESSIF
+	bool "Espressif ESP-series wireless devices"
+	default y
+	help
+	  If you have a wireless card belonging to this class, say Y.
+
+	  Note that the answer to this question doesn't directly affect the
+	  kernel: saying N will just cause the configurator to skip all the
+	  questions about these cards. If you say Y, you will be asked for
+	  your specific card in the following questions.
+
+if WLAN_VENDOR_ESPRESSIF
+
+source "drivers/net/wireless/espressif/esp_hosted_ng/Kconfig"
+
+endif # WLAN_VENDOR_ESPRESSIF
diff --git a/drivers/net/wireless/espressif/Makefile b/drivers/net/wireless/espressif/Makefile
new file mode 100644
index 0000000..74b7996
--- /dev/null
+++ b/drivers/net/wireless/espressif/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_ESPRESSIF_ESP_HOSTED_NG) += esp_hosted_ng/
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/Kconfig b/drivers/net/wireless/espressif/esp_hosted_ng/Kconfig
new file mode 100644
index 0000000..822492e
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/Kconfig
@@ -0,0 +1,35 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# ESP hosted (New Generation) wireless drivers
+#
+
+config ESPRESSIF_ESP_HOSTED_NG
+	tristate
+	help
+	  The driver allows for using ESP-series SoC or module as a hosted wireless transceiver.
+
+config ESPRESSIF_ESP_HOSTED_NG_SDIO
+	tristate "Espressif ESP-Series hosted (NG) with SDIO"
+	select ESPRESSIF_ESP_HOSTED_NG
+
+config ESPRESSIF_ESP_HOSTED_NG_SPI
+	tristate "Espressif ESP-Series hosted (NG) with SPI"
+	depends on SPI
+	select SPI_MASTER
+	select ESPRESSIF_ESP_HOSTED_NG
+
+config ESP_HOSTED_NG_TEST_RAW_TP
+	bool "-- Raw Throughput testing"
+	depends on ESPRESSIF_ESP_HOSTED_NG
+
+config ESP_HOSTED_NG_NO_ADJUST_SPI_CLOCK
+	bool "-- Disallow ESP adjust SPI clock"
+	depends on ESPRESSIF_ESP_HOSTED_NG_SPI
+
+config ESP_HOSTED_NG_NO_CS_CHANGE
+	bool "-- Disallow CS change"
+	depends on ESPRESSIF_ESP_HOSTED_NG_SPI
+
+config ESP_HOSTED_NG_MONITOR_PROCESS
+	bool "-- Enable Monitoring process"
+	depends on ESPRESSIF_ESP_HOSTED_NG_SDIO
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/Makefile b/drivers/net/wireless/espressif/esp_hosted_ng/Makefile
new file mode 100644
index 0000000..d62d80f
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/Makefile
@@ -0,0 +1,32 @@
+ifneq ($(filter $(CONFIG_ESPRESSIF_ESP_HOSTED_NG),y m),)
+
+mod_name_sdio = esp32_sdio
+mod_name_spi = esp32_spi
+
+ccflags-y += -I$(src)/include -I$(src)
+
+mod_objects = \
+	esp_bt.o \
+	esp_cmd.o \
+	esp_wpa_utils.o \
+	esp_cfg80211.o \
+	esp_stats.o \
+	main.o \
+
+$(mod_name_sdio)-objs := $(mod_objects)
+$(mod_name_spi)-objs := $(mod_objects)
+
+ifneq ($(filter $(CONFIG_ESPRESSIF_ESP_HOSTED_NG_SDIO),y m),)
+	ccflags-y += -I$(src)/sdio
+	$(mod_name_sdio)-objs += sdio/esp_sdio.o sdio/esp_sdio_api.o
+endif
+
+ifneq ($(filter $(CONFIG_ESPRESSIF_ESP_HOSTED_NG_SPI),y m),)
+	ccflags-y += -I$(src)/spi
+	$(mod_name_spi)-objs += spi/esp_spi.o
+endif
+
+obj-$(CONFIG_ESPRESSIF_ESP_HOSTED_NG_SDIO) += $(mod_name_sdio).o
+obj-$(CONFIG_ESPRESSIF_ESP_HOSTED_NG_SPI) += $(mod_name_spi).o
+
+endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c
new file mode 100644
index 0000000..5308821
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_bt.c
@@ -0,0 +1,263 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+#include "esp_bt_api.h"
+#include "esp_api.h"
+#include "esp_kernel_port.h"
+
+#define INVALID_HDEV_BUS (0xff)
+
+void esp_hci_update_tx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len)
+{
+	if (hdev) {
+		if (pkt_type == HCI_COMMAND_PKT) {
+			hdev->stat.cmd_tx++;
+		} else if (pkt_type == HCI_ACLDATA_PKT) {
+			hdev->stat.acl_tx++;
+		} else if (pkt_type == HCI_SCODATA_PKT) {
+			hdev->stat.sco_tx++;
+		}
+
+		hdev->stat.byte_tx += len;
+	}
+}
+
+void esp_hci_update_rx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len)
+{
+	if (hdev) {
+		if (pkt_type == HCI_EVENT_PKT) {
+			hdev->stat.evt_rx++;
+		} else if (pkt_type == HCI_ACLDATA_PKT) {
+			hdev->stat.acl_rx++;
+		} else if (pkt_type == HCI_SCODATA_PKT) {
+			hdev->stat.sco_rx++;
+		}
+
+		hdev->stat.byte_rx += len;
+	}
+}
+
+static int esp_bt_open(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_close(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static int esp_bt_flush(struct hci_dev *hdev)
+{
+	return 0;
+}
+
+static ESP_BT_SEND_FRAME_PROTOTYPE()
+{
+	struct esp_payload_header *hdr;
+	size_t total_len, len = skb->len;
+	int ret = 0;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
+    struct hci_dev * hdev = (struct hci_dev *)(skb->dev);
+#endif
+	struct esp_adapter *adapter = hci_get_drvdata(hdev);
+	struct sk_buff *new_skb;
+	u8 pad_len = 0, realloc_skb = 0;
+	u8 *pos = NULL;
+	u8 pkt_type;
+
+	if (!adapter) {
+		printk(KERN_ERR "%s: invalid args", __func__);
+		return -EINVAL;
+	}
+	//print_hex_dump(KERN_INFO, "bt_tx: ", DUMP_PREFIX_ADDRESS, 16, 1, skb->data, len, 1  );
+
+	/* Create space for payload header */
+	pad_len = sizeof(struct esp_payload_header);
+	total_len = len + sizeof(struct esp_payload_header);
+
+	/* Align buffer len */
+	pad_len += SKB_DATA_ADDR_ALIGNMENT - (total_len % SKB_DATA_ADDR_ALIGNMENT);
+
+	pkt_type = hci_skb_pkt_type(skb);
+
+	if (skb_headroom(skb) < pad_len) {
+		/* Headroom is not sufficient */
+		realloc_skb = 1;
+	}
+
+	if (realloc_skb || !IS_ALIGNED((unsigned long) skb->data, SKB_DATA_ADDR_ALIGNMENT)) {
+		/* Realloc SKB */
+		if (skb_linearize(skb)) {
+			hdev->stat.err_tx++;
+			return -EINVAL;
+		}
+
+		new_skb = esp_alloc_skb(skb->len + pad_len);
+
+		if (!new_skb) {
+			printk(KERN_ERR "%s: Failed to allocate SKB", __func__);
+			hdev->stat.err_tx++;
+			return -ENOMEM;
+		}
+
+		pos = new_skb->data;
+
+		pos += pad_len;
+
+		/* Populate new SKB */
+		skb_copy_from_linear_data(skb, pos, skb->len);
+		skb_put(new_skb, skb->len);
+
+		/* Replace old SKB */
+		dev_kfree_skb_any(skb);
+		skb = new_skb;
+	} else {
+		/* Realloc is not needed, Make space for interface header */
+		skb_push(skb, pad_len);
+	}
+
+	hdr = (struct esp_payload_header *) skb->data;
+
+	memset (hdr, 0, sizeof(struct esp_payload_header));
+
+	hdr->if_type = ESP_HCI_IF;
+	hdr->if_num = 0;
+	hdr->len = cpu_to_le16(len);
+	hdr->offset = cpu_to_le16(pad_len);
+	pos = skb->data;
+
+	/* set HCI packet type */
+	*(pos + pad_len - 1) = pkt_type;
+
+	if (adapter->capabilities & ESP_CHECKSUM_ENABLED)
+		hdr->checksum = cpu_to_le16(compute_checksum(skb->data, (len + pad_len)));
+
+	ret = esp_send_packet(adapter, skb);
+
+	if (ret) {
+		hdev->stat.err_tx++;
+		return ret;
+	} else {
+		esp_hci_update_tx_counter(hdev, hdr->hci_pkt_type, skb->len);
+	}
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+static int esp_bt_setup(struct hci_dev *hdev)
+{
+	return 0;
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0))
+static int esp_bt_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)
+{
+	return 0;
+}
+#endif
+
+int esp_deinit_bt(struct esp_adapter *adapter)
+{
+	struct hci_dev *hdev = NULL;
+
+	if (!adapter || !adapter->hcidev)
+		return 0;
+
+	hdev = adapter->hcidev;
+
+	hci_unregister_dev(hdev);
+	hci_free_dev(hdev);
+
+	adapter->hcidev = NULL;
+
+	return 0;
+}
+
+int esp_init_bt(struct esp_adapter *adapter)
+{
+	int ret = 0;
+	struct hci_dev *hdev = NULL;
+
+	if (!adapter) {
+		return -EINVAL;
+	}
+
+	if (adapter->hcidev) {
+		return -EEXIST;
+	}
+
+	hdev = hci_alloc_dev();
+
+	if (!hdev) {
+		BT_ERR("Can not allocate HCI device");
+		return -ENOMEM;
+	}
+
+	adapter->hcidev = hdev;
+	hci_set_drvdata(hdev, adapter);
+
+	hdev->bus = INVALID_HDEV_BUS;
+
+	if (adapter->if_type == ESP_IF_TYPE_SDIO)
+		hdev->bus   = HCI_SDIO;
+    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
+	else if (adapter->if_type == ESP_IF_TYPE_SPI)
+		hdev->bus   = HCI_SPI;
+    #endif
+
+	if (hdev->bus == INVALID_HDEV_BUS) {
+
+		if (adapter->if_type == ESP_IF_TYPE_SDIO) {
+			printk(KERN_ERR "%s: Kernel version does not support HCI over SDIO BUS\n",__func__);
+		} else if (adapter->if_type == ESP_IF_TYPE_SPI) {
+			printk(KERN_ERR "%s: Kernel version does not support HCI over SPI BUS\n",__func__);
+		} else {
+			printk(KERN_ERR "%s: HCI over expected BUS[%u] is not supported\n",__func__, adapter->if_type);
+		}
+		hci_free_dev(hdev);
+		adapter->hcidev = NULL;
+		return -EINVAL;
+	}
+
+	hdev->open  = esp_bt_open;
+	hdev->close = esp_bt_close;
+	hdev->flush = esp_bt_flush;
+	hdev->send  = esp_bt_send_frame;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	hdev->setup = esp_bt_setup;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0))
+	hdev->set_bdaddr = esp_bt_set_bdaddr;
+#endif
+
+	hdev->dev_type = HCI_PRIMARY;
+
+	ret = hci_register_dev(hdev);
+	if (ret < 0) {
+		BT_ERR("Can not register HCI device");
+		hci_free_dev(hdev);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c
new file mode 100644
index 0000000..6197933
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cfg80211.c
@@ -0,0 +1,597 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include "esp.h"
+#include "esp_api.h"
+#include "esp_cfg80211.h"
+#include "esp_cmd.h"
+#include "esp_kernel_port.h"
+
+/**
+  * @brief WiFi PHY rate encodings
+  *
+  */
+typedef enum {
+	WIFI_PHY_RATE_1M_L      = 0x00, /**< 1 Mbps with long preamble */
+	WIFI_PHY_RATE_2M_L      = 0x01, /**< 2 Mbps with long preamble */
+	WIFI_PHY_RATE_5M_L      = 0x02, /**< 5.5 Mbps with long preamble */
+	WIFI_PHY_RATE_11M_L     = 0x03, /**< 11 Mbps with long preamble */
+	WIFI_PHY_RATE_2M_S      = 0x05, /**< 2 Mbps with short preamble */
+	WIFI_PHY_RATE_5M_S      = 0x06, /**< 5.5 Mbps with short preamble */
+	WIFI_PHY_RATE_11M_S     = 0x07, /**< 11 Mbps with short preamble */
+	WIFI_PHY_RATE_48M       = 0x08, /**< 48 Mbps */
+	WIFI_PHY_RATE_24M       = 0x09, /**< 24 Mbps */
+	WIFI_PHY_RATE_12M       = 0x0A, /**< 12 Mbps */
+	WIFI_PHY_RATE_6M        = 0x0B, /**< 6 Mbps */
+	WIFI_PHY_RATE_54M       = 0x0C, /**< 54 Mbps */
+	WIFI_PHY_RATE_36M       = 0x0D, /**< 36 Mbps */
+	WIFI_PHY_RATE_18M       = 0x0E, /**< 18 Mbps */
+	WIFI_PHY_RATE_9M        = 0x0F, /**< 9 Mbps */
+	WIFI_PHY_RATE_MCS0_LGI  = 0x10, /**< MCS0 with long GI, 6.5 Mbps for 20MHz, 13.5 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS1_LGI  = 0x11, /**< MCS1 with long GI, 13 Mbps for 20MHz, 27 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS2_LGI  = 0x12, /**< MCS2 with long GI, 19.5 Mbps for 20MHz, 40.5 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS3_LGI  = 0x13, /**< MCS3 with long GI, 26 Mbps for 20MHz, 54 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS4_LGI  = 0x14, /**< MCS4 with long GI, 39 Mbps for 20MHz, 81 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS5_LGI  = 0x15, /**< MCS5 with long GI, 52 Mbps for 20MHz, 108 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS6_LGI  = 0x16, /**< MCS6 with long GI, 58.5 Mbps for 20MHz, 121.5 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS7_LGI  = 0x17, /**< MCS7 with long GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS0_SGI  = 0x18, /**< MCS0 with short GI, 7.2 Mbps for 20MHz, 15 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS1_SGI  = 0x19, /**< MCS1 with short GI, 14.4 Mbps for 20MHz, 30 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS2_SGI  = 0x1A, /**< MCS2 with short GI, 21.7 Mbps for 20MHz, 45 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS3_SGI  = 0x1B, /**< MCS3 with short GI, 28.9 Mbps for 20MHz, 60 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS4_SGI  = 0x1C, /**< MCS4 with short GI, 43.3 Mbps for 20MHz, 90 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS5_SGI  = 0x1D, /**< MCS5 with short GI, 57.8 Mbps for 20MHz, 120 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS6_SGI  = 0x1E, /**< MCS6 with short GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz */
+	WIFI_PHY_RATE_MCS7_SGI  = 0x1F, /**< MCS7 with short GI, 72.2 Mbps for 20MHz, 150 Mbps for 40MHz */
+	WIFI_PHY_RATE_LORA_250K = 0x29, /**< 250 Kbps */
+	WIFI_PHY_RATE_LORA_500K = 0x2A, /**< 500 Kbps */
+	WIFI_PHY_RATE_MAX,
+} wifi_phy_rate_t;
+
+/* Supported rates to be advertised to the cfg80211 */
+static struct ieee80211_rate esp_rates[] = {
+	{.bitrate = 10, .hw_value = WIFI_PHY_RATE_1M_L, },
+	{.bitrate = 20, .hw_value = WIFI_PHY_RATE_2M_L, },
+	{.bitrate = 55, .hw_value = WIFI_PHY_RATE_5M_L, .hw_value_short = WIFI_PHY_RATE_5M_S},
+	{.bitrate = 110, .hw_value = WIFI_PHY_RATE_11M_L, .hw_value_short = WIFI_PHY_RATE_11M_S},
+	{.bitrate = 60, .hw_value = WIFI_PHY_RATE_6M, },
+	{.bitrate = 90, .hw_value = WIFI_PHY_RATE_9M, },
+	{.bitrate = 120, .hw_value = WIFI_PHY_RATE_12M, },
+	{.bitrate = 180, .hw_value = WIFI_PHY_RATE_18M, },
+	{.bitrate = 240, .hw_value = WIFI_PHY_RATE_24M, },
+	{.bitrate = 360, .hw_value = WIFI_PHY_RATE_36M, },
+	{.bitrate = 480, .hw_value = WIFI_PHY_RATE_48M, },
+	{.bitrate = 540, .hw_value = WIFI_PHY_RATE_54M, },
+};
+
+
+/* Channel definitions to be advertised to cfg80211 */
+static struct ieee80211_channel esp_channels_2ghz[] = {
+	{.center_freq = 2412, .hw_value = 1, },
+	{.center_freq = 2417, .hw_value = 2, },
+	{.center_freq = 2422, .hw_value = 3, },
+	{.center_freq = 2427, .hw_value = 4, },
+	{.center_freq = 2432, .hw_value = 5, },
+	{.center_freq = 2437, .hw_value = 6, },
+	{.center_freq = 2442, .hw_value = 7, },
+	{.center_freq = 2447, .hw_value = 8, },
+	{.center_freq = 2452, .hw_value = 9, },
+	{.center_freq = 2457, .hw_value = 10, },
+	{.center_freq = 2462, .hw_value = 11, },
+	{.center_freq = 2467, .hw_value = 12, },
+	{.center_freq = 2472, .hw_value = 13, },
+	{.center_freq = 2484, .hw_value = 14, },
+};
+
+static struct ieee80211_supported_band esp_wifi_bands = {
+	.channels = esp_channels_2ghz,
+	.n_channels = ARRAY_SIZE(esp_channels_2ghz),
+	.bitrates = esp_rates,
+	.n_bitrates = ARRAY_SIZE(esp_rates),
+};
+
+/* Supported crypto cipher suits to be advertised to cfg80211 */
+static const u32 esp_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_SMS4,
+	WLAN_CIPHER_SUITE_AES_CMAC,
+};
+
+static const struct wiphy_wowlan_support esp_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_MAGIC_PKT,
+	.n_patterns = 0,
+	.pattern_max_len = 0,
+	.pattern_min_len = 0,
+	.max_pkt_offset = 0,
+};
+
+static int esp_inetaddr_event(struct notifier_block *nb,
+	unsigned long event, void *data)
+{
+	struct in_ifaddr *ifa = data;
+	struct net_device *netdev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;
+	struct esp_wifi_device *priv = netdev_priv(netdev);
+
+	/*printk(KERN_INFO "------- IP event -------: %d\n", priv->if_type);*/
+
+	if (!strstr(netdev->name, "espsta")) {
+		return 0;
+	}
+
+	switch (event) {
+
+	case NETDEV_UP:
+		if (priv && (priv->if_type == ESP_STA_IF)) {
+			cmd_set_ip_address(priv, ifa->ifa_local);
+			printk(KERN_INFO "%s: NETDEV_UP interface %s ip changed to  %pi4 \n",
+					__func__, netdev->name, &ifa->ifa_local);
+		}
+		break;
+
+	case NETDEV_DOWN:
+		printk(KERN_INFO "Interface Down: %d\n", priv->if_type);
+		if (priv && (priv->if_type == ESP_STA_IF))
+			cmd_set_ip_address(priv, 0);
+		break;
+	}
+
+	return 0;
+}
+
+struct wireless_dev *esp_cfg80211_add_iface(struct wiphy *wiphy,
+		const char *name,
+		unsigned char name_assign_type,
+		enum nl80211_iftype type,
+		struct vif_params *params)
+{
+	struct esp_device *esp_dev = NULL;
+/*	struct wireless_dev *wdev = NULL;*/
+	struct net_device *ndev;
+	struct esp_wifi_device *esp_wdev;
+	uint8_t esp_nw_if_num = 0;
+
+	if (!wiphy || !name) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	esp_dev = wiphy_priv(wiphy);
+
+	if (!esp_dev || !esp_dev->adapter) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	if (NL80211_IFTYPE_STATION == type) {
+		esp_nw_if_num = ESP_STA_NW_IF;
+	} else if (NL80211_IFTYPE_AP == type) {
+		esp_nw_if_num = ESP_AP_NW_IF;
+	} else {
+		printk(KERN_INFO "%s:%u network type[%u] is not supported\n",
+				__func__, __LINE__, type);
+		return NULL;
+	}
+
+	ndev = ALLOC_NETDEV(sizeof(struct esp_wifi_device), name, name_assign_type,
+			ether_setup);
+
+	if (!ndev)
+		return ERR_PTR(-ENOMEM);
+
+	set_bit(ESP_DRIVER_ACTIVE, &esp_dev->adapter->state_flags);
+	esp_wdev = netdev_priv(ndev);
+
+	ndev->ieee80211_ptr = &esp_wdev->wdev;
+	esp_wdev->wdev.wiphy = wiphy;
+	esp_wdev->esp_dev = esp_dev;
+	esp_wdev->ndev = ndev;
+	esp_wdev->adapter = esp_dev->adapter;
+	esp_wdev->adapter->priv[esp_nw_if_num] = esp_wdev;
+	/*printk(KERN_INFO "Updated priv[%u] to %px\n",
+	 * esp_nw_if_num, esp_wdev->adapter->priv[esp_nw_if_num]);*/
+	dev_net_set(ndev, wiphy_net(wiphy));
+	SET_NETDEV_DEV(ndev, wiphy_dev(esp_wdev->wdev.wiphy));
+	esp_wdev->wdev.netdev = ndev;
+	esp_wdev->wdev.iftype = type;
+
+	init_waitqueue_head(&esp_wdev->wait_for_scan_completion);
+	esp_wdev->stop_data = 1;
+	esp_wdev->port_open = 0;
+
+	if (cmd_init_interface(esp_wdev))
+		goto free_and_return;
+
+	if (cmd_get_mac(esp_wdev))
+		goto free_and_return;
+
+	eth_hw_addr_set(ndev, esp_wdev->mac_address);
+
+	esp_init_priv(ndev);
+
+	if (register_netdevice(ndev))
+		goto free_and_return;
+
+
+	set_bit(ESP_NETWORK_UP, &esp_wdev->priv_flags);
+	clear_bit(ESP_CLEANUP_IN_PROGRESS, &esp_dev->adapter->state_flags);
+
+	esp_wdev->nb.notifier_call = esp_inetaddr_event;
+	register_inetaddr_notifier(&esp_wdev->nb);
+
+	return &esp_wdev->wdev;
+
+free_and_return:
+	clear_bit(ESP_DRIVER_ACTIVE, &esp_wdev->adapter->state_flags);
+	dev_net_set(ndev, NULL);
+	free_netdev(ndev);
+	esp_wdev->ndev = NULL;
+	esp_wdev->wdev.netdev = NULL;
+	ndev = NULL;
+	return NULL;
+}
+
+#if 0
+static int esp_cfg80211_del_iface(struct wiphy *wiphy,
+							  struct wireless_dev *wdev)
+{
+	return 0;
+}
+
+static int esp_cfg80211_change_iface(struct wiphy *wiphy,
+							  struct net_device *ndev,
+							  enum nl80211_iftype type,
+							  struct vif_params *params)
+{
+	return 0;
+}
+#endif
+
+static int esp_cfg80211_scan(struct wiphy *wiphy,
+		struct cfg80211_scan_request *request)
+{
+
+	struct net_device *ndev = NULL;
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !request || !request->wdev || !request->wdev->netdev) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	ndev = request->wdev->netdev;
+	priv = netdev_priv(ndev);
+
+	printk(KERN_INFO "%s\n", __func__);
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return -EINVAL;
+	}
+
+	return cmd_scan_request(priv, request);
+}
+
+#if 0
+static int esp_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
+							  struct cfg80211_connect_params *sme)
+{
+	struct esp_wifi_device *priv = netdev_priv(dev);
+
+	printk(KERN_INFO "%s\n", __func__);
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return -EINVAL;
+	}
+
+	return cmd_connect_request(priv, sme);
+}
+#endif
+
+static ESP_MGMT_TX_PROTOTYPE()
+{
+	return 0;
+}
+
+static int esp_cfg80211_set_default_key(struct wiphy *wiphy,
+					struct net_device *dev, INT_LINK_ID
+					u8 key_index, bool unicast, bool multicast)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		printk(KERN_ERR "%s:%u invalid params\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return -EINVAL;
+	}
+
+	return cmd_set_default_key(priv, key_index);
+}
+
+static int esp_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
+				INT_LINK_ID u8 key_index, bool pairwise,
+				const u8 *mac_addr)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		printk(KERN_ERR "%s:%u invalid params\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return -EINVAL;
+	}
+	printk(KERN_INFO "%s\n", __func__);
+
+	return cmd_del_key(priv, key_index, pairwise, mac_addr);
+}
+
+static int esp_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+				INT_LINK_ID u8 key_index, bool pairwise,
+				const u8 *mac_addr, struct key_params *params)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !params) {
+		printk(KERN_ERR "%s:%u invalid params\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return -EINVAL;
+	}
+	printk(KERN_INFO "%s\n", __func__);
+
+	if (params->key_len == 0) {
+		return esp_cfg80211_del_key(wiphy, dev, ZERO_LINK_ID key_index, pairwise, mac_addr);
+	}
+	return cmd_add_key(priv, key_index, pairwise, mac_addr, params);
+}
+
+static int esp_cfg80211_disconnect(struct wiphy *wiphy,
+		struct net_device *dev, u16 reason_code)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return 0;
+	}
+	printk(KERN_INFO "%s\n", __func__);
+
+	return cmd_disconnect_request(priv, reason_code);
+}
+
+static int esp_cfg80211_authenticate(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_auth_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s\n", __func__);
+
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return 0;
+	}
+
+	return cmd_auth_request(priv, req);
+}
+
+
+static int esp_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_assoc_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	priv = netdev_priv(dev);
+
+	printk(KERN_INFO "%s\n", __func__);
+
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return 0;
+	}
+
+	return cmd_assoc_request(priv, req);
+}
+
+static int esp_cfg80211_deauth(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_deauth_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s\n", __func__);
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return 0;
+	}
+
+	return cmd_disconnect_request(priv, req->reason_code);
+}
+
+static int esp_cfg80211_disassoc(struct wiphy *wiphy, struct net_device *dev,
+		struct cfg80211_disassoc_request *req)
+{
+	struct esp_wifi_device *priv = NULL;
+
+	if (!wiphy || !dev || !req) {
+		printk(KERN_INFO "%s:%u invalid input\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s\n", __func__);
+	priv = netdev_priv(dev);
+
+	if (!priv) {
+		printk(KERN_ERR "%s: empty priv\n", __func__);
+		return 0;
+	}
+
+	return cmd_disconnect_request(priv, req->reason_code);
+}
+
+static int esp_cfg80211_suspend(struct wiphy *wiphy,
+			struct cfg80211_wowlan *wowlan)
+{
+	/*printk(KERN_INFO "%s\n", __func__);*/
+	return 0;
+}
+
+static int esp_cfg80211_resume(struct wiphy *wiphy)
+{
+	/*printk(KERN_INFO "%s\n", __func__);*/
+	return 0;
+}
+
+static void esp_cfg80211_set_wakeup(struct wiphy *wiphy,
+			bool enabled)
+{
+	/*printk(KERN_INFO "%s\n", __func__);*/
+}
+
+static struct cfg80211_ops esp_cfg80211_ops = {
+#if 0
+	.add_virtual_intf = esp_cfg80211_add_iface,
+	.del_virtual_intf = esp_cfg80211_del_iface,
+	.change_virtual_intf = esp_cfg80211_change_iface,
+#endif
+	.scan = esp_cfg80211_scan,
+	/*.connect = esp_cfg80211_connect,*/
+	.disconnect = esp_cfg80211_disconnect,
+	.add_key = esp_cfg80211_add_key,
+	.del_key = esp_cfg80211_del_key,
+	.set_default_key = esp_cfg80211_set_default_key,
+	.mgmt_tx = esp_cfg80211_mgmt_tx,
+	.auth = esp_cfg80211_authenticate,
+	.deauth = esp_cfg80211_deauth,
+	.disassoc = esp_cfg80211_disassoc,
+	.assoc = esp_cfg80211_associate,
+	.suspend = esp_cfg80211_suspend,
+	.resume = esp_cfg80211_resume,
+	.set_wakeup = esp_cfg80211_set_wakeup,
+};
+
+int esp_cfg80211_register(struct esp_adapter *adapter)
+{
+	struct wiphy *wiphy;
+	struct esp_device *esp_dev;
+	int ret = 0;
+
+	wiphy = wiphy_new(&esp_cfg80211_ops, sizeof(struct esp_device));
+
+	if (!wiphy) {
+		printk(KERN_ERR "Failed to create wiphy\n");
+		return -EFAULT;
+	}
+
+	adapter->wiphy = wiphy;
+
+	esp_dev = wiphy_priv(wiphy);
+	esp_dev->wiphy = wiphy;
+	esp_dev->adapter = adapter;
+
+	esp_dev->dev = adapter->dev;
+
+	set_wiphy_dev(wiphy, esp_dev->dev);
+
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+	wiphy->bands[NL80211_BAND_2GHZ] = &esp_wifi_bands;
+
+	/* Initialize cipher suits */
+	wiphy->cipher_suites = esp_cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(esp_cipher_suites);
+
+	/* TODO: check and finalize the numbers */
+	wiphy->max_scan_ssids = 10;
+	/*	wiphy->max_match_sets = 10;*/
+	wiphy->max_scan_ie_len = 1000;
+	wiphy->max_sched_scan_ssids = 10;
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	wiphy->wowlan = &esp_wowlan_support;
+
+	/* Advertise SAE support */
+	wiphy->features |= NL80211_FEATURE_SAE;
+
+	ret = wiphy_register(wiphy);
+
+	return ret;
+}
+
+int esp_mark_disconnect(struct esp_wifi_device *priv, uint16_t reason,
+		uint8_t locally_disconnect)
+{
+	if (priv && priv->ndev)
+		if (priv->ndev->reg_state == NETREG_REGISTERED)
+			CFG80211_DISCONNECTED(priv->ndev, reason, NULL, 0, locally_disconnect,
+					GFP_KERNEL);
+	return 0;
+}
+
+int esp_mark_scan_done_and_disconnect(struct esp_wifi_device *priv,
+		uint8_t locally_disconnect)
+{
+
+	if (!priv)
+		return -EINVAL;
+
+	ESP_MARK_SCAN_DONE(priv, true);
+
+	ESP_CANCEL_SCHED_SCAN();
+
+	esp_mark_disconnect(priv, 0, locally_disconnect);
+
+	return 0;
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c
new file mode 100644
index 0000000..2ef65b0
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_cmd.c
@@ -0,0 +1,1424 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include "esp_cmd.h"
+#include "esp_api.h"
+#include "esp_wpa_utils.h"
+#include "esp.h"
+#include "esp_cfg80211.h"
+#include "esp_kernel_port.h"
+
+#define PRINT_HEXDUMP(STR,ARG, ARG_LEN,level) \
+	print_hex_dump(KERN_INFO, STR, DUMP_PREFIX_ADDRESS, 16, 1, ARG, ARG_LEN, 1);
+
+#define COMMAND_RESPONSE_TIMEOUT (5 * HZ)
+u8 ap_bssid[MAC_ADDR_LEN];
+
+int internal_scan_request(struct esp_wifi_device *priv, char* ssid,
+		uint8_t channel, uint8_t is_blocking);
+
+struct beacon_probe_fixed_params {
+	__le64 timestamp;
+	__le16 beacon_interval;
+	__le16 cap_info;
+} __packed;
+
+static struct command_node * get_free_cmd_node(struct esp_adapter *adapter)
+{
+	struct command_node *cmd_node;
+
+	spin_lock_bh(&adapter->cmd_free_queue_lock);
+
+	if (list_empty(&adapter->cmd_free_queue)) {
+		spin_unlock_bh(&adapter->cmd_free_queue_lock);
+		printk(KERN_ERR "esp32: No free cmd node found\n");
+		return NULL;
+	}
+	cmd_node = list_first_entry(&adapter->cmd_free_queue,
+				    struct command_node, list);
+	list_del(&cmd_node->list);
+	spin_unlock_bh(&adapter->cmd_free_queue_lock);
+
+	cmd_node->cmd_skb = esp_alloc_skb(ESP_SIZE_OF_CMD_NODE);
+	if (!cmd_node->cmd_skb) {
+		printk(KERN_ERR "esp32: No free cmd node skb found\n");
+	}
+
+	return cmd_node;
+}
+
+static inline void reset_cmd_node(struct esp_adapter *adapter, struct command_node * cmd_node)
+{
+	cmd_node->cmd_code = 0;
+
+	spin_lock_bh(&adapter->cmd_lock);
+	if (cmd_node->resp_skb) {
+		dev_kfree_skb_any(cmd_node->resp_skb);
+		cmd_node->resp_skb = NULL;
+	}
+	spin_unlock_bh(&adapter->cmd_lock);
+}
+
+static void queue_cmd_node(struct esp_adapter *adapter,
+		struct command_node * cmd_node, u8 flag_high_prio)
+{
+	spin_lock_bh(&adapter->cmd_pending_queue_lock);
+
+	if (flag_high_prio)
+		list_add_rcu(&cmd_node->list, &adapter->cmd_pending_queue);
+	else
+		list_add_tail_rcu(&cmd_node->list, &adapter->cmd_pending_queue);
+
+	spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+}
+
+static int decode_get_mac_addr(struct esp_wifi_device *priv,
+		struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct cmd_config_mac_address *header;
+
+	if (!priv || !cmd_node ||
+	    !cmd_node->resp_skb ||
+	    !cmd_node->resp_skb->data) {
+		printk(KERN_INFO "%s: invalid arg\n", __func__);
+		return -1;
+	}
+
+	header = (struct cmd_config_mac_address *) (cmd_node->resp_skb->data);
+
+	if (header->header.cmd_status != CMD_RESPONSE_SUCCESS) {
+		printk(KERN_INFO "esp32: Command failed\n");
+		ret = -1;
+	}
+
+	if (priv)
+		memcpy(priv->mac_address, header->mac_addr, MAC_ADDR_LEN);
+	else
+		printk(KERN_ERR "esp32: %s: priv not updated\n", __func__);
+
+	return ret;
+}
+
+
+static int decode_common_resp(struct command_node *cmd_node)
+{
+	int ret = 0;
+	struct command_header *cmd;
+
+
+	if (!cmd_node || !cmd_node->resp_skb || !cmd_node->resp_skb->data) {
+
+		printk(KERN_INFO "esp32: %s Failed. cmd_node:%p \n", __func__, cmd_node);
+
+		if (cmd_node)
+			printk(KERN_INFO "esp32: %s: code: %u resp_skb:%p \n",
+				__func__, cmd_node->cmd_code, cmd_node->resp_skb);
+
+		return -1;
+	}
+
+	cmd = (struct command_header *) (cmd_node->resp_skb->data);
+
+	if (cmd->cmd_status != CMD_RESPONSE_SUCCESS) {
+		printk(KERN_INFO "esp32: [0x%x] Command failed\n", cmd_node->cmd_code);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static void recycle_cmd_node(struct esp_adapter *adapter,
+		struct command_node * cmd_node)
+{
+	if (!adapter || !cmd_node)
+		return;
+
+	reset_cmd_node(adapter, cmd_node);
+
+	spin_lock_bh(&adapter->cmd_free_queue_lock);
+	list_add_tail(&cmd_node->list, &adapter->cmd_free_queue);
+	spin_unlock_bh(&adapter->cmd_free_queue_lock);
+}
+
+
+static int wait_and_decode_cmd_resp(struct esp_wifi_device *priv,
+		struct command_node *cmd_node)
+{
+	struct esp_adapter *adapter = NULL;
+	int ret = 0;
+
+	if (!priv || !priv->adapter || !cmd_node) {
+		printk(KERN_INFO "%s invalid params\n", __func__);
+		if (priv->adapter) {
+			adapter = priv->adapter;
+			if (adapter && cmd_node)
+				recycle_cmd_node(adapter, cmd_node);
+		}
+		return -EINVAL;
+	}
+
+	adapter = priv->adapter;
+
+	/* wait for command response */
+	ret = wait_event_interruptible_timeout(adapter->wait_for_cmd_resp,
+			adapter->cmd_resp == cmd_node->cmd_code, COMMAND_RESPONSE_TIMEOUT);
+
+	if (!test_bit(ESP_DRIVER_ACTIVE, &adapter->state_flags))
+		return 0;
+
+	if (ret == 0) {
+		printk(KERN_ERR "esp32: Command[%u] timed out\n", cmd_node->cmd_code);
+		ret = -EINVAL;
+	} else {
+		/*printk(KERN_DEBUG "Resp for command [%u]\n", cmd_node->cmd_code);*/
+		ret = 0;
+	}
+
+	spin_lock_bh(&adapter->cmd_lock);
+	adapter->cur_cmd = NULL;
+	adapter->cmd_resp = 0;
+	spin_unlock_bh(&adapter->cmd_lock);
+
+	switch (cmd_node->cmd_code) {
+
+	case CMD_SCAN_REQUEST:
+		if (ret == 0)
+			ret = decode_common_resp(cmd_node);
+
+		if (ret)
+			ESP_MARK_SCAN_DONE(priv, false);
+		break;
+
+	case CMD_INIT_INTERFACE:
+	case CMD_DEINIT_INTERFACE:
+	case CMD_STA_AUTH:
+	case CMD_STA_ASSOC:
+	case CMD_STA_CONNECT:
+	case CMD_STA_DISCONNECT:
+	case CMD_ADD_KEY:
+	case CMD_DEL_KEY:
+	case CMD_SET_DEFAULT_KEY:
+	case CMD_SET_IP_ADDR:
+	case CMD_SET_MCAST_MAC_ADDR:
+		/* intentional fallthrough */
+		if (ret == 0)
+			ret = decode_common_resp(cmd_node);
+		break;
+
+	case CMD_GET_MAC:
+		if (ret == 0)
+			ret = decode_get_mac_addr(priv, cmd_node);
+		break;
+
+	default:
+		printk(KERN_INFO "esp32: %s Resp for [0x%x] ignored\n",
+				__func__,cmd_node->cmd_code);
+		ret = -EINVAL;
+		break;
+	}
+
+	recycle_cmd_node(adapter, cmd_node);
+	return ret;
+}
+
+static void free_esp_cmd_pool(struct esp_adapter *adapter)
+{
+	int i;
+	struct command_node * cmd_pool = NULL;
+
+	if (!adapter || !adapter->cmd_pool)
+		return;
+
+	cmd_pool = adapter->cmd_pool;
+
+	for (i=0; i<ESP_NUM_OF_CMD_NODES; i++) {
+
+		spin_lock_bh(&adapter->cmd_lock);
+		if (cmd_pool[i].resp_skb) {
+			dev_kfree_skb_any(cmd_pool[i].resp_skb);
+			cmd_pool[i].resp_skb = NULL;
+		}
+		spin_unlock_bh(&adapter->cmd_lock);
+	}
+
+	kfree(adapter->cmd_pool);
+	adapter->cmd_pool = NULL;
+}
+
+static int alloc_esp_cmd_pool(struct esp_adapter *adapter)
+{
+	u16 i;
+
+	struct command_node * cmd_pool = kcalloc(ESP_NUM_OF_CMD_NODES,
+		sizeof(struct command_node), GFP_KERNEL);
+
+	if(!cmd_pool)
+		return -ENOMEM;
+
+	adapter->cmd_pool = cmd_pool;
+
+	for (i=0; i<ESP_NUM_OF_CMD_NODES; i++) {
+
+		cmd_pool[i].cmd_skb = NULL;
+		cmd_pool[i].resp_skb = NULL;
+		recycle_cmd_node(adapter, &cmd_pool[i]);
+	}
+
+	return 0;
+}
+
+static void esp_cmd_work(struct work_struct *work)
+{
+	int ret;
+	struct command_node *cmd_node = NULL;
+	struct esp_adapter * adapter = NULL;
+	struct esp_payload_header *payload_header = NULL;
+
+	adapter = esp_get_adapter();
+
+	if (!adapter)
+		return;
+
+	if (!test_bit(ESP_DRIVER_ACTIVE, &adapter->state_flags))
+		return;
+
+	synchronize_rcu();
+	spin_lock_bh(&adapter->cmd_lock);
+	if (adapter->cur_cmd) {
+		/* Busy in another command */
+		/*printk(KERN_DEBUG "esp32: Busy in another cmd execution\n");*/
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+
+	spin_lock_bh(&adapter->cmd_pending_queue_lock);
+
+	if (list_empty(&adapter->cmd_pending_queue)) {
+		/* No command to process */
+		/*printk(KERN_DEBUG "esp32: No more command in queue.\n");*/
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+
+	cmd_node = list_first_entry(&adapter->cmd_pending_queue,
+				    struct command_node, list);
+	if (! cmd_node) {
+		printk(KERN_DEBUG "esp32: cmd node NULL\n");
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+	/*printk(KERN_DEBUG "esp32: Processing Command [0x%X]\n", cmd_node->cmd_code);*/
+
+	list_del(&cmd_node->list);
+
+	if (! cmd_node->cmd_skb) {
+		printk(KERN_DEBUG "cmd_node->cmd_skb NULL \n");
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		spin_unlock_bh(&adapter->cmd_lock);
+		return;
+	}
+
+	/* Set as current cmd */
+	adapter->cur_cmd = cmd_node;
+
+	adapter->cmd_resp = 0;
+
+	payload_header = (struct esp_payload_header *)cmd_node->cmd_skb->data;
+	if (adapter->capabilities & ESP_CHECKSUM_ENABLED)
+		payload_header->checksum = cpu_to_le16(compute_checksum(cmd_node->cmd_skb->data,
+					payload_header->len+payload_header->offset));
+
+	ret = esp_send_packet(adapter, cmd_node->cmd_skb);
+	spin_unlock_bh(&adapter->cmd_lock);
+
+	if (ret) {
+		printk(KERN_ERR "esp32: %s: Failed to send command [0x%X] \n",
+			__func__, cmd_node->cmd_code);
+		adapter->cur_cmd = NULL;
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		recycle_cmd_node(adapter, cmd_node);
+		return;
+	}
+
+	if (!list_empty(&adapter->cmd_pending_queue)) {
+		/*printk(KERN_DEBUG "Ym2: Pending cmds, queue work again\n");*/
+		spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+		queue_work(adapter->cmd_wq, &adapter->cmd_work);
+		return;
+	}
+	spin_unlock_bh(&adapter->cmd_pending_queue_lock);
+}
+
+static int create_cmd_wq(struct esp_adapter *adapter)
+{
+	adapter->cmd_wq = alloc_workqueue("ESP_CMD_WORK_QUEUE", 0, 0);
+
+	RET_ON_FAIL(!adapter->cmd_wq);
+
+	INIT_WORK(&adapter->cmd_work, esp_cmd_work);
+
+	return 0;
+}
+
+static void destroy_cmd_wq(struct esp_adapter *adapter)
+{
+	if (adapter->cmd_wq) {
+		flush_scheduled_work();
+		destroy_workqueue(adapter->cmd_wq);
+		adapter->cmd_wq = NULL;
+	}
+}
+
+struct command_node * prepare_command_request(struct esp_adapter *adapter, u8 cmd_code, u16 len)
+{
+	struct command_header *cmd;
+	struct esp_payload_header *payload_header;
+	struct command_node *node = NULL;
+
+	if (!adapter) {
+		printk(KERN_INFO "%s:%u null adapter\n",__func__,__LINE__);
+		return NULL;
+	}
+
+	if (!cmd_code || cmd_code >= CMD_MAX) {
+		printk(KERN_ERR "esp32: %s: unsupported command code\n", __func__);
+		return NULL;
+	}
+
+	node = get_free_cmd_node(adapter);
+
+	if (!node || !node->cmd_skb) {
+		printk(KERN_ERR "esp32: %s: Failed to get new free cmd node\n", __func__);
+		return NULL;
+	}
+
+	node->cmd_code = cmd_code;
+
+	len += sizeof(struct esp_payload_header);
+
+	payload_header = (struct esp_payload_header *)skb_put(node->cmd_skb, len);
+	memset(payload_header, 0, len);
+
+	payload_header->if_type = ESP_STA_IF;
+	payload_header->len = cpu_to_le16(len - sizeof(struct esp_payload_header));
+	payload_header->offset = cpu_to_le16(sizeof(struct esp_payload_header));
+	payload_header->packet_type = PACKET_TYPE_COMMAND_REQUEST;
+
+	cmd = (struct command_header *) (node->cmd_skb->data + payload_header->offset);
+	cmd->cmd_code = cmd_code;
+
+/*	payload_header->checksum = cpu_to_le16(compute_checksum(skb->data, len));*/
+
+	return node;
+}
+
+int process_cmd_resp(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	if (!skb || !adapter) {
+		printk(KERN_ERR "esp32: CMD resp: invalid!\n");
+
+		if (skb)
+			dev_kfree_skb_any(skb);
+
+		return -1;
+	}
+
+	if (!adapter->cur_cmd) {
+		printk(KERN_ERR "esp32: Command response not expected\n");
+		dev_kfree_skb_any(skb);
+		return -1;
+	}
+
+	spin_lock_bh(&adapter->cmd_lock);
+	adapter->cur_cmd->resp_skb = skb;
+	adapter->cmd_resp = adapter->cur_cmd->cmd_code;
+	spin_unlock_bh(&adapter->cmd_lock);
+
+
+	wake_up_interruptible(&adapter->wait_for_cmd_resp);
+	queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+	return 0;
+}
+
+static void process_scan_result_event(struct esp_wifi_device *priv,
+		struct scan_event *scan_evt)
+{
+	struct cfg80211_bss *bss = NULL;
+	struct beacon_probe_fixed_params *fixed_params = NULL;
+	struct ieee80211_channel *chan = NULL;
+	u8 *ie_buf = NULL;
+	u64 timestamp;
+	u16 beacon_interval;
+	u16 cap_info;
+	u32 ie_len;
+	int freq;
+
+	if (!priv || !scan_evt) {
+		printk(KERN_ERR "%s: Invalid arguments\n", __func__);
+		return;
+	}
+
+	/*if (!priv->scan_in_progress) {
+		return;
+	}*/
+
+	/* End of scan; notify cfg80211 */
+	if (scan_evt->header.status == 0) {
+
+		ESP_MARK_SCAN_DONE(priv, false);
+		if (priv->waiting_for_scan_done) {
+			priv->waiting_for_scan_done = false;
+			wake_up_interruptible(&priv->wait_for_scan_completion);
+		}
+		return;
+	}
+
+	ie_buf = (u8 *) scan_evt->frame;
+	ie_len = le16_to_cpu(scan_evt->frame_len);
+
+	fixed_params = (struct beacon_probe_fixed_params *) ie_buf;
+
+	timestamp = le64_to_cpu(fixed_params->timestamp);
+	beacon_interval = le16_to_cpu(fixed_params->beacon_interval);
+	cap_info = le16_to_cpu(fixed_params->cap_info);
+
+	freq = ieee80211_channel_to_frequency(scan_evt->channel, NL80211_BAND_2GHZ);
+	chan = ieee80211_get_channel(priv->adapter->wiphy, freq);
+
+	ie_buf += sizeof(struct beacon_probe_fixed_params);
+	ie_len -= sizeof(struct beacon_probe_fixed_params);
+
+	if (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {
+		bss = CFG80211_INFORM_BSS(priv->adapter->wiphy, chan,
+				scan_evt->bssid, timestamp,
+				cap_info, beacon_interval, ie_buf, ie_len,
+				(le32_to_cpu(scan_evt->rssi) * 100), GFP_ATOMIC);
+
+		if (bss)
+			cfg80211_put_bss(priv->adapter->wiphy, bss);
+	} else {
+		printk(KERN_INFO "Scan report: Skip invalid or disabled channel\n");
+	}
+}
+
+static void process_auth_event(struct esp_wifi_device * priv,
+		struct auth_event *event)
+{
+	if (!priv || !event) {
+		printk(KERN_ERR "%s: Invalid arguments\n", __func__);
+		return;
+	}
+
+#if 0
+	print_hex_dump(KERN_INFO, "Auth frame: ", DUMP_PREFIX_ADDRESS, 16, 1,
+			event->frame, event->frame_len, 1);
+#endif
+
+	cfg80211_rx_mlme_mgmt(priv->ndev, event->frame, event->frame_len);
+
+}
+
+static void process_disconnect_event(struct esp_wifi_device *priv,
+		struct disconnect_event *event)
+{
+	if (!priv || !event) {
+		printk(KERN_ERR "%s: Invalid arguments\n", __func__);
+		return;
+	}
+
+	printk(KERN_INFO "Disconnect event for ssid %s [reason:%d]\n",
+			event->ssid, event->reason);
+
+	esp_mark_disconnect(priv, event->reason, true);
+}
+
+static void process_assoc_event(struct esp_wifi_device *priv,
+		struct assoc_event *event)
+{
+	u8 mac[6];
+
+	if (!priv || !event) {
+		printk(KERN_ERR "%s: Invalid arguments\n", __func__);
+		return;
+	}
+
+	printk(KERN_INFO "Connection status: %d\n", event->header.status);
+
+	memcpy(mac, event->bssid, MAC_ADDR_LEN);
+
+	CFG80211_RX_ASSOC_RESP(priv->ndev, priv->bss, event->frame, event->frame_len,
+			0, priv->assoc_req_ie, priv->assoc_req_ie_len);
+
+#if 0
+	if (priv->bss) {
+		cfg80211_connect_bss(priv->ndev, mac, priv->bss, NULL, 0, NULL, 0,
+				0, GFP_KERNEL, NL80211_TIMEOUT_UNSPECIFIED);
+	} else {
+		cfg80211_connect_result(priv->ndev, mac, NULL, 0, NULL, 0,
+				0, GFP_KERNEL);
+	}
+#endif
+
+	esp_port_open(priv);
+}
+
+int process_cmd_event(struct esp_wifi_device *priv, struct sk_buff *skb)
+{
+	struct event_header *header;
+
+	if (!skb || !priv) {
+		printk(KERN_ERR "esp32: CMD evnt: invalid!\n");
+		return -1;
+	}
+
+	header = (struct event_header *) (skb->data);
+
+	switch (header->event_code) {
+
+	case EVENT_SCAN_RESULT:
+		process_scan_result_event(priv,
+				(struct scan_event *)(skb->data));
+		break;
+
+	case EVENT_ASSOC_RX:
+		process_assoc_event(priv,
+				(struct assoc_event *)(skb->data));
+		break;
+
+	case EVENT_STA_DISCONNECT:
+		process_disconnect_event(priv,
+				(struct disconnect_event *)(skb->data));
+		break;
+
+	case EVENT_AUTH_RX:
+		process_auth_event(priv, (struct auth_event *)(skb->data));
+		break;
+
+	default:
+		printk(KERN_INFO "%s:%u unhandled event[%u]\n",
+				__func__, __LINE__, header->event_code);
+		break;
+	}
+
+	return 0;
+}
+
+int cmd_set_mcast_mac_list(struct esp_wifi_device *priv, struct multicast_list *list)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_set_mcast_mac_addr *cmd_mcast_mac_list;
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_MCAST_MAC_ADDR,
+			sizeof(struct cmd_set_mcast_mac_addr));
+
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_mcast_mac_list = (struct cmd_set_mcast_mac_addr *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_mcast_mac_list->count = list->addr_count;
+	memcpy(cmd_mcast_mac_list->mcast_addr, list->mcast_addr,
+			sizeof(cmd_mcast_mac_list->mcast_addr));
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	return 0;
+}
+
+int cmd_set_ip_address(struct esp_wifi_device *priv, u32 ip)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_set_ip_addr *cmd_set_ip;
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_IP_ADDR,
+			sizeof(struct cmd_set_ip_addr));
+
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_set_ip = (struct cmd_set_ip_addr *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_set_ip->ip = cpu_to_le32(ip);
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_disconnect_request(struct esp_wifi_device *priv, u16 reason_code)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_sta_disconnect *cmd_disconnect;
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_STA_DISCONNECT,
+			sizeof(struct cmd_sta_disconnect));
+
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd_disconnect = (struct cmd_sta_disconnect *)
+		(cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd_disconnect->reason_code = reason_code;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+#if 0
+int cmd_connect_request(struct esp_wifi_device *priv,
+		struct cfg80211_connect_params *params)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_sta_connect *cmd;
+	struct ieee80211_channel *chan;
+	struct cfg80211_bss *bss;
+	struct esp_adapter *adapter = NULL;
+	u8 retry = 2;
+
+	if (!priv || !params || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return failure", __func__, __LINE__);
+		return -EFAULT;
+	}
+
+	adapter = priv->adapter;
+
+	cmd_len = sizeof(struct cmd_sta_connect) + params->ie_len;
+
+	cmd_node = prepare_command_request(adapter, CMD_STA_CONNECT, cmd_len);
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+	cmd = (struct cmd_sta_connect *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	if (params->ssid_len)
+		memcpy(cmd->ssid, params->ssid, MAX_SSID_LEN);
+	else
+		printk(KERN_ERR "%s: No ssid\n", __func__);
+
+	if (params->bssid) {
+		memcpy(ap_bssid, params->bssid, MAC_ADDR_LEN);
+		memcpy(cmd->bssid, params->bssid, MAC_ADDR_LEN);
+	}
+
+	if (params->channel) {
+		chan = params->channel;
+		cmd->channel = chan->hw_value;
+	}
+
+	if (params->ie_len) {
+		cmd->assoc_ie_len = cpu_to_le16(params->ie_len);
+		memcpy(cmd->assoc_ie, params->ie, params->ie_len);
+	}
+
+	if (params->privacy)
+		cmd->is_auth_open = 0;
+	else
+		cmd->is_auth_open = 1;
+
+	printk(KERN_INFO "Connection request: %s %pM %d\n",
+			cmd->ssid, params->bssid, cmd->channel);
+
+	do {
+		bss = cfg80211_get_bss(adapter->wiphy, params->channel, params->bssid,
+				params->ssid, params->ssid_len, IEEE80211_BSS_TYPE_ESS, IEEE80211_PRIVACY_ANY);
+
+		if (bss) {
+			break;
+		} else {
+			printk(KERN_INFO "No BSS in the list.. scanning..\n");
+			internal_scan_request(priv, cmd->ssid, cmd->channel, true);
+		}
+
+		retry--;
+	} while (retry);
+
+	if (retry) {
+		queue_cmd_node(adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+		queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+		RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+	} else {
+		printk(KERN_INFO "Failed to find %s\n", cmd->ssid);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+#endif
+
+
+int cmd_assoc_request(struct esp_wifi_device *priv,
+		struct cfg80211_assoc_request *req)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_sta_assoc *cmd;
+	struct cfg80211_bss *bss;
+	struct esp_adapter *adapter = NULL;
+	u16 cmd_len;
+
+	if (!priv || !req || !req->bss || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return failure", __func__, __LINE__);
+		return -EFAULT;
+	}
+
+	bss = req->bss;
+	adapter = priv->adapter;
+
+	cmd_len = sizeof(struct cmd_sta_assoc) + req->ie_len;
+
+	cmd_node = prepare_command_request(adapter, CMD_STA_ASSOC, cmd_len);
+
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd = (struct cmd_sta_assoc *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	cmd->assoc_ie_len = req->ie_len;
+	memcpy(cmd->assoc_ie, req->ie, req->ie_len);
+
+	/* Make a copy of assoc req IEs */
+	if (priv->assoc_req_ie) {
+		kfree(priv->assoc_req_ie);
+		priv->assoc_req_ie = NULL;
+	}
+
+	priv->assoc_req_ie = kmemdup(req->ie, req->ie_len, GFP_ATOMIC);
+
+	if (!priv->assoc_req_ie) {
+		printk(KERN_ERR "Failed to allocate buffer for assoc request IEs \n");
+		return -ENOMEM;
+	}
+
+	priv->assoc_req_ie_len = req->ie_len;
+
+	printk(KERN_INFO "Association request: %pM %d %d\n",
+			bss->bssid, bss->channel->hw_value, cmd->assoc_ie_len);
+
+	queue_cmd_node(adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_auth_request(struct esp_wifi_device *priv,
+		struct cfg80211_auth_request *req)
+{
+	struct command_node *cmd_node = NULL;
+	struct cmd_sta_auth *cmd;
+	struct cfg80211_bss *bss;
+	/*struct cfg80211_bss *bss1;*/
+	struct esp_adapter *adapter = NULL;
+	u16 cmd_len;
+	/* u8 retry = 2; */
+
+	if (!priv || !req || !req->bss || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return failure", __func__, __LINE__);
+		return -EFAULT;
+	}
+
+	bss = req->bss;
+
+	priv->bss = req->bss;
+
+	adapter = priv->adapter;
+
+	cmd_len = sizeof(struct cmd_sta_auth) + req->auth_data_len;
+
+	cmd_node = prepare_command_request(adapter, CMD_STA_AUTH, cmd_len);
+
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+	cmd = (struct cmd_sta_auth *) (cmd_node->cmd_skb->data + sizeof(struct esp_payload_header));
+
+	memcpy(cmd->bssid, bss->bssid, MAC_ADDR_LEN);
+	cmd->channel = bss->channel->hw_value;
+	cmd->auth_type = req->auth_type;
+	cmd->auth_data_len = req->auth_data_len;
+	memcpy(cmd->auth_data, req->auth_data, req->auth_data_len);
+
+	printk(KERN_INFO "Authentication request: %pM %d %d %d %d\n",
+			cmd->bssid, cmd->channel, cmd->auth_type, cmd->auth_data_len,
+			(u32) req->ie_len);
+#if 0
+	do {
+		bss1 = cfg80211_get_bss(adapter->wiphy, bss->channel, bss->bssid,
+				NULL, 0, IEEE80211_BSS_TYPE_ESS, IEEE80211_PRIVACY_ANY);
+
+		if (bss1) {
+			break;
+		} else {
+			printk(KERN_INFO "No BSS in the list.. scanning..\n");
+			internal_scan_request(priv, cmd->ssid, cmd->channel, true);
+		}
+
+		retry--;
+	} while (retry);
+#endif
+	queue_cmd_node(adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(adapter->cmd_wq, &adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_set_default_key(struct esp_wifi_device *priv, u8 key_index)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_key_operation *cmd;
+	struct wifi_sec_key * key = NULL;
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+#if 0
+	if (key_index > ESP_MAX_KEY_INDEX) {
+		printk(KERN_ERR "invalid key index[%u] > max[%u]\n",
+				key_index, ESP_MAX_KEY_INDEX);
+		return -EINVAL;
+	}
+#endif
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return", __func__, __LINE__);
+		return 0;
+	}
+
+	cmd_len = sizeof(struct cmd_key_operation);
+
+	/* get new cmd node */
+	cmd_node = prepare_command_request(priv->adapter, CMD_SET_DEFAULT_KEY, cmd_len);
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	/* cmd specific update */
+	cmd = (struct cmd_key_operation *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+	key = &cmd->key;
+
+	key->index = key_index;
+	key->set_cur = 1;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_del_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_key_operation *cmd;
+	struct wifi_sec_key * key = NULL;
+	const u8 *mac = NULL;
+	const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags))
+		return 0;
+
+#if 0
+	if (key_index > ESP_MAX_KEY_INDEX) {
+		printk(KERN_ERR "invalid key index[%u] > max[%u]\n",
+				key_index, ESP_MAX_KEY_INDEX);
+		return -EINVAL;
+	}
+#endif
+
+	mac = pairwise ? mac_addr : bc_mac;
+
+	cmd_len = sizeof(struct cmd_key_operation);
+
+	/* get new cmd node */
+	cmd_node = prepare_command_request(priv->adapter, CMD_DEL_KEY, cmd_len);
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	/* cmd specific update */
+	cmd = (struct cmd_key_operation *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+	key = &cmd->key;
+
+	if (mac && !is_multicast_ether_addr(mac))
+		memcpy((char *)&key->mac_addr, (void *)mac, MAC_ADDR_LEN);
+
+	key->index = key_index;
+	key->del = 1;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_add_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr, struct key_params *params)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct cmd_key_operation *cmd;
+	struct wifi_sec_key * key = NULL;
+	const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	const u8 *mac = NULL;
+
+#if 0
+	printk(KERN_INFO "%s:%u key_idx: %u pairwise: %u params->key_len: %u \nparams->seq_len:%u params->mode: 0x%x \nparams->cipher: 0x%x\n",
+      __func__, __LINE__,
+      key_index, pairwise, params->key_len, params->seq_len, params->mode, params->cipher);
+#endif
+	if (!priv || !priv->adapter || !params ||
+	    !params->key || !params->key_len || !params->seq_len) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+#if 0
+	if (key_index > ESP_MAX_KEY_INDEX) {
+		printk(KERN_ERR "invalid key index[%u] > max[%u]\n",
+				key_index, ESP_MAX_KEY_INDEX);
+		return -EINVAL;
+	}
+#endif
+
+	if (params->key_len > sizeof(key->data)) {
+		printk(KERN_ERR "Too long key length (%u)\n", params->key_len);
+		return -EINVAL;
+	}
+
+	if (params->seq_len > sizeof(key->seq)) {
+		printk(KERN_ERR "Too long key seq length (%u)\n", params->seq_len);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return failure", __func__, __LINE__);
+		return -EFAULT;
+	}
+
+	mac = pairwise ? mac_addr : bc_mac;
+	if (mac) {
+#if 0
+		print_hex_dump(KERN_INFO, "mac: ", DUMP_PREFIX_ADDRESS, 16, 1,
+				mac, MAC_ADDR_LEN, 1);
+#endif
+	}
+
+	cmd_len = sizeof(struct cmd_key_operation);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_ADD_KEY, cmd_len);
+	if (!cmd_node) {
+		printk(KERN_ERR "Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	cmd = (struct cmd_key_operation *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+	key = &cmd->key;
+
+	if (mac && !is_multicast_ether_addr(mac))
+		memcpy((char *)&key->mac_addr, (void *)mac, MAC_ADDR_LEN);
+
+	key->index = key_index;
+
+	key->len = params->key_len;
+	if (params->key && key->len)
+		memcpy(key->data, params->key, key->len);
+
+	key->seq_len = params->seq_len;
+	if (params->seq && key->seq_len)
+		memcpy(key->seq, params->seq, key->seq_len);
+
+	key->algo = wpa_cipher_to_alg(params->cipher);
+#if 0
+	if (key->algo == WIFI_WPA_ALG_NONE) {
+		printk(KERN_INFO "CIPHER NONE does not use pairwise keys");
+		return 0;
+	}
+#endif
+
+#if 0
+	printk(KERN_ERR "%s:%u algo: %u idx: %u seq_len: %u len:%u \n", __func__, __LINE__,
+			key->algo, key->index, key->seq_len, key->len);
+	PRINT_HEXDUMP("mac", key->mac_addr, 6, ESP_LOG_INFO);
+	PRINT_HEXDUMP("seq", key->seq, key->seq_len, ESP_LOG_INFO);
+	PRINT_HEXDUMP("key_data", key->data, key->len, ESP_LOG_INFO);
+#endif
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_init_interface(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_INIT_INTERFACE, cmd_len);
+
+	if (!cmd_node) {
+		printk(KERN_ERR "esp32: Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int cmd_deinit_interface(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter)
+		return -EINVAL;
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return\n", __func__, __LINE__);
+		return 0;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_DEINIT_INTERFACE, cmd_len);
+
+	if (!cmd_node) {
+		printk(KERN_ERR "esp32: Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+int internal_scan_request(struct esp_wifi_device *priv, char* ssid,
+		uint8_t channel, uint8_t is_blocking)
+{
+	int ret = 0;
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct scan_request *scan_req;
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (priv->scan_in_progress) {
+		printk(KERN_ERR "Scan in progress.. return\n");
+		return -EBUSY;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return", __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	cmd_len = sizeof(struct scan_request);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SCAN_REQUEST, cmd_len);
+
+	if (!cmd_node) {
+		printk(KERN_ERR "esp32: Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	scan_req = (struct scan_request *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+
+	if (ssid) {
+		memcpy(scan_req->ssid, ssid, MAX_SSID_LEN);
+	}
+
+	scan_req->channel = channel;
+
+	priv->scan_in_progress = true;
+
+	if (is_blocking)
+		priv->waiting_for_scan_done = true;
+
+	/* Enqueue command */
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	ret = wait_and_decode_cmd_resp(priv, cmd_node);
+
+	if (!ret && is_blocking) {
+		/* Wait for scan done */
+		wait_event_interruptible_timeout(priv->wait_for_scan_completion,
+				priv->waiting_for_scan_done != true, COMMAND_RESPONSE_TIMEOUT);
+	}
+
+	return ret;
+}
+
+int cmd_scan_request(struct esp_wifi_device *priv, struct cfg80211_scan_request *request)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+	struct scan_request *scan_req;
+
+	if (!priv || !priv->adapter || !request) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	if (test_bit(ESP_CLEANUP_IN_PROGRESS, &priv->adapter->state_flags)) {
+		printk(KERN_ERR "%s:%u cleanup in progress, return", __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	if (priv->scan_in_progress || priv->request) {
+		printk(KERN_ERR "Scan in progress.. return\n");
+		return -EBUSY;
+	}
+
+	cmd_len = sizeof(struct scan_request);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_SCAN_REQUEST, cmd_len);
+
+	if (!cmd_node) {
+		printk(KERN_ERR "esp32: Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	scan_req = (struct scan_request *) (cmd_node->cmd_skb->data +
+			sizeof(struct esp_payload_header));
+
+	/* TODO: Handle case of multiple SSIDs or channels */
+	if(request->ssids && request->ssids[0].ssid_len) {
+		memcpy(scan_req->ssid, request->ssids[0].ssid, MAX_SSID_LEN);
+	}
+
+#if 0
+	if (request->n_channels) {
+		chan = request->channels[0];
+		scan_req->channel = chan->hw_value;
+	}
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 8, 0)
+	scan_req->duration = request->duration;
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
+	memcpy(scan_req->bssid, request->bssid, MAC_ADDR_LEN);
+#endif
+
+	priv->scan_in_progress = true;
+	priv->request = request;
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+
+int cmd_get_mac(struct esp_wifi_device *priv)
+{
+	u16 cmd_len;
+	struct command_node *cmd_node = NULL;
+
+	if (!priv || !priv->adapter) {
+		printk(KERN_ERR "%s: Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	cmd_len = sizeof(struct command_header);
+
+	cmd_node = prepare_command_request(priv->adapter, CMD_GET_MAC, cmd_len);
+
+	if (!cmd_node) {
+		printk(KERN_ERR "esp32: Failed to get command node\n");
+		return -ENOMEM;
+	}
+
+	queue_cmd_node(priv->adapter, cmd_node, ESP_CMD_DFLT_PRIO);
+	queue_work(priv->adapter->cmd_wq, &priv->adapter->cmd_work);
+
+	RET_ON_FAIL(wait_and_decode_cmd_resp(priv, cmd_node));
+
+	return 0;
+}
+
+
+int esp_commands_teardown(struct esp_adapter *adapter)
+{
+#define MAX_DEINIT_RETRY 5
+	uint8_t iface_idx = 0;
+	struct esp_wifi_device *priv = NULL;
+
+    if (!adapter) {
+        return -EINVAL;
+	}
+
+	set_bit(ESP_CLEANUP_IN_PROGRESS, &adapter->state_flags);
+
+	if (!test_bit(ESP_CMD_INIT_DONE, &adapter->state_flags))
+		return 0;
+
+
+	for (iface_idx=0; iface_idx<ESP_MAX_INTERFACE; iface_idx++) {
+
+		priv = adapter->priv[iface_idx];
+
+		if (!priv)
+			continue;
+
+		esp_mark_scan_done_and_disconnect(priv, false);
+
+		esp_port_close(priv);
+	}
+
+    destroy_cmd_wq(adapter);
+    free_esp_cmd_pool(adapter);
+
+    return 0;
+}
+
+int esp_commands_setup(struct esp_adapter *adapter)
+{
+	if (!adapter) {
+		printk(KERN_ERR "esp32: %s failed\n", __func__);
+		return -EINVAL;
+	}
+
+	init_waitqueue_head(&adapter->wait_for_cmd_resp);
+
+	spin_lock_init(&adapter->cmd_lock);
+
+	INIT_LIST_HEAD(&adapter->cmd_pending_queue);
+	INIT_LIST_HEAD(&adapter->cmd_free_queue);
+
+	spin_lock_init(&adapter->cmd_pending_queue_lock);
+	spin_lock_init(&adapter->cmd_free_queue_lock);
+
+	RET_ON_FAIL(create_cmd_wq(adapter));
+
+	RET_ON_FAIL(alloc_esp_cmd_pool(adapter));
+
+	set_bit(ESP_CMD_INIT_DONE, &adapter->state_flags);
+	return 0;
+}
+
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_main.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_main.c
new file mode 100644
index 0000000..781e137
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_main.c
@@ -0,0 +1 @@
+df
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c
new file mode 100644
index 0000000..d50d595
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_stats.c
@@ -0,0 +1,211 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2022 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+
+#include "esp_stats.h"
+
+#if TEST_RAW_TP
+
+#include "esp_api.h"
+#include <linux/timer.h>
+
+static struct task_struct *raw_tp_tx_thread;
+static int test_raw_tp;
+static int test_raw_tp__host_to_esp;
+static struct timer_list log_raw_tp_stats_timer;
+static u8 log_raw_tp_stats_timer_running;
+static unsigned long test_raw_tp_len;
+static u32 raw_tp_timer_count;
+static u8 traffic_open_init_done;
+static struct completion traffic_open;
+
+static void log_raw_tp_stats_timer_cb(struct timer_list *timer)
+{
+	unsigned long actual_bandwidth = 0;
+
+	mod_timer(&log_raw_tp_stats_timer, jiffies + msecs_to_jiffies(1000));
+	actual_bandwidth = (test_raw_tp_len*8)/1024;
+	printk(KERN_INFO "%u-%u sec       %lu kbits/sec\n\r",
+			raw_tp_timer_count,
+			raw_tp_timer_count + 1, actual_bandwidth);
+
+	raw_tp_timer_count++;
+	test_raw_tp_len = 0;
+}
+
+static int raw_tp_tx_process(void *data)
+{
+	int ret = 0;
+	struct sk_buff *tx_skb = NULL;
+	struct esp_payload_header *payload_header = NULL;
+	struct esp_adapter *adapter = NULL;
+	struct esp_wifi_device *priv = NULL;
+	struct esp_skb_cb *cb = NULL;
+	u8 pad_len = 0;
+	u16 total_len = 0;
+
+	pad_len = sizeof(struct esp_payload_header);
+	total_len = TEST_RAW_TP__BUF_SIZE + pad_len;
+	pad_len += SKB_DATA_ADDR_ALIGNMENT - (total_len % SKB_DATA_ADDR_ALIGNMENT);
+
+	msleep(2000);
+	adapter = esp_get_adapter();
+	priv = adapter->priv[0];
+
+	while (!kthread_should_stop()) {
+
+		if (esp_is_tx_queue_paused(priv)) {
+
+			tx_skb = esp_alloc_skb(TEST_RAW_TP__BUF_SIZE);
+			if (!tx_skb) {
+				printk(KERN_INFO "%s:%u esp_alloc_skb failed\n",__func__,__LINE__);
+				msleep(10);
+				continue;
+			}
+			memset(tx_skb->data, 0, TEST_RAW_TP__BUF_SIZE);
+			tx_skb->len = TEST_RAW_TP__BUF_SIZE;
+			cb = (struct esp_skb_cb *) tx_skb->cb;
+			cb->priv = priv;
+
+			payload_header = (struct esp_payload_header *) tx_skb->data;
+			memset(payload_header, 0, pad_len);
+
+			payload_header->if_type = ESP_TEST_IF;
+			payload_header->if_num = 0;
+			payload_header->len = cpu_to_le16(TEST_RAW_TP__BUF_SIZE);
+			payload_header->offset = cpu_to_le16(pad_len);
+
+			if (adapter->capabilities & ESP_CHECKSUM_ENABLED) {
+				payload_header->checksum =
+					cpu_to_le16(compute_checksum(tx_skb->data,
+								(TEST_RAW_TP__BUF_SIZE + pad_len)));
+			}
+			ret = esp_send_packet(esp_get_adapter(), tx_skb);
+			if(!ret)
+				test_raw_tp_len += TEST_RAW_TP__BUF_SIZE;
+
+		} else {
+			if (traffic_open_init_done)
+				wait_for_completion_interruptible(&traffic_open);
+		}
+	}
+	printk(KERN_INFO "esp32: raw tp tx thrd stopped\n");
+	return 0;
+}
+
+static void process_raw_tp_flags(void)
+{
+	test_raw_tp_cleanup();
+
+	if (test_raw_tp) {
+
+		timer_setup(&log_raw_tp_stats_timer, log_raw_tp_stats_timer_cb, 0);
+		mod_timer(&log_raw_tp_stats_timer, jiffies + msecs_to_jiffies(1000));
+		log_raw_tp_stats_timer_running = 1;
+
+		if (test_raw_tp__host_to_esp) {
+
+			raw_tp_tx_thread = kthread_run(raw_tp_tx_process, NULL, "raw tp thrd");
+			if (!raw_tp_tx_thread)
+				printk(KERN_ERR "Failed to create send traffic thread\n");
+
+		}
+		if (!traffic_open_init_done) {
+			init_completion(&traffic_open);
+			traffic_open_init_done = 1;
+		}
+	}
+}
+
+
+static void start_test_raw_tp(int raw_tp__host_to_esp)
+{
+	test_raw_tp = 1;
+	test_raw_tp__host_to_esp = raw_tp__host_to_esp;
+}
+
+static void stop_test_raw_tp(void)
+{
+	test_raw_tp = 0;
+	test_raw_tp__host_to_esp = 0;
+}
+
+inline void esp_raw_tp_queue_resume(void)
+{
+	if (traffic_open_init_done)
+		if (!completion_done(&traffic_open))
+			complete_all(&traffic_open);
+}
+
+void test_raw_tp_cleanup(void)
+{
+	int ret = 0;
+
+	if (log_raw_tp_stats_timer_running) {
+		ret = del_timer(&log_raw_tp_stats_timer);
+		if (!ret) {
+			log_raw_tp_stats_timer_running = 0;
+		}
+		raw_tp_timer_count = 0;
+	}
+
+	if (traffic_open_init_done)
+		if (!completion_done(&traffic_open))
+			complete_all(&traffic_open);
+
+	if (raw_tp_tx_thread) {
+		ret = kthread_stop(raw_tp_tx_thread);
+		if(ret) {
+			msleep(10);
+			ret = kthread_stop(raw_tp_tx_thread);
+		}
+		if (ret)
+			printk(KERN_ERR "Kthread stop error\n");
+
+		raw_tp_tx_thread = 0;
+	}
+}
+
+void update_test_raw_tp_rx_stats(u16 len)
+{
+	/* if traffic dir is esp to host, increment stats */
+	if (!test_raw_tp__host_to_esp)
+		test_raw_tp_len += len;
+}
+#endif
+
+void process_test_capabilities(u8 cap)
+{
+#if TEST_RAW_TP
+	printk(KERN_INFO "ESP peripheral test capabilities: 0x%x\n", cap);
+	if ((cap & ESP_TEST_RAW_TP) == ESP_TEST_RAW_TP) {
+		if ((cap & ESP_TEST_RAW_TP__ESP_TO_HOST) == ESP_TEST_RAW_TP__ESP_TO_HOST) {
+			start_test_raw_tp(ESP_TEST_RAW_TP__RX);
+			printk(KERN_INFO "esp32: start testing of ESP->Host raw throughput\n");
+		} else {
+			start_test_raw_tp(ESP_TEST_RAW_TP__TX);
+			printk(KERN_INFO "esp32: start testing of Host->ESP raw throughput\n");
+		}
+	} else {
+		printk(KERN_INFO "esp32: stop raw throuput test if running\n");
+		stop_test_raw_tp();
+	}
+	process_raw_tp_flags();
+#endif
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/esp_wpa_utils.c b/drivers/net/wireless/espressif/esp_hosted_ng/esp_wpa_utils.c
new file mode 100644
index 0000000..dcbc69e
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/esp_wpa_utils.c
@@ -0,0 +1,75 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include "esp_wpa_utils.h"
+
+
+int wpa_cipher_to_alg(int cipher)
+{
+    switch (cipher) {
+    case WLAN_CIPHER_SUITE_CCMP :
+        return WIFI_WPA_ALG_CCMP;
+#ifdef CONFIG_GCMP
+    case WLAN_CIPHER_SUITE_GCMP_256:
+    case WLAN_CIPHER_SUITE_GCMP:
+        return WIFI_WPA_ALG_GCMP;
+#endif
+    case WLAN_CIPHER_SUITE_TKIP:
+        return WIFI_WPA_ALG_TKIP;
+    case WLAN_CIPHER_SUITE_WEP104:
+        return WIFI_WPA_ALG_WEP104;
+	case WLAN_CIPHER_SUITE_WEP40:
+		return WIFI_WPA_ALG_WEP40;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		return WIFI_WPA_ALG_IGTK;
+
+    }
+    return WIFI_WPA_ALG_NONE;
+}
+
+int wpa_cipher_key_len(int cipher)
+{
+    switch (cipher) {
+    case WLAN_CIPHER_SUITE_TKIP:
+#ifdef CONFIG_GCMP
+    case WLAN_CIPHER_GCMP_SUITE_256:
+#endif
+#ifdef CONFIG_GMAC
+    case WLAN_CIPHER_BIP_GMAC_SUITE_256:
+#endif
+        return 32;
+    case WLAN_CIPHER_SUITE_CCMP:
+#ifdef CONFIG_GCMP
+    case WLAN_CIPHER_SUITE_GCMP:
+#endif
+#ifdef CONFIG_GMAC
+    case WLAN_CIPHER_SUITE_BIP_GMAC_128:
+#endif
+#if 0
+    case WLAN_CIPHER_SUITE_AES_128_CMAC:
+        return 16;
+#endif
+    case WLAN_CIPHER_SUITE_WEP104:
+        return 13;
+    case WLAN_CIPHER_SUITE_WEP40:
+        return 5;
+    }
+
+    return 0;
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h
new file mode 100644
index 0000000..ff08249
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/adapter.h
@@ -0,0 +1,310 @@
+// Copyright 2015-2021 Espressif Systems (Shanghai) PTE LTD
+/* SPDX-License-Identifier: GPL-2.0 OR Apache-2.0 */
+
+#ifndef __ESP_NETWORK_ADAPTER__H
+#define __ESP_NETWORK_ADAPTER__H
+
+#define PRIO_Q_HIGH                     0
+#define PRIO_Q_MID                      1
+#define PRIO_Q_LOW                      2
+#define MAX_PRIORITY_QUEUES             3
+#define MAC_ADDR_LEN                    6
+#define MAX_KEY_LEN                     32
+#define MAX_SEQ_LEN                     10
+#define ESP_MAX_KEY_INDEX               0
+
+/* ESP Payload Header Flags */
+#define MORE_FRAGMENT                   (1 << 0)
+#define MAX_SSID_LEN                    32
+
+#define MAX_MULTICAST_ADDR_COUNT        8
+
+struct esp_payload_header {
+	uint8_t          if_type:4;
+	uint8_t          if_num:4;
+	uint8_t          flags;
+	uint8_t          packet_type;
+	uint8_t          reserved1;
+	uint16_t         len;
+	uint16_t         offset;
+	uint16_t         checksum;
+	uint8_t          reserved2;
+	/* Position of union field has to always be last,
+	 * this is required for hci_pkt_type */
+	union {
+		uint8_t      reserved3;
+		uint8_t      hci_pkt_type;    /* Packet type for HCI interface */
+		uint8_t      priv_pkt_type;   /* Packet type for priv interface */
+	};
+	/* Do no add anything here */
+} __attribute__((packed));
+
+struct ieee_mgmt_header {
+	uint16_t   frame_control;
+	uint16_t   dur;
+	uint8_t    da[MAC_ADDR_LEN];
+	uint8_t    sa[MAC_ADDR_LEN];
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint16_t   seq_ctrl;
+}__attribute__((packed));
+
+enum ESP_INTERFACE_TYPE{
+	ESP_STA_IF,
+	ESP_AP_IF,
+	ESP_HCI_IF,
+	ESP_INTERNAL_IF,
+	ESP_TEST_IF,
+	ESP_MAX_IF,
+};
+
+enum ESP_PACKET_TYPE {
+	PACKET_TYPE_DATA,
+	PACKET_TYPE_COMMAND_REQUEST,
+	PACKET_TYPE_COMMAND_RESPONSE,
+	PACKET_TYPE_EVENT,
+	PACKET_TYPE_EAPOL,
+};
+
+enum ESP_HOST_INTERRUPT {
+	ESP_OPEN_DATA_PATH,
+	ESP_CLOSE_DATA_PATH,
+	ESP_RESET,
+	ESP_POWER_SAVE_ON,
+	ESP_POWER_SAVE_OFF,
+};
+
+enum ESP_CAPABILITIES {
+	ESP_WLAN_SDIO_SUPPORT = (1 << 0),
+	ESP_BT_UART_SUPPORT = (1 << 1),
+	ESP_BT_SDIO_SUPPORT = (1 << 2),
+	ESP_BLE_ONLY_SUPPORT = (1 << 3),
+	ESP_BR_EDR_ONLY_SUPPORT = (1 << 4),
+	ESP_WLAN_SPI_SUPPORT = (1 << 5),
+	ESP_BT_SPI_SUPPORT = (1 << 6),
+	ESP_CHECKSUM_ENABLED = (1 << 7),
+};
+
+typedef enum {
+	ESP_TEST_RAW_TP = (1 << 0),
+	ESP_TEST_RAW_TP__ESP_TO_HOST = (1 << 1)
+} ESP_RAW_TP_MEASUREMENT;
+
+enum ESP_INTERNAL_MSG {
+	ESP_INTERNAL_BOOTUP_EVENT = 1,
+};
+
+enum ESP_BOOTUP_TAG_TYPE {
+	ESP_BOOTUP_CAPABILITY,
+	ESP_BOOTUP_FW_DATA,
+	ESP_BOOTUP_SPI_CLK_MHZ,
+	ESP_BOOTUP_FIRMWARE_CHIP_ID,
+	ESP_BOOTUP_TEST_RAW_TP,
+};
+
+enum COMMAND_CODE {
+	CMD_INIT_INTERFACE = 1,
+	CMD_SET_MAC,
+	CMD_GET_MAC,
+	CMD_SCAN_REQUEST,
+	CMD_STA_CONNECT,
+	CMD_STA_DISCONNECT,
+	CMD_DEINIT_INTERFACE,
+	CMD_ADD_KEY,
+	CMD_DEL_KEY,
+	CMD_SET_DEFAULT_KEY,
+	CMD_STA_AUTH,
+	CMD_STA_ASSOC,
+	CMD_SET_IP_ADDR,
+	CMD_SET_MCAST_MAC_ADDR,
+	CMD_MAX,
+};
+
+enum EVENT_CODE {
+	EVENT_SCAN_RESULT = 1,
+	EVENT_STA_CONNECT,
+	EVENT_STA_DISCONNECT,
+	EVENT_AUTH_RX,
+	EVENT_ASSOC_RX,
+};
+
+enum COMMAND_RESPONSE_TYPE {
+	CMD_RESPONSE_PENDING,
+	CMD_RESPONSE_FAIL,
+	CMD_RESPONSE_SUCCESS,
+	CMD_RESPONSE_BUSY,
+	CMD_RESPONSE_UNSUPPORTED,
+	CMD_RESPONSE_INVALID,
+};
+
+struct command_header {
+	uint8_t    cmd_code;
+	uint8_t    cmd_status;
+	uint16_t   len;
+	uint16_t   seq_num;
+	uint8_t    reserved1;
+	uint8_t    reserved2;
+}__attribute__((packed));
+
+struct scan_request {
+	struct     command_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint16_t   duration;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    channel;
+	uint8_t    pad[2];
+}__attribute__((packed));
+
+struct cmd_config_mac_address {
+	struct     command_header header;
+	uint8_t    mac_addr[MAC_ADDR_LEN];
+	uint8_t    pad[2];
+}__attribute__((packed));
+
+struct cmd_sta_auth {
+	struct     command_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    channel;
+	uint8_t    auth_type;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    auth_data_len;
+	uint8_t    pad[2];
+	uint8_t    auth_data[];
+}__attribute__((packed));
+
+struct cmd_sta_assoc {
+	struct     command_header header;
+	uint8_t    assoc_ie_len;
+	uint8_t    pad[3];
+	uint8_t    assoc_ie[];
+}__attribute__((packed));
+
+struct cmd_sta_connect {
+	struct     command_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint16_t   assoc_flags;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    channel;
+	uint8_t    is_auth_open;
+	uint8_t    assoc_ie_len;
+	uint8_t    assoc_ie[];
+}__attribute__((packed));
+
+struct cmd_sta_disconnect {
+	struct     command_header header;
+	uint16_t   reason_code;
+	uint8_t    pad[2];
+}__attribute__((packed));
+
+struct cmd_set_ip_addr {
+	struct command_header header;
+	uint32_t ip;
+}__attribute__((packed));
+
+struct cmd_set_mcast_mac_addr {
+	struct command_header header;
+	uint8_t count;
+	uint8_t mcast_addr[MAX_MULTICAST_ADDR_COUNT][MAC_ADDR_LEN];
+}__attribute__((packed));
+
+struct wifi_sec_key {
+	uint32_t   algo;
+	uint32_t   index;
+	uint8_t    data[MAX_KEY_LEN];
+	uint32_t   len;
+	uint8_t    mac_addr[MAC_ADDR_LEN];
+	uint8_t    seq[MAX_SEQ_LEN];
+	uint32_t   seq_len;
+	uint8_t    del;
+	uint8_t    set_cur;
+	uint8_t    pad[2];
+}__attribute__((packed));
+
+struct cmd_key_operation {
+	struct     command_header header;
+	struct     wifi_sec_key key;
+}__attribute__((packed));
+
+struct event_header {
+	uint8_t    event_code;
+	uint8_t    status;
+	uint16_t   len;
+}__attribute__((packed));
+
+struct scan_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    frame_type;
+	uint8_t    channel;
+	uint32_t   rssi;
+	uint64_t   tsf;
+	uint16_t   frame_len;
+	uint8_t    pad[2];
+	uint8_t    frame[0];
+}__attribute__((packed));
+
+struct auth_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    frame_type;
+	uint8_t    channel;
+	uint32_t   rssi;
+	uint64_t   tsf;
+	uint16_t   frame_len;
+	uint8_t    pad[2];
+	uint8_t    frame[0];
+}__attribute__((packed));
+
+struct assoc_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	uint8_t    frame_type;
+	uint8_t    channel;
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    pad[1];
+	uint16_t   frame_len;
+	uint32_t   rssi;
+	uint64_t   tsf;
+	uint8_t    frame[0];
+}__attribute__((packed));
+
+struct disconnect_event {
+	struct     event_header header;
+	uint8_t    bssid[MAC_ADDR_LEN];
+	char       ssid[MAX_SSID_LEN+1];
+	uint8_t    reason;
+}__attribute__((packed));
+
+struct esp_internal_bootup_event {
+	struct     event_header header;
+	uint8_t    len;
+	uint8_t    pad[3];
+	uint8_t    data[0];
+}__attribute__((packed));
+
+struct fw_version {
+	uint8_t    major1;
+	uint8_t    major2;
+	uint8_t    minor;
+}__attribute__((packed));
+
+struct fw_data {
+	struct     fw_version version;
+	uint32_t   last_reset_reason;
+}__attribute__((packed));
+
+
+
+static inline uint16_t compute_checksum(uint8_t *buf, uint16_t len)
+{
+	uint16_t checksum = 0;
+	uint16_t i = 0;
+
+	while(i < len) {
+		checksum += buf[i];
+		i++;
+	}
+
+	return checksum;
+}
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h
new file mode 100644
index 0000000..9cb9d25
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp.h
@@ -0,0 +1,174 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef __esp__h_
+#define __esp__h_
+
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/spinlock.h>
+#include <net/cfg80211.h>
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include "adapter.h"
+
+#define ESP_IF_TYPE_SDIO        1
+#define ESP_IF_TYPE_SPI         2
+
+/* Network link status */
+#define ESP_LINK_DOWN           0
+#define ESP_LINK_UP             1
+
+#define ESP_MAX_INTERFACE       1
+//#define ESP_MAX_INTERFACE       2
+#define ESP_STA_NW_IF           0
+#define ESP_AP_NW_IF            1
+
+/* ESP in sdkconfig has CONFIG_IDF_FIRMWARE_CHIP_ID entry.
+ * supported values of CONFIG_IDF_FIRMWARE_CHIP_ID are - */
+enum chipset_type_e {
+	ESP_FIRMWARE_CHIP_UNRECOGNIZED = 0xff,
+	ESP_FIRMWARE_CHIP_ESP32 = 0x0,
+	ESP_FIRMWARE_CHIP_ESP32S2 = 0x2,
+	ESP_FIRMWARE_CHIP_ESP32C3 = 0x5,
+	ESP_FIRMWARE_CHIP_ESP32S3 = 0x9,
+};
+
+#define ESP_PAYLOAD_HEADER      8
+struct esp_private;
+struct esp_adapter;
+
+#define ACQUIRE_LOCK            1
+#define LOCK_ALREADY_ACQUIRED   0
+
+#define SKB_DATA_ADDR_ALIGNMENT 4
+#define INTERFACE_HEADER_PADDING (SKB_DATA_ADDR_ALIGNMENT*3)
+
+enum adapter_flags_e {
+	ESP_CLEANUP_IN_PROGRESS,    /* Driver unloading or ESP reseted */
+	ESP_CMD_INIT_DONE,          /* Cmd component is initialized with esp_commands_setup() */
+	ESP_DRIVER_ACTIVE,          /* kernel module __exit is not yet invoked */
+};
+
+enum priv_flags_e {
+	ESP_NETWORK_UP,
+};
+
+struct command_node {
+	struct list_head list;
+	uint8_t cmd_code;
+	struct sk_buff *cmd_skb;
+	struct sk_buff *resp_skb;
+};
+
+struct esp_adapter {
+	struct device           *dev;
+	struct wiphy            *wiphy;
+
+	uint8_t                 if_type;
+	uint32_t                capabilities;
+
+	/* Possible types:
+	 * struct esp_sdio_context */
+	void                    *if_context;
+
+	struct esp_if_ops       *if_ops;
+
+	/* Private for each interface */
+	struct esp_wifi_device  *priv[ESP_MAX_INTERFACE];
+	struct hci_dev          *hcidev;
+
+	struct workqueue_struct *if_rx_workqueue;
+	struct work_struct      if_rx_work;
+
+	wait_queue_head_t       wait_for_cmd_resp;
+	uint8_t                 cmd_resp;
+
+	/* wpa supplicant commands structures */
+	struct command_node     *cmd_pool;
+	struct list_head        cmd_free_queue;
+	spinlock_t              cmd_free_queue_lock;
+	struct list_head        cmd_pending_queue;
+	spinlock_t              cmd_pending_queue_lock;
+
+	struct command_node     *cur_cmd;
+	spinlock_t              cmd_lock;
+
+	struct workqueue_struct *mac_filter_wq;
+	struct work_struct      mac_flter_work;
+
+	struct workqueue_struct *cmd_wq;
+	struct work_struct      cmd_work;
+
+	struct sk_buff_head     events_skb_q;
+	struct workqueue_struct *events_wq;
+	struct work_struct      events_work;
+
+	unsigned long           state_flags;
+};
+
+struct esp_device {
+	struct device           *dev;
+	struct wiphy            *wiphy;
+	struct esp_adapter      *adapter;
+};
+
+struct esp_wifi_device {
+	struct wireless_dev     wdev;
+	struct net_device       *ndev;
+	struct esp_device       *esp_dev;
+	struct esp_adapter      *adapter;
+
+	struct net_device_stats stats;
+	uint8_t                 mac_address[MAC_ADDR_LEN];
+	uint8_t                 if_type;
+	uint8_t                 if_num;
+
+	uint32_t                ssid_len;
+	uint8_t                 ssid[32];
+
+	/* This is needed to notify scan completion*/
+	struct cfg80211_scan_request *request;
+	struct cfg80211_bss     *bss;
+	uint8_t                 *assoc_req_ie;
+	size_t                  assoc_req_ie_len;
+
+	uint8_t                 scan_in_progress;
+	uint8_t                 waiting_for_scan_done;
+
+	uint8_t                 link_state;
+
+	volatile uint8_t        stop_data;
+	volatile uint8_t        port_open;
+
+	uint8_t                 pad[3];
+	wait_queue_head_t       wait_for_scan_completion;
+	unsigned long           priv_flags;
+	struct notifier_block   nb;
+};
+
+
+struct esp_skb_cb {
+	struct esp_wifi_device      *priv;
+};
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h
new file mode 100644
index 0000000..4af1484
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_api.h
@@ -0,0 +1,54 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _esp_api__h_
+#define _esp_api__h_
+
+#include "esp.h"
+
+#define RET_ON_FAIL(x)                                   \
+	do {                                                 \
+		int ret = (x);                                   \
+        if (!!(ret)) {                                   \
+            printk(KERN_ERR "esp32: %s failure, ret: %d\n", #x, ret);  \
+            return ret;                                  \
+        }                                                \
+	} while(0);                                          \
+
+int esp_add_card(struct esp_adapter *adapter);
+int esp_remove_card(struct esp_adapter *adapter);
+void esp_process_new_packet_intr(struct esp_adapter *adapter);
+struct esp_adapter * esp_get_adapter(void);
+struct esp_wifi_device * get_priv_from_payload_header(struct esp_payload_header *header);
+struct sk_buff * esp_alloc_skb(u32 len);
+int esp_send_packet(struct esp_adapter *adapter, struct sk_buff *skb);
+u8 esp_is_bt_supported_over_sdio(u32 cap);
+void esp_tx_pause(struct esp_wifi_device *priv);
+void esp_tx_resume(struct esp_wifi_device *priv);
+void process_event_esp_bootup(struct esp_adapter *adapter, u8 *evt_buf, u8 len);
+int process_fw_data(struct fw_data *fw_p);
+void esp_init_priv(struct net_device *ndev);
+void esp_port_open(struct esp_wifi_device * priv);
+void esp_port_close(struct esp_wifi_device * priv);
+void esp_remove_network_interfaces(struct esp_adapter *adapter);
+void print_capabilities(u32 cap);
+void process_capabilities(struct esp_adapter *adapter);
+void process_test_capabilities(u8 cap);
+int esp_is_tx_queue_paused(struct esp_wifi_device *priv);
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h
new file mode 100644
index 0000000..7f172fe
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_bt_api.h
@@ -0,0 +1,48 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef __esp_bt_api_h_
+#define __esp_bt_api_h_
+
+#include <linux/version.h>
+#include "esp.h"
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+		#define hci_skb_pkt_type(skb) bt_cb((skb))->pkt_type
+	#else
+        #error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+	#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+		#define HCI_PRIMARY HCI_BREDR
+	#else
+        #error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+	#endif
+#endif
+
+int esp_init_bt(struct esp_adapter *adapter);
+int esp_deinit_bt(struct esp_adapter *adapter);
+void esp_hci_update_tx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len);
+void esp_hci_update_rx_counter(struct hci_dev *hdev, u8 pkt_type, size_t len);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h
new file mode 100644
index 0000000..fe052e7
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cfg80211.h
@@ -0,0 +1,37 @@
+#ifndef __esp_cfg80211_h_
+#define __esp_cfg80211_h_
+
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/version.h>
+
+struct wireless_dev *esp_cfg80211_add_iface(struct wiphy *wiphy,
+                              const char *name,
+                              unsigned char name_assign_type,
+                              enum nl80211_iftype type,
+                              struct vif_params *params);
+int esp_cfg80211_register(struct esp_adapter *adapter);
+
+int esp_mark_disconnect(struct esp_wifi_device *priv, uint16_t reason,
+		uint8_t locally_disconnect);
+int esp_mark_scan_done_and_disconnect(struct esp_wifi_device *priv,
+		uint8_t locally_disconnect);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h
new file mode 100644
index 0000000..ecd6246
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_cmd.h
@@ -0,0 +1,62 @@
+#ifndef __esp_cmd_h_
+#define __esp_cmd_h_
+
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include "esp.h"
+
+#define ESP_NUM_OF_CMD_NODES 20
+#define ESP_SIZE_OF_CMD_NODE 2048
+
+#define ESP_CMD_HIGH_PRIO    1
+#define ESP_CMD_DFLT_PRIO    0
+
+struct multicast_list
+{
+	struct esp_wifi_device *priv;
+	u8 addr_count;
+	u8 mcast_addr[MAX_MULTICAST_ADDR_COUNT][MAC_ADDR_LEN];
+};
+
+
+int esp_commands_setup(struct esp_adapter *adapter);
+int esp_commands_teardown(struct esp_adapter *adapter);
+int cmd_init_interface(struct esp_wifi_device *priv);
+int cmd_deinit_interface(struct esp_wifi_device *priv);
+int process_cmd_resp(struct esp_adapter *adapter, struct sk_buff *skb);
+int cmd_scan_request(struct esp_wifi_device *priv,
+		struct cfg80211_scan_request *request);
+int cmd_get_mac(struct esp_wifi_device *priv);
+int process_cmd_event(struct esp_wifi_device *priv, struct sk_buff *skb);
+int cmd_connect_request(struct esp_wifi_device *priv,
+		struct cfg80211_connect_params *params);
+int cmd_auth_request(struct esp_wifi_device *priv,
+		struct cfg80211_auth_request *req);
+int cmd_assoc_request(struct esp_wifi_device *priv,
+		struct cfg80211_assoc_request *req);
+int cmd_disconnect_request(struct esp_wifi_device *priv, u16 reason_code);
+int cmd_add_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr, struct key_params *params);
+int cmd_del_key(struct esp_wifi_device *priv, u8 key_index, bool pairwise,
+		const u8 *mac_addr);
+int cmd_set_default_key(struct esp_wifi_device *priv, u8 key_index);
+int cmd_set_ip_address(struct esp_wifi_device *priv, u32 ip);
+int cmd_set_mcast_mac_list(struct esp_wifi_device *priv, struct multicast_list *list);
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h
new file mode 100644
index 0000000..53ff7b7
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_if.h
@@ -0,0 +1,35 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef __ESP_IF__H_
+#define __ESP_IF__H_
+
+#include "esp.h"
+
+struct esp_if_ops {
+	int (*init)(struct esp_adapter *adapter);
+	struct sk_buff* (*read)(struct esp_adapter *adapter);
+	int (*write)(struct esp_adapter *adapter, struct sk_buff *skb);
+	int (*deinit)(struct esp_adapter *adapter);
+};
+
+int esp_init_interface_layer(struct esp_adapter *adapter);
+void esp_deinit_interface_layer(void);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h
new file mode 100644
index 0000000..42d730a
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_kernel_port.h
@@ -0,0 +1,244 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _esp_kernel_port__h_
+#define _esp_kernel_port__h_
+
+#include "esp.h"
+#include <net/cfg80211.h>
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
+    #define ESP_BT_SEND_FRAME_PROTOTYPE() \
+        int esp_bt_send_frame(struct sk_buff *skb)
+#else
+    #define ESP_BT_SEND_FRAME_PROTOTYPE() \
+        int esp_bt_send_frame(struct hci_dev* hdev, struct sk_buff *skb)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0)
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+  #define ESP_MGMT_TX_PROTOTYPE()                                              \
+    int esp_cfg80211_mgmt_tx(struct wiphy *wiphy,                              \
+            struct wireless_dev *wdev, struct ieee80211_channel *chan,         \
+            bool offchan, unsigned int wait, const u8 *buf, size_t len,        \
+            bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+#else
+  #define ESP_MGMT_TX_PROTOTYPE()                                              \
+    int esp_cfg80211_mgmt_tx(struct wiphy *wiphy,                              \
+            struct wireless_dev *wdev, struct cfg80211_mgmt_tx_params *params, \
+            u64 *cookie)
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
+  #define ALLOC_NETDEV(size, name, type, setup) \
+    alloc_netdev(size, name, setup)
+#else
+  #define ALLOC_NETDEV(size, name, type, setup) \
+    alloc_netdev(size, name, type, setup)
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0)
+  #define CFG80211_INFORM_BSS(wiphy, chan, bssid, tsf, \
+          cap, beacon_interval, ie, ielen, sig, gfp) \
+  cfg80211_inform_bss(wiphy, chan, bssid, tsf, \
+          cap, beacon_interval, ie, ielen, sig, gfp)
+#else
+  #define CFG80211_INFORM_BSS(wiphy, chan, bssid, tsf, \
+          cap, beacon_interval, ie, ielen, signal, gfp) \
+  cfg80211_inform_bss(wiphy, chan, CFG80211_BSS_FTYPE_UNKNOWN, bssid, tsf, \
+          cap, beacon_interval, ie, ielen, signal, gfp)
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0)
+enum ieee80211_bss_type {
+	IEEE80211_BSS_TYPE_ESS,
+	IEEE80211_BSS_TYPE_PBSS,
+	IEEE80211_BSS_TYPE_IBSS,
+	IEEE80211_BSS_TYPE_MBSS,
+	IEEE80211_BSS_TYPE_ANY
+};
+
+enum ieee80211_privacy {
+	IEEE80211_PRIVACY_ON,
+	IEEE80211_PRIVACY_OFF,
+	IEEE80211_PRIVACY_ANY
+};
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+  #define CFG80211_DISCONNECTED(dev, reason, ie, ie_len, locally_generated, gfp) \
+    cfg80211_disconnected(dev, reason, ie, ie_len, gfp)
+
+#else
+  #define CFG80211_DISCONNECTED(dev, reason, ie, ie_len, locally_generated, gfp) \
+      cfg80211_disconnected(dev, reason, ie, ie_len, locally_generated, gfp)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
+    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+        #define hci_skb_pkt_type(skb) bt_cb((skb))->pkt_type
+    #else
+        #error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+    #endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
+    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34))
+        #define HCI_PRIMARY HCI_BREDR
+    #else
+        #error "ESP-Hosted solution doesn't supported below kernel version < 2.6.34"
+    #endif
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+
+    #define ESP_MARK_SCAN_DONE(PrIv, abort) do {                               \
+                                                                               \
+        if (PrIv->request) {                                                   \
+            cfg80211_scan_done(PrIv->request, abort);                          \
+            PrIv->request = NULL;                                              \
+        }                                                                      \
+                                                                               \
+        PrIv->scan_in_progress = false;                                        \
+                                                                               \
+    } while(0);
+
+#else
+
+    #define ESP_MARK_SCAN_DONE(PrIv, abort) do {                               \
+                                                                               \
+        struct cfg80211_scan_info info = {                                     \
+            .aborted = abort,                                                  \
+        };                                                                     \
+                                                                               \
+        if (PrIv->request) {                                                   \
+            cfg80211_scan_done(PrIv->request, &info);                          \
+            PrIv->request = NULL;                                              \
+        }                                                                      \
+                                                                               \
+        PrIv->scan_in_progress = false;                                        \
+                                                                               \
+    } while(0);
+
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+    #define ESP_CANCEL_SCHED_SCAN() cfg80211_sched_scan_stopped(priv->wdev.wiphy, 0);
+#else
+    #define ESP_CANCEL_SCHED_SCAN() cfg80211_sched_scan_stopped(priv->wdev.wiphy);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0)
+static inline void *skb_put_data(struct sk_buff *skb, const void *data,
+				 unsigned int len)
+{
+	void *tmp = skb_put(skb, len);
+
+	memcpy(tmp, data, len);
+
+	return tmp;
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
+    #define NDO_TX_TIMEOUT_PROTOTYPE() \
+        void esp_tx_timeout(struct net_device *ndev)
+#else
+    #define NDO_TX_TIMEOUT_PROTOTYPE() \
+        void esp_tx_timeout(struct net_device *ndev, unsigned int txqueue)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+#define do_exit(code)	kthread_complete_and_exit(NULL, code)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0))
+#define NETIF_RX_NI(skb)	netif_rx(skb)
+#else
+#define NETIF_RX_NI(skb)	netif_rx_ni(skb)
+#endif
+
+static inline
+void CFG80211_RX_ASSOC_RESP(struct net_device *dev,
+			    struct cfg80211_bss *bss,
+			    const u8 *buf, size_t len,
+			    int uapsd_queues,
+			    const u8 *req_ies, size_t req_ies_len)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	struct cfg80211_rx_assoc_resp resp = {0};
+
+	resp.links[0].bss = bss;
+	resp.buf = (u8 *)buf;
+	resp.len =  len;
+	resp.req_ies = req_ies;
+	resp.uapsd_queues = uapsd_queues;
+	resp.req_ies_len = req_ies_len;
+
+	cfg80211_rx_assoc_resp(dev, &resp);
+#else
+	cfg80211_rx_assoc_resp(dev, bss, buf, len, uapsd_queues, req_ies, req_ies_len)
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+static inline bool wireless_dev_current_bss_exists(struct wireless_dev *wdev)
+{
+	if (wdev->links[0].client.current_bss)
+		return true;
+	return false;
+}
+#define INT_LINK_ID int link_id,
+#define ZERO_LINK_ID 0,
+#else
+static inline bool wireless_dev_current_bss_exists(struct wireless_dev *wdev)
+{
+	if (wdev->current_bss)
+		return true;
+	return false;
+}
+#define INT_LINK_ID
+#define ZERO_LINK_ID
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0))
+static inline void eth_hw_addr_set(struct net_device *dev, const u8 *addr)
+{
+	ether_addr_copy(dev->dev_addr, addr, ETH_ALEN);
+}
+#endif
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h
new file mode 100644
index 0000000..994c7cc
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_stats.h
@@ -0,0 +1,44 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef __ESP_STAT__H__
+#define __ESP_STAT__H__
+
+#include "esp.h"
+
+#ifdef CONFIG_ESP_HOSTED_NG_TEST_RAW_TP
+#define TEST_RAW_TP 1
+#else
+#define TEST_RAW_TP 0
+#endif
+
+#if TEST_RAW_TP
+
+#define TEST_RAW_TP__BUF_SIZE    1460
+
+#define ESP_TEST_RAW_TP__RX      0
+#define ESP_TEST_RAW_TP__TX      1
+
+inline void esp_raw_tp_queue_resume(void);
+#endif
+
+void test_raw_tp_cleanup(void);
+void update_test_raw_tp_rx_stats(u16 len);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_wpa_utils.h b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_wpa_utils.h
new file mode 100644
index 0000000..9991b4d
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/include/esp_wpa_utils.h
@@ -0,0 +1,53 @@
+#ifndef __esp_wpa_utils_h_
+#define __esp_wpa_utils_h_
+
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include "esp.h"
+
+#define WPA_CIPHER_NONE                 BIT(0)
+#define WPA_CIPHER_WEP40                BIT(7)
+#define WPA_CIPHER_WEP104               BIT(8)
+#define WPA_CIPHER_TKIP                 BIT(1)
+#define WPA_CIPHER_CCMP                 BIT(3)
+#define WPA_CIPHER_AES_128_CMAC         BIT(5)
+#define WPA_CIPHER_SMS4                 BIT(10)
+#define WPA_CIPHER_GCMP                 BIT(11)
+#define WPA_CIPHER_GCMP_256             BIT(12)
+#define WPA_CIPHER_BIP_GMAC_128         BIT(13)
+#define WPA_CIPHER_BIP_GMAC_256         BIT(14)
+
+enum wpa_alg {
+    WIFI_WPA_ALG_NONE   = 0,
+    WIFI_WPA_ALG_WEP40  = 1,
+    WIFI_WPA_ALG_TKIP   = 2,
+    WIFI_WPA_ALG_CCMP   = 3,
+    WIFI_WAPI_ALG_SMS4  = 4,
+    WIFI_WPA_ALG_WEP104 = 5,
+    WIFI_WPA_ALG_WEP    = 6,
+    WIFI_WPA_ALG_IGTK   = 7,
+    WIFI_WPA_ALG_PMK    = 8,
+    WIFI_WPA_ALG_GCMP   = 9,
+};
+
+int wpa_cipher_to_alg(int cipher);
+
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/main.c b/drivers/net/wireless/espressif/esp_hosted_ng/main.c
new file mode 100644
index 0000000..e907d8b
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/main.c
@@ -0,0 +1,893 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/igmp.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "esp.h"
+#include "esp_if.h"
+#include "esp_bt_api.h"
+#include "esp_api.h"
+#include "esp_cmd.h"
+#include "esp_kernel_port.h"
+
+#include "esp_cfg80211.h"
+#include "esp_stats.h"
+
+//#define HOST_GPIO_PIN_INVALID -1
+//static int resetpin = HOST_GPIO_PIN_INVALID;
+extern u8 ap_bssid[MAC_ADDR_LEN];
+extern volatile u8 host_sleep;
+
+//module_param(resetpin, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+//MODULE_PARM_DESC(resetpin, "Host's GPIO pin number which is connected to ESP32's EN to reset ESP32 device");
+
+static void deinit_adapter(void);
+
+struct multicast_list mcast_list = {0};
+struct esp_adapter adapter;
+
+struct esp_adapter *esp_get_adapter(void)
+{
+	return &adapter;
+}
+
+void esp_process_new_packet_intr(struct esp_adapter *adapter)
+{
+	if(adapter)
+		queue_work(adapter->if_rx_workqueue, &adapter->if_rx_work);
+}
+
+static int process_tx_packet (struct sk_buff *skb)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct esp_skb_cb *cb = NULL;
+	struct esp_payload_header *payload_header = NULL;
+	struct sk_buff *new_skb = NULL;
+	int ret = 0;
+	u8 pad_len = 0, realloc_skb = 0;
+	u16 len = 0;
+	u16 total_len = 0;
+	static u8 c = 0;
+	u8 *pos = NULL;
+
+	c++;
+	/* Get the priv */
+	cb = (struct esp_skb_cb *) skb->cb;
+	priv = cb->priv;
+
+	if (!priv) {
+		dev_kfree_skb(skb);
+		printk(KERN_INFO "%s: no priv\n", __func__);
+		return NETDEV_TX_OK;
+	}
+
+	if (netif_queue_stopped((const struct net_device *) priv->ndev)) {
+		printk(KERN_INFO "%s: Netif queue stopped\n", __func__);
+		return NETDEV_TX_BUSY;
+	}
+
+	if (host_sleep) {
+		return NETDEV_TX_BUSY;
+	}
+
+	len = skb->len;
+
+	/* Create space for payload header */
+	pad_len = sizeof(struct esp_payload_header);
+
+	total_len = len + pad_len;
+
+	/* Align buffer length */
+	pad_len += SKB_DATA_ADDR_ALIGNMENT - (total_len % SKB_DATA_ADDR_ALIGNMENT);
+
+	if (skb_headroom(skb) < pad_len) {
+		/* Headroom is not sufficient */
+		realloc_skb = 1;
+	}
+
+	if (realloc_skb || !IS_ALIGNED((unsigned long) skb->data, SKB_DATA_ADDR_ALIGNMENT)) {
+		/* Realloc SKB */
+		if (skb_linearize(skb)) {
+			priv->stats.tx_errors++;
+			dev_kfree_skb(skb);
+			printk(KERN_ERR "%s: Failed to linearize SKB", __func__);
+			return NETDEV_TX_OK;
+		}
+
+		new_skb = esp_alloc_skb(skb->len + pad_len);
+
+		if (!new_skb) {
+			printk(KERN_ERR "%s: Failed to allocate SKB", __func__);
+			priv->stats.tx_errors++;
+			dev_kfree_skb(skb);
+			return NETDEV_TX_OK;
+		}
+
+		pos = new_skb->data;
+		pos += pad_len;
+
+		/* Populate new SKB */
+		skb_copy_from_linear_data(skb, pos, skb->len);
+		skb_put(new_skb, skb->len + pad_len);
+
+		/* Replace old SKB */
+		dev_kfree_skb_any(skb);
+		skb = new_skb;
+	} else {
+		/* Realloc is not needed, Make space for interface header */
+		skb_push(skb, pad_len);
+	}
+
+	/* Set payload header */
+	payload_header = (struct esp_payload_header *) skb->data;
+	memset(payload_header, 0, pad_len);
+
+	payload_header->if_type = priv->if_type;
+	payload_header->if_num = priv->if_num;
+	payload_header->len = cpu_to_le16(len);
+	payload_header->offset = cpu_to_le16(pad_len);
+	payload_header->packet_type = PACKET_TYPE_DATA;
+
+	if (adapter.capabilities & ESP_CHECKSUM_ENABLED)
+		payload_header->checksum = cpu_to_le16(compute_checksum(skb->data, (len + pad_len)));
+
+	if (!priv->stop_data) {
+		ret = esp_send_packet(priv->adapter, skb);
+
+		if (ret) {
+/*			printk(KERN_ERR "%s: Failed to send SKB", __func__);*/
+			priv->stats.tx_errors++;
+		} else {
+			priv->stats.tx_packets++;
+			priv->stats.tx_bytes += skb->len;
+		}
+	} else {
+		dev_kfree_skb_any(skb);
+		priv->stats.tx_dropped++;
+	}
+
+	return 0;
+}
+
+void esp_port_open(struct esp_wifi_device * priv)
+{
+	priv->port_open = 1;
+	priv->stop_data = 0;
+}
+
+void esp_port_close(struct esp_wifi_device * priv)
+{
+	if (!priv)
+		return;
+
+	priv->port_open = 0;
+	priv->stop_data = 1;
+}
+
+void print_capabilities(u32 cap)
+{
+	printk(KERN_INFO "Capabilities: 0x%x. Features supported are:\n", cap);
+	if (cap & ESP_WLAN_SDIO_SUPPORT)
+		printk(KERN_INFO "\t * WLAN on SDIO\n");
+	else if (cap & ESP_WLAN_SPI_SUPPORT)
+		printk(KERN_INFO "\t * WLAN on SPI\n");
+
+	if ((cap & ESP_BT_UART_SUPPORT) ||
+		    (cap & ESP_BT_SDIO_SUPPORT) ||
+		    (cap & ESP_BT_SPI_SUPPORT)) {
+		printk(KERN_INFO "\t * BT/BLE\n");
+		if (cap & ESP_BT_UART_SUPPORT)
+			printk(KERN_INFO "\t   - HCI over UART\n");
+		if (cap & ESP_BT_SDIO_SUPPORT)
+			printk(KERN_INFO "\t   - HCI over SDIO\n");
+		if (cap & ESP_BT_SPI_SUPPORT)
+			printk(KERN_INFO "\t   - HCI over SPI\n");
+
+		if ((cap & ESP_BLE_ONLY_SUPPORT) && (cap & ESP_BR_EDR_ONLY_SUPPORT))
+			printk(KERN_INFO "\t   - BT/BLE dual mode\n");
+		else if (cap & ESP_BLE_ONLY_SUPPORT)
+			printk(KERN_INFO "\t   - BLE only\n");
+		else if (cap & ESP_BR_EDR_ONLY_SUPPORT)
+			printk(KERN_INFO "\t   - BR EDR only\n");
+	}
+}
+
+void process_capabilities(struct esp_adapter *adapter)
+{
+	printk(KERN_INFO "ESP peripheral capabilities: 0x%x\n", adapter->capabilities);
+
+	/* Reset BT */
+	esp_deinit_bt(adapter);
+
+	if ((adapter->capabilities & ESP_BT_SPI_SUPPORT) ||
+		(adapter->capabilities & ESP_BT_SDIO_SUPPORT)) {
+		msleep(200);
+		printk(KERN_INFO "ESP Bluetooth init\n");
+		esp_init_bt(adapter);
+	}
+}
+
+static int check_esp_version(struct fw_version *ver)
+{
+	printk(KERN_INFO "esp32: ESP Firmware version: %u.%u.%u\n",
+			ver->major1, ver->major2, ver->minor);
+	if (!ver->major1) {
+		printk(KERN_ERR "Incompatible ESP firmware release detected, Please use correct ESP-Hosted branch/compatible release\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void print_reset_reason(uint32_t reason)
+{
+	switch (reason)
+	{
+		case 1 : printk(KERN_INFO  "POWERON_RESET\n");break;          /**<1, Vbat power on reset*/
+		case 3 : printk(KERN_INFO  "SW_RESET\n");break;               /**<3, Software reset digital core*/
+		case 4 : printk(KERN_INFO  "OWDT_RESET\n");break;             /**<4, Legacy watch dog reset digital core*/
+		case 5 : printk(KERN_INFO  "DEEPSLEEP_RESET\n");break;        /**<5, Deep Sleep reset digital core*/
+		case 6 : printk(KERN_INFO  "SDIO_RESET\n");break;             /**<6, Reset by SLC module, reset digital core*/
+		case 7 : printk(KERN_INFO  "TG0WDT_SYS_RESET\n");break;       /**<7, Timer Group0 Watch dog reset digital core*/
+		case 8 : printk(KERN_INFO  "TG1WDT_SYS_RESET\n");break;       /**<8, Timer Group1 Watch dog reset digital core*/
+		case 9 : printk(KERN_INFO  "RTCWDT_SYS_RESET\n");break;       /**<9, RTC Watch dog Reset digital core*/
+		case 10 : printk(KERN_INFO  "INTRUSION_RESET\n");break;       /**<10, Instrusion tested to reset CPU*/
+		case 11 : printk(KERN_INFO  "TGWDT_CPU_RESET\n");break;       /**<11, Time Group reset CPU*/
+		case 12 : printk(KERN_INFO  "SW_CPU_RESET\n");break;          /**<12, Software reset CPU*/
+		case 13 : printk(KERN_INFO  "RTCWDT_CPU_RESET\n");break;      /**<13, RTC Watch dog Reset CPU*/
+		case 14 : printk(KERN_INFO  "EXT_CPU_RESET\n");break;         /**<14, for APP CPU, reseted by PRO CPU*/
+		case 15 : printk(KERN_INFO  "RTCWDT_BROWN_OUT_RESET\n");break;/**<15, Reset when the vdd voltage is not stable*/
+		case 16 : printk(KERN_INFO  "RTCWDT_RTC_RESET\n");break;      /**<16, RTC Watch dog reset digital core and rtc module*/
+		default : printk(KERN_INFO  "Unknown[%u]\n",reason);break;
+	}
+}
+
+int process_fw_data(struct fw_data *fw_p)
+{
+	if (!fw_p) {
+		printk(KERN_ERR "Incomplete/incorrect bootup event received\n");
+		return -1;
+	}
+
+	printk(KERN_INFO "esp32: %s ESP chipset's last reset cause: ", __func__);
+	print_reset_reason(le32_to_cpu(fw_p->last_reset_reason));
+	return check_esp_version(&fw_p->version);
+}
+
+static int esp_open(struct net_device *ndev)
+{
+	return 0;
+}
+
+static int esp_stop(struct net_device *ndev)
+{
+	struct esp_wifi_device *priv = netdev_priv(ndev);
+	ESP_MARK_SCAN_DONE(priv, true);
+	return 0;
+}
+
+static struct net_device_stats* esp_get_stats(struct net_device *ndev)
+{
+	struct esp_wifi_device *priv = netdev_priv(ndev);
+
+	if (!priv)
+		return NULL;
+
+	return &priv->stats;
+}
+
+#if 0
+static int esp_set_mac_address(struct net_device *ndev, void *data)
+{
+	struct esp_wifi_device *priv = netdev_priv(ndev);
+	//struct sockaddr *mac_addr = data;
+
+	if (!priv || !priv->adapter)
+		return -EINVAL;
+
+	printk(KERN_INFO "%s:%u %pM\n", __func__, __LINE__, priv->mac_address);
+	eth_hw_addr_set(ndev, priv->mac_address/*mac_addr->sa_data*/);
+
+	return 0;
+}
+#endif
+
+static NDO_TX_TIMEOUT_PROTOTYPE()
+{
+}
+
+static void esp_set_rx_mode(struct net_device *ndev)
+{
+	struct esp_wifi_device *priv = netdev_priv(ndev);
+	struct netdev_hw_addr *mac_addr;
+	u32 count = 0;
+#if 0
+	struct in_device *in_dev = in_dev_get(ndev);
+	struct ip_mc_list *ip_list = in_dev->mc_list;
+#endif
+	netdev_for_each_mc_addr(mac_addr, ndev) {
+		if (count < MAX_MULTICAST_ADDR_COUNT) {
+			/*printk(KERN_INFO "%d: %pM\n", count+1, mac_addr->addr);*/
+			memcpy(&mcast_list.mcast_addr[count++], mac_addr->addr, ETH_ALEN);
+		}
+	}
+
+	mcast_list.priv = priv;
+	mcast_list.addr_count = count;
+
+	if (priv->port_open) {
+		/*printk (KERN_INFO "Set Multicast list\n");*/
+		if (adapter.mac_filter_wq)
+			queue_work(adapter.mac_filter_wq, &adapter.mac_flter_work);
+	}
+#if 0
+	cmd_set_mcast_mac_list(priv, &mcast_list);
+	while(ip_list) {
+		printk(KERN_DEBUG " IP MC Address: 0x%x\n", ip_list->multiaddr);
+		ip_list = ip_list->next;
+	}
+#endif
+
+}
+
+static int esp_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct esp_skb_cb *cb = NULL;
+
+	if (!skb || !ndev)
+		return NETDEV_TX_OK;
+
+	priv = netdev_priv(ndev);
+	if (!priv) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	if (!priv->port_open) {
+		priv->stats.tx_dropped++;
+		/*printk(KERN_ERR "esp32: %s: port not yet open\n", __func__);*/
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	if (!skb->len || (skb->len > ETH_FRAME_LEN)) {
+		printk(KERN_ERR "esp32: %s: Bad len %d\n", __func__, skb->len);
+		priv->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	cb = (struct esp_skb_cb *) skb->cb;
+	cb->priv = priv;
+
+	return process_tx_packet(skb);
+}
+
+static const struct net_device_ops esp_netdev_ops = {
+	.ndo_open = esp_open,
+	.ndo_stop = esp_stop,
+	.ndo_start_xmit = esp_hard_start_xmit,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_tx_timeout = esp_tx_timeout,
+	.ndo_get_stats = esp_get_stats,
+	.ndo_set_rx_mode = esp_set_rx_mode,
+};
+
+
+void esp_init_priv(struct net_device *ndev)
+{
+	ndev->netdev_ops = &esp_netdev_ops;
+	ndev->needed_headroom = roundup(sizeof(struct esp_payload_header) +
+			INTERFACE_HEADER_PADDING, 4);
+}
+
+static int add_network_iface(void)
+{
+	int ret = 0;
+	struct esp_adapter * adapter = esp_get_adapter();
+	struct wireless_dev * wdev = NULL;
+
+	if (!adapter) {
+		printk(KERN_INFO "%s: adapter not yet init\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = esp_cfg80211_register(adapter);
+	if (ret) {
+		printk(KERN_ERR "Failed to register with cfg80211 (err code 0x%x)\n", ret);
+		return ret;
+	}
+
+	rtnl_lock();
+	wdev = esp_cfg80211_add_iface(adapter->wiphy, "espsta%d", 1, NL80211_IFTYPE_STATION, NULL);
+	rtnl_unlock();
+
+	/* Return success if network added successfully */
+	if (wdev)
+		return 0;
+
+	return -1;
+}
+
+int esp_add_card(struct esp_adapter *adapter)
+{
+	RET_ON_FAIL(esp_commands_setup(adapter));
+
+	RET_ON_FAIL(add_network_iface());
+
+	return 0;
+}
+
+void esp_remove_network_interfaces(struct esp_adapter *adapter)
+{
+	uint8_t iface_idx = 0;
+	struct net_device *ndev = NULL;
+	struct esp_wifi_device *priv = NULL;
+
+	for (iface_idx=0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+
+		priv = adapter->priv[iface_idx];
+
+		if (!priv)
+			continue;
+
+		if (!test_bit(ESP_NETWORK_UP, &priv->priv_flags))
+			continue;
+
+		/* stop and unregister network */
+		ndev = priv->ndev;
+
+		if (ndev) {
+
+			if (netif_carrier_ok(ndev))
+				netif_carrier_off(ndev);
+
+			netif_device_detach(ndev);
+
+			if (ndev->reg_state == NETREG_REGISTERED) {
+				unregister_inetaddr_notifier(&(adapter->priv[0]->nb));
+				unregister_netdev(ndev);
+				free_netdev(ndev);
+				ndev = NULL;
+			}
+		}
+		clear_bit(ESP_NETWORK_UP, &priv->priv_flags);
+	}
+
+	if (adapter->wiphy) {
+
+		wiphy_unregister(adapter->wiphy);
+		wiphy_free(adapter->wiphy);
+		adapter->wiphy = NULL;
+	}
+}
+
+int esp_remove_card(struct esp_adapter *adapter)
+{
+	uint8_t iface_idx = 0;
+
+	if (!adapter) {
+		return 0;
+	}
+
+	esp_deinit_bt(adapter);
+
+	esp_commands_teardown(adapter);
+
+	esp_remove_network_interfaces(adapter);
+
+	for (iface_idx=0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+		esp_port_close(adapter->priv[iface_idx]);
+		adapter->priv[iface_idx] = NULL;
+	}
+
+	return 0;
+}
+
+struct esp_wifi_device * get_priv_from_payload_header(
+		struct esp_payload_header *header)
+{
+	struct esp_wifi_device *priv = NULL;
+	u8 i = 0;
+
+	if (!header)
+		return NULL;
+
+	for (i = 0; i < ESP_MAX_INTERFACE; i++) {
+		priv = adapter.priv[i];
+
+		if (!priv)
+			continue;
+
+		if (priv->if_type == header->if_type &&
+				priv->if_num == header->if_num) {
+			return priv;
+		}
+	}
+	return NULL;
+}
+
+static void process_esp_bootup_event(struct esp_adapter *adapter,
+		struct esp_internal_bootup_event *evt)
+{
+	if (!adapter || !evt) {
+		printk(KERN_ERR "%s: Invalid arguments\n", __func__);
+		return;
+	}
+
+	if (evt->header.status) {
+		printk(KERN_ERR "%s: Incorrect ESP bootup event\n", __func__);
+		return;
+	}
+
+	printk (KERN_INFO "\nReceived ESP bootup event\n");
+	process_event_esp_bootup(adapter, evt->data, evt->len);
+}
+
+static int process_internal_event(struct esp_adapter *adapter,
+		struct sk_buff *skb)
+{
+	struct event_header *header = NULL;
+
+	if (!skb || !adapter) {
+		printk (KERN_ERR "esp32: Incorrect event data!\n");
+		return -1;
+	}
+
+	header = (struct event_header *) (skb->data);
+
+	switch (header->event_code) {
+
+	case ESP_INTERNAL_BOOTUP_EVENT:
+		process_esp_bootup_event(adapter,
+			(struct esp_internal_bootup_event *)(skb->data));
+		break;
+
+	default:
+		printk(KERN_INFO "%s:%u unhandled internal event[%u]\n",
+				__func__, __LINE__, header->event_code);
+		break;
+	}
+
+	return 0;
+}
+
+static void process_rx_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	struct esp_wifi_device *priv = NULL;
+	struct esp_payload_header *payload_header = NULL;
+	u16 len = 0, offset = 0;
+	u16 rx_checksum = 0, checksum = 0;
+	struct hci_dev *hdev = adapter->hcidev;
+	u8 *type = NULL;
+	struct sk_buff * eap_skb = NULL;
+	struct ethhdr * eth = NULL;
+
+	if (!skb)
+		return;
+
+	/* get the paload header */
+	payload_header = (struct esp_payload_header *) skb->data;
+
+	len = le16_to_cpu(payload_header->len);
+	offset = le16_to_cpu(payload_header->offset);
+
+	if (payload_header->reserved2 == 0xFF) {
+		print_hex_dump(KERN_INFO, "Wake up packet: ", DUMP_PREFIX_ADDRESS, 16, 1, skb->data, len+offset, 1);
+	}
+
+	if (adapter->capabilities & ESP_CHECKSUM_ENABLED) {
+		rx_checksum = le16_to_cpu(payload_header->checksum);
+		payload_header->checksum = 0;
+
+		checksum = compute_checksum(skb->data, (len + offset));
+
+		if (checksum != rx_checksum) {
+			dev_kfree_skb_any(skb);
+			return;
+		}
+	}
+
+	/* chop off the header from skb */
+	skb_pull(skb, offset);
+
+	if (payload_header->if_type == ESP_STA_IF || payload_header->if_type == ESP_AP_IF) {
+
+		/* retrieve priv based on payload header contents */
+		priv = get_priv_from_payload_header(payload_header);
+
+		if (!priv) {
+			printk(KERN_ERR "%s: empty priv\n", __func__);
+			dev_kfree_skb_any(skb);
+			return;
+		}
+
+		if (payload_header->packet_type == PACKET_TYPE_EAPOL) {
+			printk(KERN_INFO "%s: Rx PACKET_TYPE_EAPOL!!!!\n", __func__);
+			esp_port_open(priv);
+
+			eap_skb = alloc_skb(skb->len + ETH_HLEN, GFP_KERNEL);
+			if(!eap_skb) {
+				printk(KERN_INFO "%s:%u memory alloc failed\n",__func__, __LINE__);
+				return;
+			}
+			eap_skb->dev = priv->ndev;
+
+			if (!IS_ALIGNED((unsigned long) eap_skb->data, SKB_DATA_ADDR_ALIGNMENT)) {
+				printk(KERN_INFO "%s:%u eap skb unaligned\n",__func__, __LINE__);
+			}
+
+			eth = (struct ethhdr *) skb_put(eap_skb, ETH_HLEN);
+			ether_addr_copy(eth->h_dest, /*skb->data*/priv->ndev->dev_addr);
+			ether_addr_copy(eth->h_source, /*skb->data+6*/ ap_bssid);
+			eth->h_proto = cpu_to_be16(ETH_P_PAE);
+
+			skb_put_data(eap_skb, skb->data, skb->len);
+			eap_skb->protocol = eth_type_trans(eap_skb, eap_skb->dev);
+
+			netif_rx(eap_skb);
+
+		} else if (payload_header->packet_type == PACKET_TYPE_DATA) {
+
+			skb->dev = priv->ndev;
+			skb->protocol = eth_type_trans(skb, priv->ndev);
+			skb->ip_summed = CHECKSUM_NONE;
+
+			priv->stats.rx_bytes += skb->len;
+			/* Forward skb to kernel */
+			NETIF_RX_NI(skb);
+			priv->stats.rx_packets++;
+		} else if (payload_header->packet_type == PACKET_TYPE_COMMAND_RESPONSE) {
+			process_cmd_resp(priv->adapter, skb);
+		} else if (payload_header->packet_type == PACKET_TYPE_EVENT) {
+			process_cmd_event(priv, skb);
+			dev_kfree_skb_any(skb);
+		}
+
+	} else if (payload_header->if_type == ESP_HCI_IF) {
+		if (hdev) {
+
+			type = skb->data;
+			hci_skb_pkt_type(skb) = *type;
+			skb_pull(skb, 1);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0))
+			if (hci_recv_frame(hdev, skb)) {
+#else
+			if (hci_recv_frame(skb)) {
+#endif
+				hdev->stat.err_rx++;
+			} else {
+				esp_hci_update_rx_counter(hdev, *type, skb->len);
+			}
+		}
+	} else if (payload_header->if_type == ESP_INTERNAL_IF) {
+
+		/* Queue event skb for processing in events workqueue */
+		skb_queue_tail(&adapter->events_skb_q, skb);
+
+		if (adapter->events_wq)
+			queue_work(adapter->events_wq, &adapter->events_work);
+		else
+			dev_kfree_skb_any(skb);
+
+	} else if (payload_header->if_type == ESP_TEST_IF) {
+		#if TEST_RAW_TP
+			update_test_raw_tp_rx_stats(len);
+		#endif
+		dev_kfree_skb_any(skb);
+	} else {
+		dev_kfree_skb_any(skb);
+	}
+}
+
+int esp_is_tx_queue_paused(struct esp_wifi_device *priv)
+{
+	if (!priv || !priv->ndev)
+		return 0;
+
+	if ((priv->ndev &&
+		    !netif_queue_stopped((const struct net_device *)priv->ndev)))
+		return 1;
+    return 0;
+}
+
+void esp_tx_pause(struct esp_wifi_device *priv)
+{
+	if (!priv || !priv->ndev)
+		return;
+
+	if (!netif_queue_stopped((const struct net_device *)priv->ndev)) {
+		netif_stop_queue(priv->ndev);
+	}
+}
+
+void esp_tx_resume(struct esp_wifi_device *priv)
+{
+	if (!priv || !priv->ndev)
+		return;
+
+	if (netif_queue_stopped((const struct net_device *)priv->ndev)) {
+		netif_wake_queue(priv->ndev);
+	}
+}
+
+struct sk_buff * esp_alloc_skb(u32 len)
+{
+	struct sk_buff *skb = NULL;
+
+	u8 offset;
+
+	skb = netdev_alloc_skb(NULL, len + INTERFACE_HEADER_PADDING);
+
+	if (skb) {
+		/* Align SKB data pointer */
+		offset = ((unsigned long)skb->data) & (SKB_DATA_ADDR_ALIGNMENT - 1);
+
+		if (offset)
+			skb_reserve(skb, INTERFACE_HEADER_PADDING - offset);
+	}
+
+	return skb;
+}
+
+
+static int esp_get_packets(struct esp_adapter *adapter)
+{
+	struct sk_buff *skb = NULL;
+
+	if (!adapter || !adapter->if_ops || !adapter->if_ops->read)
+		return -EINVAL;
+
+	skb = adapter->if_ops->read(adapter);
+
+	if (!skb)
+		return -EFAULT;
+
+	process_rx_packet(adapter, skb);
+
+	return 0;
+}
+
+int esp_send_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	if (!adapter || !adapter->if_ops || !adapter->if_ops->write) {
+		printk(KERN_ERR "esp32: %s:%u adapter: %p\n", __func__, __LINE__, adapter);
+		return -EINVAL;
+	}
+
+	return adapter->if_ops->write(adapter, skb);
+}
+
+static void esp_if_rx_work(struct work_struct *work)
+{
+	/* read inbound packet and forward it to network/serial interface */
+	esp_get_packets(&adapter);
+}
+
+static void update_mac_filter(struct work_struct *work)
+{
+	cmd_set_mcast_mac_list(mcast_list.priv, &mcast_list);
+}
+
+static void esp_events_work(struct work_struct *work)
+{
+	struct sk_buff *skb = NULL;
+
+	skb = skb_dequeue(&adapter.events_skb_q);
+	if (!skb)
+		return;
+
+	process_internal_event(&adapter, skb);
+	dev_kfree_skb_any(skb);
+}
+
+static struct esp_adapter *init_adapter(void)
+{
+	memset(&adapter, 0, sizeof(adapter));
+
+	/* Prepare interface RX work */
+	adapter.if_rx_workqueue = alloc_workqueue("ESP_IF_RX_WORK_QUEUE", 0, 0);
+
+	if (!adapter.if_rx_workqueue) {
+		deinit_adapter();
+		return NULL;
+	}
+
+	INIT_WORK(&adapter.if_rx_work, esp_if_rx_work);
+
+	skb_queue_head_init(&adapter.events_skb_q);
+
+	adapter.events_wq = alloc_workqueue("ESP_EVENTS_WORKQUEUE", WQ_HIGHPRI, 0);
+
+	if (!adapter.events_wq) {
+		deinit_adapter();
+		return NULL;
+	}
+
+	INIT_WORK(&adapter.events_work, esp_events_work);
+
+	adapter.mac_filter_wq = alloc_workqueue("MAC_FILTER", 0, 0);
+	if (!adapter.mac_filter_wq) {
+		deinit_adapter();
+		return NULL;
+	}
+
+	INIT_WORK(&adapter.mac_flter_work, update_mac_filter);
+
+	return &adapter;
+}
+
+static void deinit_adapter(void)
+{
+	skb_queue_purge(&adapter.events_skb_q);
+
+	if (adapter.events_wq)
+		destroy_workqueue(adapter.events_wq);
+
+	if (adapter.if_rx_workqueue)
+		destroy_workqueue(adapter.if_rx_workqueue);
+
+	if (adapter.mac_filter_wq)
+		destroy_workqueue(adapter.mac_filter_wq);
+}
+
+int esp_init(void)
+{
+	int ret = 0;
+	struct esp_adapter *adapter = NULL;
+
+	printk(KERN_INFO "%s: enter\n", __func__);
+
+	adapter = init_adapter();
+
+	if (!adapter)
+		return -EFAULT;
+
+	/* Init transport layer */
+	ret = esp_init_interface_layer(adapter);
+
+	if (ret != 0) {
+		deinit_adapter();
+	}
+
+	printk(KERN_INFO "%s: ret=%d\n", __func__, ret);
+
+	return ret;
+}
+
+void esp_exit(void)
+{
+	uint8_t iface_idx = 0;
+#if TEST_RAW_TP
+	test_raw_tp_cleanup();
+#endif
+	for (iface_idx=0; iface_idx<ESP_MAX_INTERFACE; iface_idx++) {
+		cmd_deinit_interface(adapter.priv[iface_idx]);
+	}
+	clear_bit(ESP_DRIVER_ACTIVE, &adapter.state_flags);
+
+	esp_deinit_interface_layer();
+	deinit_adapter();
+}
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/main.h b/drivers/net/wireless/espressif/esp_hosted_ng/main.h
new file mode 100644
index 0000000..87165e0
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/main.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+#ifndef _ESP_MAIN_H_
+#define _ESP_MAIN_H_
+
+int esp_init(void);
+void esp_exit(void);
+
+#endif // _ESP_MAIN_H_
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c
new file mode 100644
index 0000000..5764ced
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio.c
@@ -0,0 +1,1003 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include "esp_if.h"
+#include "esp_sdio_api.h"
+#include "esp_api.h"
+#include "esp_bt_api.h"
+#include <linux/kthread.h>
+#include <linux/printk.h>
+#include "esp_stats.h"
+#include "include/esp_kernel_port.h"
+#include "main.h"
+
+#define MAX_WRITE_RETRIES       2
+#define TX_MAX_PENDING_COUNT    200
+#define TX_RESUME_THRESHOLD     (TX_MAX_PENDING_COUNT/5)
+
+#define CHECK_SDIO_RW_ERROR(ret) do {			\
+	if (ret)						\
+	printk(KERN_ERR "%s: CMD53 read/write error at %d\n", __func__, __LINE__);	\
+} while (0);
+
+#ifdef CONFIG_ESP_HOSTED_NG_MONITOR_PROCESS
+#define ENABLE_MONITOR_PROCESS	1
+#else
+#define ENABLE_MONITOR_PROCESS	0
+#endif
+
+struct esp_sdio_context sdio_context;
+static atomic_t tx_pending;
+static atomic_t queue_items[MAX_PRIORITY_QUEUES];
+
+#if ENABLE_MONITOR_PROCESS
+struct task_struct *monitor_thread;
+#endif
+struct task_struct *tx_thread;
+
+volatile u8 host_sleep = 0;
+
+static int init_context(struct esp_sdio_context *context);
+static struct sk_buff * read_packet(struct esp_adapter *adapter);
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb);
+/*int deinit_context(struct esp_adapter *adapter);*/
+
+static const struct sdio_device_id esp_devices[] = {
+	{ SDIO_DEVICE(ESP_VENDOR_ID, ESP_DEVICE_ID_1) },
+	{ SDIO_DEVICE(ESP_VENDOR_ID, ESP_DEVICE_ID_2) },
+	{}
+};
+
+static void esp_process_interrupt(struct esp_sdio_context *context, u32 int_status)
+{
+	if (!context) {
+		return;
+	}
+
+	if (int_status & ESP_SLAVE_RX_NEW_PACKET_INT) {
+		esp_process_new_packet_intr(context->adapter);
+	}
+}
+
+static void esp_handle_isr(struct sdio_func *func)
+{
+	struct esp_sdio_context *context = NULL;
+	u32 *int_status;
+	int ret;
+
+	if (!func) {
+		return;
+	}
+
+	if (host_sleep)
+		return;
+
+	context = sdio_get_drvdata(func);
+
+	if (!context) {
+		return;
+	}
+
+	int_status = kmalloc(sizeof(u32), GFP_ATOMIC);
+
+	if (!int_status) {
+		return;
+	}
+
+	/* Read interrupt status register */
+	ret = esp_read_reg(context, ESP_SLAVE_INT_ST_REG,
+			(u8 *) int_status, sizeof(* int_status), ACQUIRE_LOCK);
+	CHECK_SDIO_RW_ERROR(ret);
+
+	esp_process_interrupt(context, *int_status);
+
+	/* Clear interrupt status */
+	ret = esp_write_reg(context, ESP_SLAVE_INT_CLR_REG,
+			(u8 *) int_status, sizeof(* int_status), ACQUIRE_LOCK);
+	CHECK_SDIO_RW_ERROR(ret);
+
+	kfree(int_status);
+}
+
+int generate_slave_intr(struct esp_sdio_context *context, u8 data)
+{
+	u8 *val;
+	int ret = 0;
+
+	if (!context)
+		return -EINVAL;
+
+	val = kmalloc(sizeof(u8), GFP_KERNEL);
+
+	if (!val) {
+		return -ENOMEM;
+	}
+
+	*val = data;
+
+	ret = esp_write_reg(context, ESP_SLAVE_SCRATCH_REG_7, val,
+			sizeof(*val), ACQUIRE_LOCK);
+
+	kfree(val);
+
+	return ret;
+}
+
+static void deinit_sdio_func(struct sdio_func *func)
+{
+	sdio_claim_host(func);
+	/* Release IRQ */
+	sdio_release_irq(func);
+	/* Disable sdio function */
+	sdio_disable_func(func);
+	sdio_release_host(func);
+	sdio_set_drvdata(func, NULL);
+}
+
+static int esp_slave_get_tx_buffer_num(struct esp_sdio_context *context, u32 *tx_num, u8 is_lock_needed)
+{
+	u32 *len = NULL;
+	int ret = 0;
+
+	len = kmalloc(sizeof(u32), GFP_KERNEL);
+
+	if (!len) {
+		return -ENOMEM;
+	}
+
+	ret = esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (u8*) len, sizeof(*len), is_lock_needed);
+
+	if (ret) {
+		kfree(len);
+		return ret;
+	}
+
+	*len = (*len >> 16) & ESP_TX_BUFFER_MASK;
+	*len = (*len + ESP_TX_BUFFER_MAX - context->tx_buffer_count) % ESP_TX_BUFFER_MAX;
+
+	*tx_num = *len;
+
+	kfree(len);
+	return ret;
+}
+
+static int esp_get_len_from_slave(struct esp_sdio_context *context, u32 *rx_size, u8 is_lock_needed)
+{
+	u32 *len;
+	u32 temp;
+	int ret = 0;
+
+	len = kmalloc(sizeof(u32), GFP_KERNEL);
+
+	if (!len) {
+		return -ENOMEM;
+	}
+
+	ret = esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+			(u8 *) len, sizeof(*len), is_lock_needed);
+
+	if (ret) {
+		kfree (len);
+		return ret;
+	}
+
+	*len &= ESP_SLAVE_LEN_MASK;
+
+	if (*len >= context->rx_byte_count)
+		*len = (*len + ESP_RX_BYTE_MAX - context->rx_byte_count) % ESP_RX_BYTE_MAX;
+	else {
+		/* Handle a case of roll over */
+		temp = ESP_RX_BYTE_MAX - context->rx_byte_count;
+		*len = temp + *len;
+
+		if (*len > ESP_RX_BUFFER_SIZE) {
+			printk(KERN_INFO "%s: Len from slave[%d] exceeds max [%d]\n",
+					__func__, *len, ESP_RX_BUFFER_SIZE);
+		}
+	}
+	*rx_size = *len;
+
+	kfree (len);
+	return 0;
+}
+
+
+#if 0
+static void flush_sdio(struct esp_sdio_context *context)
+{
+	struct sk_buff *skb;
+
+	if (!context || !context->adapter)
+		return;
+
+	while (1) {
+		skb = read_packet(context->adapter);
+
+		if (!skb) {
+			break;
+		}
+
+		if (skb->len)
+			printk (KERN_INFO "%s: Flushed %d bytes\n", __func__, skb->len);
+		dev_kfree_skb(skb);
+		skb = NULL;
+	}
+}
+#endif
+
+static void esp_remove(struct sdio_func *func)
+{
+	struct esp_sdio_context *context;
+	uint8_t prio_q_idx = 0;
+	context = sdio_get_drvdata(func);
+
+#if ENABLE_MONITOR_PROCESS
+	if (monitor_thread)
+		kthread_stop(monitor_thread);
+#endif
+	if (context) {
+		context->state = ESP_CONTEXT_INIT;
+		for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++)
+			skb_queue_purge(&(sdio_context.tx_q[prio_q_idx]));
+	}
+
+	if (tx_thread)
+		kthread_stop(tx_thread);
+
+	if (context) {
+		generate_slave_intr(context, BIT(ESP_CLOSE_DATA_PATH));
+		msleep(100);
+
+		context->state = ESP_CONTEXT_DISABLED;
+
+		if (context->adapter) {
+			esp_remove_card(context->adapter);
+
+			if (context->adapter->hcidev) {
+				esp_deinit_bt(context->adapter);
+			}
+		}
+
+
+		if (context->func) {
+			deinit_sdio_func(context->func);
+			context->func = NULL;
+		}
+		memset(context, 0, sizeof(struct esp_sdio_context));
+	}
+}
+
+static struct esp_if_ops if_ops = {
+	.read		= read_packet,
+	.write		= write_packet,
+};
+
+static int get_firmware_data(struct esp_sdio_context *context)
+{
+	u32 *val;
+	int ret = 0;
+
+	val = kmalloc(sizeof(u32), GFP_KERNEL);
+
+	if (!val) {
+		return -ENOMEM;
+	}
+
+	/* Initialize rx_byte_count */
+	ret = esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+			(u8 *) val, sizeof(* val), ACQUIRE_LOCK);
+	if (ret) {
+		kfree(val);
+		return ret;
+	}
+
+	printk(KERN_INFO "Rx Pre ====== %d\n", context->rx_byte_count);
+	context->rx_byte_count = *val & ESP_SLAVE_LEN_MASK;
+	printk(KERN_INFO "Rx Pos ======  %d\n", context->rx_byte_count);
+
+	/* Initialize tx_buffer_count */
+	ret = esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (u8 *) val,
+			sizeof(* val), ACQUIRE_LOCK);
+
+	if (ret) {
+		kfree(val);
+		return ret;
+	}
+
+	*val = ((*val >> 16) & ESP_TX_BUFFER_MASK);
+	printk(KERN_INFO "Tx Pre ======  %d\n", context->tx_buffer_count);
+
+	if (*val >= ESP_MAX_BUF_CNT)
+		context->tx_buffer_count = (*val) - ESP_MAX_BUF_CNT;
+	else
+		context->tx_buffer_count = 0;
+	printk(KERN_INFO "Tx Pos ======  %d\n", context->tx_buffer_count);
+
+	kfree(val);
+	return ret;
+}
+
+static int init_context(struct esp_sdio_context *context)
+{
+	int ret = 0;
+	uint8_t prio_q_idx = 0;
+
+	if (!context) {
+		return -EINVAL;
+	}
+
+	ret = get_firmware_data(context);
+	if(ret)
+		return ret;
+
+	context->adapter = esp_get_adapter();
+
+	if (unlikely(!context->adapter))
+		printk (KERN_ERR "%s: Failed to get adapter\n", __func__);
+
+	for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_head_init(&(sdio_context.tx_q[prio_q_idx]));
+		atomic_set(&queue_items[prio_q_idx], 0);
+	}
+
+	context->adapter->if_type = ESP_IF_TYPE_SDIO;
+
+	return ret;
+}
+
+static struct sk_buff * read_packet(struct esp_adapter *adapter)
+{
+	u32 len_from_slave, data_left, len_to_read, size, num_blocks;
+	int ret = 0;
+	struct sk_buff *skb;
+	u8 *pos;
+	struct esp_sdio_context *context;
+
+	if (!adapter || !adapter->if_context) {
+		printk (KERN_ERR "%s: INVALID args\n", __func__);
+		return NULL;
+	}
+
+	context = adapter->if_context;
+
+	if(!context ||  (context->state != ESP_CONTEXT_READY) || !context->func) {
+		printk(KERN_ERR "Invalid context/state\n");
+		return NULL;
+	}
+
+	sdio_claim_host(context->func);
+
+	data_left = len_to_read = len_from_slave = num_blocks = 0;
+
+	/* Read length */
+	ret = esp_get_len_from_slave(context, &len_from_slave, LOCK_ALREADY_ACQUIRED);
+
+	if (ret || !len_from_slave) {
+		sdio_release_host(context->func);
+		return NULL;
+	}
+
+	size = ESP_BLOCK_SIZE * 4;
+
+	if (len_from_slave > size) {
+		printk(KERN_INFO "Rx large packet: %d\n", len_from_slave);
+	}
+
+	skb = esp_alloc_skb(len_from_slave);
+
+	if (!skb) {
+		printk (KERN_ERR "%s: SKB alloc failed\n", __func__);
+		sdio_release_host(context->func);
+		return NULL;
+	}
+
+	skb_put(skb, len_from_slave);
+	pos = skb->data;
+
+	data_left = len_from_slave;
+
+	do {
+		num_blocks = data_left/ESP_BLOCK_SIZE;
+
+#if 0
+		if (!context->rx_byte_count) {
+			start_time = ktime_get_ns();
+		}
+#endif
+
+		if (num_blocks) {
+			len_to_read = num_blocks * ESP_BLOCK_SIZE;
+			ret = esp_read_block(context,
+					ESP_SLAVE_CMD53_END_ADDR - len_to_read,
+					pos, len_to_read, LOCK_ALREADY_ACQUIRED);
+		} else {
+			len_to_read = data_left;
+			/* 4 byte aligned length */
+			ret = esp_read_block(context,
+					ESP_SLAVE_CMD53_END_ADDR - len_to_read,
+					pos, (len_to_read + 3) & (~3), LOCK_ALREADY_ACQUIRED);
+		}
+
+		if (ret) {
+			printk (KERN_ERR "%s: Failed to read data - %d [%u - %d]\n", __func__, ret, num_blocks, len_to_read);
+			dev_kfree_skb(skb);
+			skb = NULL;
+			sdio_release_host(context->func);
+			return NULL;
+		}
+
+		data_left -= len_to_read;
+		pos += len_to_read;
+		context->rx_byte_count += len_to_read;
+		context->rx_byte_count = context->rx_byte_count % ESP_RX_BYTE_MAX;
+
+	} while (data_left > 0);
+
+	sdio_release_host(context->func);
+
+	return skb;
+}
+
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	u32 max_pkt_size = ESP_RX_BUFFER_SIZE - sizeof(struct esp_payload_header);
+	struct esp_payload_header *payload_header = (struct esp_payload_header *) skb->data;
+	struct esp_skb_cb * cb = NULL;
+	uint8_t prio = PRIO_Q_LOW;
+
+	if (!adapter || !adapter->if_context || !skb || !skb->data || !skb->len) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		if(skb) {
+			dev_kfree_skb(skb);
+			skb = NULL;
+		}
+
+		return -EINVAL;
+	}
+
+	if (skb->len > max_pkt_size) {
+		printk(KERN_ERR "%s: Drop pkt of len[%u] > max SDIO transport len[%u]\n",
+				__func__, skb->len, max_pkt_size);
+		dev_kfree_skb(skb);
+		skb = NULL;
+		return -EPERM;
+	}
+
+	cb = (struct esp_skb_cb *)skb->cb;
+	if (cb && cb->priv && (atomic_read(&tx_pending) >= TX_MAX_PENDING_COUNT)) {
+		esp_tx_pause(cb->priv);
+		dev_kfree_skb(skb);
+		skb = NULL;
+/*		printk(KERN_ERR "%s: TX Pause busy", __func__);*/
+		return -EBUSY;
+	}
+
+	/* Enqueue SKB in tx_q */
+	atomic_inc(&tx_pending);
+
+	/* Notify to process queue */
+	if (payload_header->if_type == ESP_INTERNAL_IF)
+		prio = PRIO_Q_HIGH;
+	else if (payload_header->if_type == ESP_HCI_IF)
+		prio = PRIO_Q_MID;
+	else
+		prio = PRIO_Q_LOW;
+
+	atomic_inc(&queue_items[prio]);
+	skb_queue_tail(&(sdio_context.tx_q[prio]), skb);
+
+	return 0;
+}
+
+static int is_sdio_write_buffer_available(u32 buf_needed)
+{
+#define BUFFER_AVAILABLE        1
+#define BUFFER_UNAVAILABLE      0
+
+	int ret = 0;
+	static u32 buf_available = 0;
+	struct esp_sdio_context *context = &sdio_context;
+	u8 retry = MAX_WRITE_RETRIES;
+
+	/*If buffer needed are less than buffer available
+	  then only read for available buffer number from slave*/
+	if (buf_available < buf_needed) {
+		while (retry) {
+			ret = esp_slave_get_tx_buffer_num(context, &buf_available, ACQUIRE_LOCK);
+
+			if (buf_available < buf_needed) {
+
+				/* Release SDIO and retry after delay*/
+				retry--;
+				usleep_range(10,50);
+				continue;
+			}
+
+			break;
+		}
+	}
+
+	if (buf_available >= buf_needed)
+		buf_available -= buf_needed;
+
+	if (!retry) {
+		/* No buffer available at slave */
+		return BUFFER_UNAVAILABLE;
+	}
+
+	return BUFFER_AVAILABLE;
+}
+
+static int tx_process(void *data)
+{
+	int ret = 0;
+	u32 block_cnt = 0;
+	u32 buf_needed = 0;
+	u8 *pos = NULL;
+	u32 data_left, len_to_send, pad;
+	struct sk_buff *tx_skb = NULL;
+	struct esp_adapter *adapter = (struct esp_adapter *) data;
+	struct esp_sdio_context *context = NULL;
+	struct esp_skb_cb * cb = NULL;
+	u8 retry;
+
+	context = adapter->if_context;
+
+	while (!kthread_should_stop()) {
+
+		if (context->state != ESP_CONTEXT_READY) {
+			msleep(10);
+			printk(KERN_ERR "%s: not ready", __func__);
+			continue;
+		}
+
+		if (host_sleep) {
+			/* TODO: Use wait_event_interruptible_timeout */
+			msleep(100);
+			continue;
+		}
+
+		if (atomic_read(&queue_items[PRIO_Q_HIGH]) > 0) {
+			tx_skb = skb_dequeue(&(context->tx_q[PRIO_Q_HIGH]));
+			if (!tx_skb) {
+				continue;
+			}
+			atomic_dec(&queue_items[PRIO_Q_HIGH]);
+		} else if (atomic_read(&queue_items[PRIO_Q_MID]) > 0) {
+			tx_skb = skb_dequeue(&(context->tx_q[PRIO_Q_MID]));
+			if (!tx_skb) {
+				continue;
+			}
+			atomic_dec(&queue_items[PRIO_Q_MID]);
+		} else if (atomic_read(&queue_items[PRIO_Q_LOW]) > 0) {
+			tx_skb = skb_dequeue(&(context->tx_q[PRIO_Q_LOW]));
+			if (!tx_skb) {
+				continue;
+			}
+			atomic_dec(&queue_items[PRIO_Q_LOW]);
+		} else {
+#if 0
+			printk(KERN_ERR "%s: not ready 2 [%d %d]\n", __func__,
+					atomic_read(&queue_items[PRIO_Q_OTHERS]),
+					atomic_read(&queue_items[PRIO_Q_SERIAL]));
+#endif
+			msleep(1);
+			continue;
+		}
+
+		if (atomic_read(&tx_pending))
+			atomic_dec(&tx_pending);
+
+		retry = MAX_WRITE_RETRIES;
+
+		/* resume network tx queue if bearable load */
+		cb = (struct esp_skb_cb *)tx_skb->cb;
+		if (cb && cb->priv && atomic_read(&tx_pending) < TX_RESUME_THRESHOLD) {
+			esp_tx_resume(cb->priv);
+			#if TEST_RAW_TP
+				esp_raw_tp_queue_resume();
+			#endif
+		}
+
+		buf_needed = (tx_skb->len + ESP_RX_BUFFER_SIZE - 1) / ESP_RX_BUFFER_SIZE;
+
+		/*If SDIO slave buffer is available to write then only write data
+		else wait till buffer is available*/
+		ret = is_sdio_write_buffer_available(buf_needed);
+		if(!ret) {
+			dev_kfree_skb(tx_skb);
+			continue;
+		}
+
+		pos = tx_skb->data;
+		data_left = len_to_send = 0;
+
+		data_left = tx_skb->len;
+		pad = ESP_BLOCK_SIZE - (data_left % ESP_BLOCK_SIZE);
+		data_left += pad;
+
+
+		do {
+			block_cnt = data_left / ESP_BLOCK_SIZE;
+			len_to_send = data_left;
+			ret = esp_write_block(context, ESP_SLAVE_CMD53_END_ADDR - len_to_send,
+					pos, (len_to_send + 3) & (~3), ACQUIRE_LOCK);
+
+			if (ret) {
+				printk (KERN_ERR "%s: Failed to send data: %d %d %d\n", __func__, ret, len_to_send, data_left);
+				break;
+			}
+
+			data_left -= len_to_send;
+			pos += len_to_send;
+		} while (data_left);
+
+		if (ret) {
+			/* drop the packet */
+			dev_kfree_skb(tx_skb);
+			continue;
+		}
+
+		context->tx_buffer_count += buf_needed;
+		context->tx_buffer_count = context->tx_buffer_count % ESP_TX_BUFFER_MAX;
+
+		dev_kfree_skb(tx_skb);
+		tx_skb = NULL;
+	}
+
+	do_exit(0);
+	return 0;
+}
+
+static struct esp_sdio_context * init_sdio_func(struct sdio_func *func)
+{
+	struct esp_sdio_context *context = NULL;
+	int ret = 0;
+
+	if (!func)
+		return NULL;
+
+	context = &sdio_context;
+
+	context->func = func;
+
+	sdio_claim_host(func);
+
+	/* Enable Function */
+	ret = sdio_enable_func(func);
+	if (ret) {
+		return NULL;
+	}
+
+	/* Register IRQ */
+	ret = sdio_claim_irq(func, esp_handle_isr);
+	if (ret) {
+		sdio_disable_func(func);
+		return NULL;
+	}
+
+	/* Set private data */
+	sdio_set_drvdata(func, context);
+
+	context->state = ESP_CONTEXT_INIT;
+
+	sdio_release_host(func);
+
+	return context;
+}
+
+#if ENABLE_MONITOR_PROCESS
+static int monitor_process(void *data)
+{
+	u32 val, intr, len_reg, rdata, old_len = 0;
+	struct esp_sdio_context *context = (struct esp_sdio_context *) data;
+	struct sk_buff *skb;
+
+	while (!kthread_should_stop()) {
+		msleep(5000);
+
+		val = intr = len_reg = rdata = 0;
+
+		esp_read_reg(context, ESP_SLAVE_PACKET_LEN_REG,
+				(u8 *) &val, sizeof(val), ACQUIRE_LOCK);
+
+		len_reg = val & ESP_SLAVE_LEN_MASK;
+
+		val = 0;
+		esp_read_reg(context, ESP_SLAVE_TOKEN_RDATA, (u8 *) &val,
+				sizeof(val), ACQUIRE_LOCK);
+
+		rdata = ((val >> 16) & ESP_TX_BUFFER_MASK);
+
+		esp_read_reg(context, ESP_SLAVE_INT_ST_REG,
+				(u8 *) &intr, sizeof(intr), ACQUIRE_LOCK);
+
+
+		if (len_reg > context->rx_byte_count) {
+			if (old_len && (context->rx_byte_count == old_len)) {
+				printk (KERN_DEBUG "Monitor thread ----> [%d - %d] [%d - %d] %d\n",
+						len_reg, context->rx_byte_count,
+						rdata, context->tx_buffer_count, intr);
+
+				skb = read_packet(context->adapter);
+
+				if (!skb)
+					continue;
+
+				if (skb->len)
+					printk (KERN_DEBUG "%s: Flushed %d bytes\n", __func__, skb->len);
+
+				/* drop the packet */
+				dev_kfree_skb(skb);
+				skb = NULL;
+			}
+		}
+
+		old_len = context->rx_byte_count;
+	}
+
+	do_exit(0);
+	return 0;
+}
+#endif
+
+static int esp_probe(struct sdio_func *func,
+		     const struct sdio_device_id *id)
+{
+	struct esp_sdio_context *context = NULL;
+	int ret = 0;
+
+	if (func->num != 1) {
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s: ESP network device detected\n", __func__);
+
+	context = init_sdio_func(func);
+
+	if (!context) {
+		return -ENOMEM;
+	}
+
+	context->state = ESP_CONTEXT_READY;
+	atomic_set(&tx_pending, 0);
+	ret = init_context(context);
+	if (ret) {
+		deinit_sdio_func(func);
+		return ret;
+	}
+
+	tx_thread = kthread_run(tx_process, context->adapter, "esp32_TX");
+
+	if (!tx_thread)
+		printk (KERN_ERR "Failed to create esp32_sdio TX thread\n");
+
+	context->adapter->dev = &func->dev;
+	generate_slave_intr(context, BIT(ESP_OPEN_DATA_PATH));
+
+
+#if ENABLE_MONITOR_PROCESS
+	monitor_thread = kthread_run(monitor_process, context, "Monitor process");
+
+	if (!monitor_thread)
+		printk (KERN_ERR "Failed to create monitor thread\n");
+#endif
+
+	return ret;
+}
+
+static int esp_suspend(struct device *dev)
+{
+	struct sdio_func *func = NULL;
+	struct esp_sdio_context *context = NULL;
+
+	if (!dev) {
+		printk(KERN_INFO "Failed to inform ESP that host is suspending\n");
+		return -1;
+	}
+
+	func = dev_to_sdio_func(dev);
+
+	printk(KERN_INFO "----> Host Suspend\n");
+	msleep(1000);
+
+	context = sdio_get_drvdata(func);
+
+	if (!context) {
+		printk(KERN_INFO "Failed to inform ESP that host is suspending\n");
+		return -1;
+	}
+
+	host_sleep = 1;
+
+	generate_slave_intr(context, BIT(ESP_POWER_SAVE_ON));
+	msleep(10);
+
+	sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+#if 0
+	/* Enale OOB IRQ and host wake up */
+	enable_irq(SDIO_OOB_IRQ);
+	enable_irq_wake(SDIO_OOB_IRQ);
+#endif
+	return 0;
+}
+
+static int esp_resume(struct device *dev)
+{
+	struct sdio_func *func = NULL;
+	struct esp_sdio_context *context = NULL;
+
+	if (!dev) {
+		printk(KERN_INFO "Failed to inform ESP that host is awake\n");
+		return -1;
+	}
+
+	func = dev_to_sdio_func(dev);
+
+	printk(KERN_INFO "-----> Host Awake\n");
+#if 0
+	/* Host woke up.. Disable OOB IRQ */
+	disable_irq_wake(SDIO_OOB_IRQ);
+	disable_irq(SDIO_OOB_IRQ);
+#endif
+
+
+	context = sdio_get_drvdata(func);
+
+	if (!context) {
+		printk(KERN_INFO "Failed to inform ESP that host is awake\n");
+		return -1;
+	}
+
+	/*     generate_slave_intr(context, BIT(ESP_RESET));*/
+	get_firmware_data(context);
+	msleep(100);
+	generate_slave_intr(context, BIT(ESP_POWER_SAVE_OFF));
+	host_sleep = 0;
+	return 0;
+}
+
+static const struct dev_pm_ops esp_pm_ops = {
+	.suspend = esp_suspend,
+	.resume = esp_resume,
+};
+
+/* SDIO driver structure to be registered with kernel */
+static struct sdio_driver esp_sdio_driver = {
+	.name		= "esp_sdio",
+	.id_table	= esp_devices,
+	.probe		= esp_probe,
+	.remove		= esp_remove,
+	.drv = {
+		.owner = THIS_MODULE,
+		.pm = &esp_pm_ops,
+	}
+
+};
+
+int esp_init_interface_layer(struct esp_adapter *adapter)
+{
+	if (!adapter)
+		return -EINVAL;
+
+	adapter->if_context = &sdio_context;
+	adapter->if_ops = &if_ops;
+	sdio_context.adapter = adapter;
+
+	return sdio_register_driver(&esp_sdio_driver);
+}
+
+void process_event_esp_bootup(struct esp_adapter *adapter, u8 *evt_buf, u8 len)
+{
+	u8 len_left = len, tag_len;
+	u8 *pos;
+	struct esp_sdio_context *context = &sdio_context;
+
+	if (!adapter)
+		return;
+
+	if (!evt_buf)
+		return;
+
+	pos = evt_buf;
+
+	while (len_left) {
+		tag_len = *(pos + 1);
+
+		printk(KERN_INFO "EVENT: %d\n", *pos);
+
+		if (*pos == ESP_BOOTUP_CAPABILITY) {
+
+			adapter->capabilities = *(pos + 2);
+			process_capabilities(adapter);
+			print_capabilities(*(pos + 2));
+
+		} else if (*pos == ESP_BOOTUP_FIRMWARE_CHIP_ID){
+
+			printk(KERN_INFO "ESP chipset detected [%s]\n",
+				*(pos+2)==ESP_FIRMWARE_CHIP_ESP32 ? "esp32":
+				*(pos+2)==ESP_FIRMWARE_CHIP_ESP32S2 ? "esp32-s2" :
+				*(pos+2)==ESP_FIRMWARE_CHIP_ESP32C3 ? "esp32-c3" :
+				*(pos+2)==ESP_FIRMWARE_CHIP_ESP32S3 ? "esp32-s3" :
+				"unknown");
+
+			if (*(pos+2)!=ESP_FIRMWARE_CHIP_ESP32)
+				printk(KERN_ERR "SDIO is only supported with ESP32\n");
+
+		} else if (*pos == ESP_BOOTUP_TEST_RAW_TP) {
+			process_test_capabilities(*(pos + 2));
+
+		} else if (*pos == ESP_BOOTUP_FW_DATA) {
+
+			if (tag_len != sizeof(struct fw_data))
+				printk(KERN_INFO "Length not matching to firmware data size\n");
+			else
+				if (process_fw_data((struct fw_data*)(pos + 2)))
+					if (context->func) {
+						generate_slave_intr(context, BIT(ESP_CLOSE_DATA_PATH));
+						return;
+					}
+
+		} else {
+			printk (KERN_WARNING "Unsupported tag in event");
+		}
+
+		pos += (tag_len+2);
+		len_left -= (tag_len+2);
+	}
+
+	if (esp_add_card(adapter)) {
+		printk(KERN_ERR "network iterface init failed\n");
+		generate_slave_intr(context, BIT(ESP_CLOSE_DATA_PATH));
+	}
+}
+
+void esp_deinit_interface_layer(void)
+{
+	sdio_unregister_driver(&esp_sdio_driver);
+}
+
+static int __init esp_sdio_init(void)
+{
+	return esp_init();
+}
+
+static void __exit esp_sdio_exit(void)
+{
+	esp_exit();
+}
+
+module_init(esp_sdio_init);
+module_exit(esp_sdio_exit);
+
+MODULE_AUTHOR("Amey Inamdar <amey.inamdar@espressif.com>");
+MODULE_AUTHOR("Mangesh Malusare <mangesh.malusare@espressif.com>");
+MODULE_AUTHOR("Yogesh Mantri <yogesh.mantri@espressif.com>");
+MODULE_DESCRIPTION("SDIO Driver for ESP-Hosted solution");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c
new file mode 100644
index 0000000..64739b0
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.c
@@ -0,0 +1,160 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include "esp_sdio_api.h"
+
+static int esp_read_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	*data = sdio_readb(func, reg, &ret);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_write_byte(struct esp_sdio_context *context, u32 reg, u8 data, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	sdio_writeb(func, data, reg, &ret);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_read_multi_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	ret = sdio_memcpy_fromio(func, data, reg, size);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+static int esp_write_multi_byte(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	struct sdio_func *func = NULL;
+	int ret;
+
+	if (!context || !context->func || !data) {
+		printk (KERN_ERR "%s: Invalid or incomplete arguments!\n", __func__);
+		return -1;
+	}
+
+	func = context->func;
+
+	if (is_lock_needed)
+		sdio_claim_host(func);
+
+	ret = sdio_memcpy_toio(func, reg, data, size);
+
+	if (is_lock_needed)
+		sdio_release_host(func);
+
+	return ret;
+}
+
+int esp_read_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	/* Need to apply address mask when reading/writing slave registers */
+	reg &= ESP_ADDRESS_MASK;
+
+	if (size <= 1) {
+		return esp_read_byte(context, reg, data, is_lock_needed);
+	} else {
+		return esp_read_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_read_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	if (size <= 1) {
+		return esp_read_byte(context, reg, data, is_lock_needed);
+	} else {
+		return esp_read_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_write_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	/* Need to apply address mask when reading/writing slave registers */
+	reg &= ESP_ADDRESS_MASK;
+
+	if (size <= 1) {
+		return esp_write_byte(context, reg, *data, is_lock_needed);
+	} else {
+		return esp_write_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
+int esp_write_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed)
+{
+	if (size <= 1) {
+		return esp_write_byte(context, reg, *data, is_lock_needed);
+	} else {
+		return esp_write_multi_byte(context, reg, data, size, is_lock_needed);
+	}
+}
+
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h
new file mode 100644
index 0000000..1e26d73
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_api.h
@@ -0,0 +1,29 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _ESP_SDIO_API_H_
+#define _ESP_SDIO_API_H_
+#include "esp_sdio_decl.h"
+
+int esp_read_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_read_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_write_reg(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+int esp_write_block(struct esp_sdio_context *context, u32 reg, u8 *data, u16 size, u8 is_lock_needed);
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h
new file mode 100644
index 0000000..1758d5b
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/sdio/esp_sdio_decl.h
@@ -0,0 +1,100 @@
+/*
+ * Espressif Systems Wireless LAN device driver
+ *
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#ifndef _ESP_DECL_H_
+#define _ESP_DECL_H_
+
+#include "esp.h"
+
+/* Interrupt Status */
+#define ESP_SLAVE_BIT0_INT             BIT(0)
+#define ESP_SLAVE_BIT1_INT             BIT(1)
+#define ESP_SLAVE_BIT2_INT             BIT(2)
+#define ESP_SLAVE_BIT3_INT             BIT(3)
+#define ESP_SLAVE_BIT4_INT             BIT(4)
+#define ESP_SLAVE_BIT5_INT             BIT(5)
+#define ESP_SLAVE_BIT6_INT             BIT(6)
+#define ESP_SLAVE_BIT7_INT             BIT(7)
+#define ESP_SLAVE_RX_UNDERFLOW_INT     BIT(16)
+#define ESP_SLAVE_TX_OVERFLOW_INT      BIT(17)
+#define ESP_SLAVE_RX_NEW_PACKET_INT    BIT(23)
+
+
+#define ESP_SLAVE_CMD53_END_ADDR       0x1F800
+#define ESP_SLAVE_LEN_MASK             0xFFFFF
+#define ESP_BLOCK_SIZE                 512
+#define ESP_RX_BYTE_MAX                0x100000
+#define ESP_RX_BUFFER_SIZE             2048
+
+#define ESP_TX_BUFFER_MASK             0xFFF
+#define ESP_TX_BUFFER_MAX              0x1000
+#define ESP_MAX_BUF_CNT                10
+
+#define ESP_SLAVE_SLCHOST_BASE         0x3FF55000
+
+#define ESP_SLAVE_SCRATCH_REG_7        (ESP_SLAVE_SLCHOST_BASE + 0x8C)
+/* SLAVE registers */
+/* Interrupt Registers */
+#define ESP_SLAVE_INT_RAW_REG          (ESP_SLAVE_SLCHOST_BASE + 0x50)
+#define ESP_SLAVE_INT_ST_REG           (ESP_SLAVE_SLCHOST_BASE + 0x58)
+#define ESP_SLAVE_INT_CLR_REG          (ESP_SLAVE_SLCHOST_BASE + 0xD4)
+
+/* Data path registers*/
+#define ESP_SLAVE_PACKET_LEN_REG       (ESP_SLAVE_SLCHOST_BASE + 0x60)
+#define ESP_SLAVE_TOKEN_RDATA          (ESP_SLAVE_SLCHOST_BASE + 0x44)
+
+/* Scratch registers*/
+#define ESP_SLAVE_SCRATCH_REG_0        (ESP_SLAVE_SLCHOST_BASE + 0x6C)
+#define ESP_SLAVE_SCRATCH_REG_1        (ESP_SLAVE_SLCHOST_BASE + 0x70)
+#define ESP_SLAVE_SCRATCH_REG_2        (ESP_SLAVE_SLCHOST_BASE + 0x74)
+#define ESP_SLAVE_SCRATCH_REG_3        (ESP_SLAVE_SLCHOST_BASE + 0x78)
+#define ESP_SLAVE_SCRATCH_REG_4        (ESP_SLAVE_SLCHOST_BASE + 0x7C)
+#define ESP_SLAVE_SCRATCH_REG_6        (ESP_SLAVE_SLCHOST_BASE + 0x88)
+#define ESP_SLAVE_SCRATCH_REG_8        (ESP_SLAVE_SLCHOST_BASE + 0x9C)
+#define ESP_SLAVE_SCRATCH_REG_9        (ESP_SLAVE_SLCHOST_BASE + 0xA0)
+#define ESP_SLAVE_SCRATCH_REG_10       (ESP_SLAVE_SLCHOST_BASE + 0xA4)
+#define ESP_SLAVE_SCRATCH_REG_11       (ESP_SLAVE_SLCHOST_BASE + 0xA8)
+#define ESP_SLAVE_SCRATCH_REG_12       (ESP_SLAVE_SLCHOST_BASE + 0xAC)
+#define ESP_SLAVE_SCRATCH_REG_13       (ESP_SLAVE_SLCHOST_BASE + 0xB0)
+#define ESP_SLAVE_SCRATCH_REG_14       (ESP_SLAVE_SLCHOST_BASE + 0xB4)
+#define ESP_SLAVE_SCRATCH_REG_15       (ESP_SLAVE_SLCHOST_BASE + 0xB8)
+
+#define ESP_ADDRESS_MASK              0x3FF
+
+#define ESP_VENDOR_ID                 0x6666
+#define ESP_DEVICE_ID_1               0x2222
+#define ESP_DEVICE_ID_2               0x3333
+
+
+enum context_state {
+	ESP_CONTEXT_DISABLED = 0,
+	ESP_CONTEXT_INIT,
+	ESP_CONTEXT_READY
+};
+
+struct esp_sdio_context {
+	struct esp_adapter     *adapter;
+	struct sdio_func       *func;
+	enum context_state     state;
+	struct sk_buff_head    tx_q[MAX_PRIORITY_QUEUES];
+	u32                    rx_byte_count;
+	u32                    tx_buffer_count;
+};
+
+#endif
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c
new file mode 100644
index 0000000..69fcc09
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.c
@@ -0,0 +1,712 @@
+/*
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#define DEBUG
+
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include "esp_spi.h"
+#include "esp_if.h"
+#include "esp_api.h"
+#include "esp_bt_api.h"
+#include "esp_kernel_port.h"
+#include "esp_stats.h"
+#include "main.h"
+
+#define NUMBER_1M               1000000
+#define TX_MAX_PENDING_COUNT    100
+#define TX_RESUME_THRESHOLD     (TX_MAX_PENDING_COUNT/5)
+
+#ifdef CONFIG_ESP_HOSTED_NG_NO_ADJUST_SPI_CLOCK
+#define ALLOW_ADJUST_SPI_CLOCK	0
+#else
+#define ALLOW_ADJUST_SPI_CLOCK	1
+#endif
+
+#ifdef CONFIG_ESP_HOSTED_NG_NO_CS_CHANGE
+#define ALLOW_CS_CHANGE	0
+#else
+#define ALLOW_CS_CHANGE	1
+#endif
+
+static struct sk_buff *read_packet(struct esp_adapter *adapter);
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb);
+static void adjust_spi_clock(struct esp_spi_context *spi_ctx, u8 spi_clk_mhz);
+
+volatile u8 data_path = 0;
+volatile u8 host_sleep = 0;
+static struct esp_adapter *adapter;
+static char hardware_type = ESP_FIRMWARE_CHIP_UNRECOGNIZED;
+static atomic_t tx_pending;
+static uint8_t esp_reset_after_module_load;
+
+static struct esp_if_ops if_ops = {
+	.read		= read_packet,
+	.write		= write_packet,
+};
+
+static DEFINE_MUTEX(spi_lock);
+
+static void open_data_path(void)
+{
+	atomic_set(&tx_pending, 0);
+	msleep(200);
+	data_path = OPEN_DATAPATH;
+}
+
+static void close_data_path(void)
+{
+	data_path = CLOSE_DATAPATH;
+	msleep(200);
+}
+
+static irqreturn_t spi_data_ready_interrupt_handler(int irq, void *dev_id)
+{
+	struct esp_spi_context *spi_ctx = dev_id;
+	/* ESP peripheral has queued buffer for transmission */
+	if (spi_ctx->spi_workqueue)
+ 		queue_work(spi_ctx->spi_workqueue, &spi_ctx->spi_work);
+
+ 	return IRQ_HANDLED;
+ }
+
+static irqreturn_t spi_interrupt_handler(int irq, void *dev_id)
+{
+	struct esp_spi_context *spi_ctx = dev_id;
+	/* ESP peripheral is ready for next SPI transaction */
+	if (spi_ctx->spi_workqueue)
+		queue_work(spi_ctx->spi_workqueue, &spi_ctx->spi_work);
+
+	return IRQ_HANDLED;
+}
+
+static struct sk_buff *read_packet(struct esp_adapter *adapter)
+{
+	struct esp_spi_context *spi_ctx;
+	struct sk_buff *skb = NULL;
+
+	if (!data_path) {
+		return NULL;
+	}
+
+	if (!adapter || !adapter->if_context) {
+		printk (KERN_ERR "%s: Invalid args\n", __func__);
+		return NULL;
+	}
+
+	spi_ctx = adapter->if_context;
+
+	if (spi_ctx->spi) {
+		skb = skb_dequeue(&(spi_ctx->rx_q[PRIO_Q_HIGH]));
+		if (!skb)
+			skb = skb_dequeue(&(spi_ctx->rx_q[PRIO_Q_MID]));
+		if (!skb)
+			skb = skb_dequeue(&(spi_ctx->rx_q[PRIO_Q_LOW]));
+	} else {
+		printk (KERN_ERR "%s: Invalid args\n", __func__);
+		return NULL;
+	}
+
+	return skb;
+}
+
+static int write_packet(struct esp_adapter *adapter, struct sk_buff *skb)
+{
+	u32 max_pkt_size = SPI_BUF_SIZE - sizeof(struct esp_payload_header);
+	struct esp_payload_header *payload_header = (struct esp_payload_header *) skb->data;
+	struct esp_skb_cb * cb = NULL;
+        struct esp_spi_context *spi_ctx;
+
+	if (!adapter || !adapter->if_context || !skb || !skb->data || !skb->len) {
+		printk (KERN_ERR "%s: Invalid args\n", __func__);
+		if(skb) {
+			dev_kfree_skb(skb);
+			skb = NULL;
+		}
+		return -EINVAL;
+	}
+
+	spi_ctx = adapter->if_context;
+
+	if (skb->len > max_pkt_size) {
+		printk (KERN_ERR "%s: Drop pkt of len[%u] > max spi transport len[%u]\n",
+				__func__, skb->len, max_pkt_size);
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+
+	if (!data_path) {
+		printk(KERN_INFO "esp32: %s:%u datapath closed\n",__func__,__LINE__);
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+
+	cb = (struct esp_skb_cb *)skb->cb;
+	if (cb && cb->priv && (atomic_read(&tx_pending) >= TX_MAX_PENDING_COUNT)) {
+		esp_tx_pause(cb->priv);
+		dev_kfree_skb(skb);
+		skb = NULL;
+		/*printk(KERN_ERR "esp32: %s: TX Pause busy", __func__);*/
+		if (spi_ctx->spi_workqueue)
+			queue_work(spi_ctx->spi_workqueue, &spi_ctx->spi_work);
+		return -EBUSY;
+	}
+
+	/* Enqueue SKB in tx_q */
+	if (payload_header->if_type == ESP_INTERNAL_IF) {
+		skb_queue_tail(&spi_ctx->tx_q[PRIO_Q_HIGH], skb);
+	} else if (payload_header->if_type == ESP_HCI_IF) {
+		skb_queue_tail(&spi_ctx->tx_q[PRIO_Q_MID], skb);
+	} else {
+		skb_queue_tail(&spi_ctx->tx_q[PRIO_Q_LOW], skb);
+		atomic_inc(&tx_pending);
+	}
+
+	if (spi_ctx->spi_workqueue)
+		queue_work(spi_ctx->spi_workqueue, &spi_ctx->spi_work);
+
+	return 0;
+}
+
+void process_event_esp_bootup(struct esp_adapter *adapter, u8 *evt_buf, u8 len)
+{
+	/* Bootup event will be received whenever ESP is booted.
+	 * It is termed 'First bootup' when this event is received
+	 * the first time module loaded. It is termed 'Second & onward bootup' when
+	 * there is ESP reset (reason may be manual reset of ESP or any crash at ESP)
+	 */
+	u8 len_left = len, tag_len;
+	u8 *pos;
+	uint8_t iface_idx = 0;
+	uint8_t prio_q_idx = 0;
+	struct esp_spi_context *spi_ctx;
+
+	if (!adapter)
+		return;
+	spi_ctx = adapter->if_context;
+
+	if (!evt_buf)
+		return;
+
+	/* Second & onward bootup, cleanup and re-init the driver */
+	if (esp_reset_after_module_load)
+		set_bit(ESP_CLEANUP_IN_PROGRESS, &adapter->state_flags);
+
+	pos = evt_buf;
+
+	while (len_left) {
+
+		tag_len = *(pos + 1);
+
+		printk(KERN_INFO "EVENT: %d\n", *pos);
+
+		if (*pos == ESP_BOOTUP_CAPABILITY) {
+
+			adapter->capabilities = *(pos + 2);
+
+		} else if (*pos == ESP_BOOTUP_FW_DATA) {
+
+			if (tag_len != sizeof(struct fw_data))
+				printk(KERN_INFO "Length not matching to firmware data size\n");
+			else
+				if (process_fw_data((struct fw_data*)(pos + 2))) {
+					esp_remove_card(adapter);
+					return;
+				}
+
+		} else if (*pos == ESP_BOOTUP_SPI_CLK_MHZ){
+
+			if (spi_ctx) {
+				adjust_spi_clock(spi_ctx, *(pos + 2));
+				adapter->dev = &spi_ctx->spi->dev;
+			}
+
+		} else if (*pos == ESP_BOOTUP_FIRMWARE_CHIP_ID){
+
+			hardware_type = *(pos+2);
+
+		} else if(*pos == ESP_BOOTUP_TEST_RAW_TP) {
+			process_test_capabilities(*(pos + 2));
+		} else {
+			printk (KERN_WARNING "Unsupported tag in event");
+		}
+
+		pos += (tag_len+2);
+		len_left -= (tag_len+2);
+	}
+
+	if ((hardware_type != ESP_FIRMWARE_CHIP_ESP32) &&
+	    (hardware_type != ESP_FIRMWARE_CHIP_ESP32S2) &&
+	    (hardware_type != ESP_FIRMWARE_CHIP_ESP32C3) &&
+	    (hardware_type != ESP_FIRMWARE_CHIP_ESP32S3)) {
+		printk(KERN_INFO "ESP chipset not recognized, ignoring [%d]\n", hardware_type);
+		hardware_type = ESP_FIRMWARE_CHIP_UNRECOGNIZED;
+	} else {
+		printk(KERN_INFO "ESP chipset detected [%s]\n",
+				hardware_type==ESP_FIRMWARE_CHIP_ESP32 ? "esp32":
+				hardware_type==ESP_FIRMWARE_CHIP_ESP32S2 ? "esp32-s2" :
+				hardware_type==ESP_FIRMWARE_CHIP_ESP32C3 ? "esp32-c3" :
+				hardware_type==ESP_FIRMWARE_CHIP_ESP32S3 ? "esp32-s3" :
+				"unknown");
+	}
+
+	if (esp_reset_after_module_load) {
+
+		/* Second & onward bootup:
+		 *
+		 * SPI is software and not a hardware based module.
+		 * When bootup event is received, we should discard all prior commands,
+		 * old messages pending at network and re-initialize everything.
+		 *
+		 * Such handling is not required
+		 * 1. for SDIO
+		 *   as Removal of SDIO triggers complete Deinit and on SDIO insertion/
+		 *   detection, i.e., after probing, initialization is triggered
+		 *
+		 * 2. On first bootup (if counterpart of this else)
+		 *   First bootup event is received immediately after module insertion.
+		 *   As all network or cmds are init and clean for the first time,
+		 *   there is no need to re-init them
+		 */
+
+		for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++) {
+			skb_queue_purge(&spi_ctx->tx_q[prio_q_idx]);
+		}
+
+		for (iface_idx=0; iface_idx < ESP_MAX_INTERFACE; iface_idx++) {
+
+			struct esp_wifi_device *priv = adapter->priv[iface_idx];
+
+			if (!priv)
+				continue;
+
+			if (priv->scan_in_progress)
+				ESP_MARK_SCAN_DONE(priv, true);
+
+			if (priv->ndev &&
+			    wireless_dev_current_bss_exists(&priv->wdev)) {
+				CFG80211_DISCONNECTED(priv->ndev,
+						0, NULL, 0, false, GFP_KERNEL);
+			}
+		}
+
+		esp_remove_card(adapter);
+
+		for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++) {
+			skb_queue_head_init(&spi_ctx->tx_q[prio_q_idx]);
+		}
+	}
+
+	if (esp_add_card(adapter)) {
+		printk(KERN_ERR "network iterface init failed\n");
+	}
+
+	process_capabilities(adapter);
+	print_capabilities(adapter->capabilities);
+
+
+	esp_reset_after_module_load = 1;
+}
+
+
+static int process_rx_buf(struct esp_spi_context *spi_ctx, struct sk_buff *skb)
+{
+	struct esp_payload_header *header;
+	u16 len = 0;
+	u16 offset = 0;
+
+	if (!skb)
+		return -EINVAL;
+
+	header = (struct esp_payload_header *) skb->data;
+
+	if (header->if_type >= ESP_MAX_IF) {
+		return -EINVAL;
+	}
+
+	offset = le16_to_cpu(header->offset);
+
+	/* Validate received SKB. Check len and offset fields */
+	if (offset != sizeof(struct esp_payload_header)) {
+		return -EINVAL;
+	}
+
+	len = le16_to_cpu(header->len);
+	if (!len) {
+		return -EINVAL;
+	}
+
+	len += sizeof(struct esp_payload_header);
+
+	if (len > SPI_BUF_SIZE) {
+		return -EINVAL;
+	}
+
+	/* Trim SKB to actual size */
+	skb_trim(skb, len);
+
+
+	if (!data_path) {
+		/*printk(KERN_INFO "%s:%u datapath closed\n",__func__,__LINE__);*/
+		return -EPERM;
+	}
+
+	/* enqueue skb for read_packet to pick it */
+	if (header->if_type == ESP_INTERNAL_IF)
+		skb_queue_tail(&spi_ctx->rx_q[PRIO_Q_HIGH], skb);
+	else if (header->if_type == ESP_HCI_IF)
+		skb_queue_tail(&spi_ctx->rx_q[PRIO_Q_MID], skb);
+	else
+		skb_queue_tail(&spi_ctx->rx_q[PRIO_Q_LOW], skb);
+
+	/* indicate reception of new packet */
+	esp_process_new_packet_intr(spi_ctx->adapter);
+
+	return 0;
+}
+
+static void esp_spi_work(struct work_struct *work)
+{
+	struct spi_transfer trans;
+	struct sk_buff *tx_skb = NULL, *rx_skb = NULL;
+	struct esp_skb_cb * cb = NULL;
+	u8 *rx_buf = NULL;
+	int ret = 0;
+	volatile int trans_ready, rx_pending;
+	struct esp_spi_context *spi_ctx;
+
+
+	mutex_lock(&spi_lock);
+
+	spi_ctx = container_of(work, struct esp_spi_context, spi_work);
+
+	trans_ready = gpiod_get_value(spi_ctx->handshake);
+	rx_pending = gpiod_get_value(spi_ctx->data_ready);
+
+//	printk(KERN_INFO "%s: trans_ready=%d	rx_pending=%d\n",
+//			__func__, trans_ready, rx_pending);
+
+	if (trans_ready) {
+		if (data_path) {
+			tx_skb = skb_dequeue(&spi_ctx->tx_q[PRIO_Q_HIGH]);
+			if (!tx_skb)
+				tx_skb = skb_dequeue(&spi_ctx->tx_q[PRIO_Q_MID]);
+			if (!tx_skb)
+				tx_skb = skb_dequeue(&spi_ctx->tx_q[PRIO_Q_LOW]);
+			if (tx_skb) {
+				if (atomic_read(&tx_pending))
+					atomic_dec(&tx_pending);
+
+				/* resume network tx queue if bearable load */
+				cb = (struct esp_skb_cb *)tx_skb->cb;
+				if (cb && cb->priv && atomic_read(&tx_pending) < TX_RESUME_THRESHOLD) {
+					esp_tx_resume(cb->priv);
+#if TEST_RAW_TP
+					esp_raw_tp_queue_resume();
+#endif
+				}
+			}
+		}
+
+		if (rx_pending || tx_skb) {
+			memset(&trans, 0, sizeof(trans));
+			trans.speed_hz = spi_ctx->spi_clk_mhz * NUMBER_1M;
+
+			/* Setup and execute SPI transaction
+			 * 	Tx_buf: Check if tx_q has valid buffer for transmission,
+			 * 		else keep it blank
+			 *
+			 * 	Rx_buf: Allocate memory for incoming data. This will be freed
+			 *		immediately if received buffer is invalid.
+			 *		If it is a valid buffer, upper layer will free it.
+			 * */
+
+			/* Configure TX buffer if available */
+
+			if (tx_skb) {
+				trans.tx_buf = tx_skb->data;
+				/*print_hex_dump(KERN_ERR, "tx: ", DUMP_PREFIX_ADDRESS, 16, 1, trans.tx_buf, 32, 1);*/
+			} else {
+				tx_skb = esp_alloc_skb(SPI_BUF_SIZE);
+				trans.tx_buf = skb_put(tx_skb, SPI_BUF_SIZE);
+				memset((void*)trans.tx_buf, 0, SPI_BUF_SIZE);
+			}
+
+			/* Configure RX buffer */
+			rx_skb = esp_alloc_skb(SPI_BUF_SIZE);
+			rx_buf = skb_put(rx_skb, SPI_BUF_SIZE);
+
+			memset(rx_buf, 0, SPI_BUF_SIZE);
+
+			trans.rx_buf = rx_buf;
+			trans.len = SPI_BUF_SIZE;
+
+#if ALLOW_CS_CHANGE
+			if (hardware_type == ESP_FIRMWARE_CHIP_ESP32) {
+				trans.cs_change = 1;
+			}
+#endif
+
+			ret = spi_sync_transfer(spi_ctx->spi, &trans, 1);
+			if (ret) {
+				dev_err(&spi_ctx->spi->dev, "SPI Transaction failed: %d", ret);
+				dev_kfree_skb(rx_skb);
+				dev_kfree_skb(tx_skb);
+			} else {
+
+				/* Free rx_skb if received data is not valid */
+				if (process_rx_buf(spi_ctx, rx_skb)) {
+					dev_kfree_skb(rx_skb);
+				}
+
+				if (tx_skb)
+					dev_kfree_skb(tx_skb);
+			}
+		}
+	}
+
+	mutex_unlock(&spi_lock);
+}
+
+static void adjust_spi_clock(struct esp_spi_context *spi_ctx, u8 spi_clk_mhz)
+{
+#if ALLOW_ADJUST_SPI_CLOCK
+	if ((spi_clk_mhz) && (spi_clk_mhz != spi_ctx->spi_clk_mhz)) {
+		printk(KERN_INFO "ESP Reconfigure SPI CLK to %u MHz\n",spi_clk_mhz);
+		spi_ctx->spi_clk_mhz = spi_clk_mhz;
+		spi_ctx->spi->max_speed_hz = spi_clk_mhz * NUMBER_1M;
+	}
+#endif
+}
+
+static void esp_hw_reset(struct esp_spi_context *spi_ctx)
+{
+	dev_dbg(&spi_ctx->spi->dev, "Hardware reset\n");
+
+	gpiod_direction_output(spi_ctx->reset, 1);
+
+	// Set HOST's resetpin set to LOW
+	gpiod_set_value(spi_ctx->reset, 0);
+	udelay(200);
+
+	// Set HOST's resetpin set to IN mode
+	gpiod_direction_input(spi_ctx->reset);
+
+	// Wait for ESP to start
+	msleep(200);
+}
+
+static int esp_spi_probe(struct spi_device *spi)
+{
+	int ret, irq;
+	uint8_t prio_q_idx = 0;
+	struct device *dev = &spi->dev;
+	struct esp_spi_context *spi_ctx;
+
+	dev_dbg(dev, "Probing ESP32 SPI-driver...\n");
+
+	spi_ctx = devm_kzalloc(dev, sizeof(*spi_ctx), GFP_KERNEL);
+	if (!spi_ctx)
+                return -ENOMEM;
+	spi_set_drvdata(spi, spi_ctx);
+
+	spi_ctx->spi = spi;
+	spi_ctx->adapter = adapter;
+	spi_ctx->spi_clk_mhz = spi->max_speed_hz / NUMBER_1M;
+	adapter->if_context = spi_ctx;
+	adapter->dev = dev;
+
+	spi_ctx->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(spi_ctx->reset)) {
+		ret = PTR_ERR(spi_ctx->reset);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Couldn't get Reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	esp_hw_reset(spi_ctx);
+
+	spi_ctx->spi_workqueue = create_workqueue("ESP_SPI_WORK_QUEUE");
+	if (!spi_ctx->spi_workqueue) {
+		printk(KERN_ERR "SPI workqueue failed to create\n");
+                return -EFAULT;
+        }
+        INIT_WORK(&spi_ctx->spi_work, esp_spi_work);
+
+	for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_head_init(&spi_ctx->tx_q[prio_q_idx]);
+		skb_queue_head_init(&spi_ctx->rx_q[prio_q_idx]);
+	}
+
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		dev_err(dev, "%s: spi_setup failed\n", __func__);
+		return ret;
+	}
+
+	dev_info(dev, "ESP32 peripheral is registered to SPI bus [%d]"
+		",chip select [%d], SPI Clock [%d], SPI mode [0x%02x]\n",
+		spi->master->bus_num, spi->chip_select,
+		spi_ctx->spi_clk_mhz, spi->mode);
+
+
+	spi_ctx->handshake = devm_gpiod_get(dev, "handshake", GPIOD_IN);
+	if (IS_ERR(spi_ctx->handshake)) {
+		ret = PTR_ERR(spi_ctx->handshake);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Couldn't get Handshake GPIO: %d\n", ret);
+		return ret;
+        }
+
+	spi_ctx->data_ready = devm_gpiod_get(dev, "dataready", GPIOD_IN);
+	if (IS_ERR(spi_ctx->data_ready)) {
+		ret = PTR_ERR(spi_ctx->data_ready);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Couldn't get Data-Ready GPIO: %d\n", ret);
+		return ret;
+	}
+
+	irq = gpiod_to_irq(spi_ctx->handshake);
+	if (irq < 0) {
+		dev_err(dev, "Can't get IRQ for Handshake GPIO\n");
+		return -EINVAL;
+        }
+	ret = devm_request_irq(dev, irq, spi_interrupt_handler,
+				IRQF_SHARED | IRQF_TRIGGER_RISING,
+				"ESP_SPI",
+				spi_ctx);
+        if (ret < 0) {
+		dev_err(dev, "Failed to request IRQ for SPI: %d\n", ret);
+                return ret;
+        }
+
+	irq = gpiod_to_irq(spi_ctx->data_ready);
+	if (irq < 0) {
+		dev_err(dev, "Can't get IRQ for Data-Ready GPIO\n");
+		return -EINVAL;
+	}
+	ret = devm_request_irq(dev, irq, spi_data_ready_interrupt_handler,
+				IRQF_SHARED | IRQF_TRIGGER_RISING,
+				"ESP_SPI_DATA_READY",
+				spi_ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to request IRQ for Data-Ready GPIO: %d\n", ret);
+                return ret;
+        }
+
+	open_data_path();
+
+	dev_dbg(dev, "Probe success.\n");
+
+	return 0;
+}
+
+static void esp_spi_remove(struct spi_device *spi)
+{
+	uint8_t prio_q_idx = 0;
+	struct esp_spi_context *spi_ctx = spi_get_drvdata(spi);
+
+	disable_irq(gpiod_to_irq(spi_ctx->handshake));
+	disable_irq(gpiod_to_irq(spi_ctx->data_ready));
+	close_data_path();
+
+	for (prio_q_idx=0; prio_q_idx<MAX_PRIORITY_QUEUES; prio_q_idx++) {
+		skb_queue_purge(&spi_ctx->tx_q[prio_q_idx]);
+		skb_queue_purge(&spi_ctx->rx_q[prio_q_idx]);
+	}
+
+	if (spi_ctx->spi_workqueue) {
+		flush_scheduled_work();
+		destroy_workqueue(spi_ctx->spi_workqueue);
+		spi_ctx->spi_workqueue = NULL;
+	}
+
+	esp_remove_card(spi_ctx->adapter);
+
+	if (spi_ctx->adapter->hcidev)
+		esp_deinit_bt(spi_ctx->adapter);
+}
+
+static const struct spi_device_id esp_spi_ids[] = {
+	{ "esp32-spi", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, esp_spi_ids);
+
+static const struct of_device_id esp_dt_ids[] = {
+	{ .compatible = "espressif,esp32-spi" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, esp_dt_ids);
+
+static struct spi_driver esp_spi_driver = {
+	.driver = {
+		.name = "esp32_spi",
+		.of_match_table = of_match_ptr(esp_dt_ids),
+	},
+	.id_table = esp_spi_ids,
+	.probe = esp_spi_probe,
+	.remove = esp_spi_remove,
+};
+
+int esp_init_interface_layer(struct esp_adapter *adapt)
+{
+	int ret;
+
+	if (!adapt)
+		return -EINVAL;
+	adapter = adapt;
+	adapter->if_ops = &if_ops;
+	adapter->if_type = ESP_IF_TYPE_SPI;
+
+	ret = spi_register_driver(&esp_spi_driver);
+	if (ret < 0) {
+		printk(KERN_ERR "Unable to register SPI driver\n");
+                return ret;
+	}
+
+	return 0;
+}
+
+void esp_deinit_interface_layer(void)
+{
+	spi_unregister_driver(&esp_spi_driver);
+}
+
+static int __init esp_spi_init(void)
+{
+	return esp_init();
+}
+
+static void __exit esp_spi_exit(void)
+{
+	esp_exit();
+}
+
+module_init(esp_spi_init);
+module_exit(esp_spi_exit);
+
+MODULE_AUTHOR("Amey Inamdar <amey.inamdar@espressif.com>");
+MODULE_AUTHOR("Mangesh Malusare <mangesh.malusare@espressif.com>");
+MODULE_AUTHOR("Yogesh Mantri <yogesh.mantri@espressif.com>");
+MODULE_AUTHOR("Sergey Suloev <ssuloev@orpaltech.com>");
+MODULE_DESCRIPTION("SPI Driver for ESP-Hosted solution");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h
new file mode 100644
index 0000000..08f3b7e
--- /dev/null
+++ b/drivers/net/wireless/espressif/esp_hosted_ng/spi/esp_spi.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015-2021 Espressif Systems (Shanghai) PTE LTD
+ *
+ * This software file (the "File") is distributed by Espressif Systems (Shanghai)
+ * PTE LTD under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+#ifndef _ESP_SPI_H_
+#define _ESP_SPI_H_
+
+#include "esp.h"
+
+#define HANDSHAKE_PIN           16
+#define SPI_IRQ                 gpio_to_irq(HANDSHAKE_PIN)
+#define SPI_DATA_READY_PIN      27
+#define SPI_DATA_READY_IRQ      gpio_to_irq(SPI_DATA_READY_PIN)
+#define SPI_BUF_SIZE            1600
+
+struct esp_spi_context {
+	struct esp_adapter          *adapter;
+	struct spi_device           *spi;
+	struct gpio_desc            *reset;
+	struct gpio_desc            *handshake;
+	struct gpio_desc            *data_ready;
+	struct sk_buff_head         tx_q[MAX_PRIORITY_QUEUES];
+	struct sk_buff_head         rx_q[MAX_PRIORITY_QUEUES];
+	struct workqueue_struct     *spi_workqueue;
+	struct work_struct          spi_work;
+	/*struct workqueue_struct     *nw_cmd_reinit_workqueue;
+	struct work_struct          nw_cmd_reinit_work;*/
+	uint8_t                     spi_clk_mhz;
+	uint8_t                     reserved[2];
+};
+
+enum {
+	CLOSE_DATAPATH,
+	OPEN_DATAPATH,
+};
+
+
+#endif
-- 
2.25.1

