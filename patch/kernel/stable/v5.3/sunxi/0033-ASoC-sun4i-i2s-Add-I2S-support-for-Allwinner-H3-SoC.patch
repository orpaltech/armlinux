From 311a4d7f64e326dc5b765d4f6f3c593a7847983c Mon Sep 17 00:00:00 2001
From: Sergey Suloev <ssuloev@orpaltech.com>
Date: Tue, 20 Aug 2019 08:34:25 +0300
Subject: [PATCH] ASoC: i2s/sun4i: Add I2S support for Allwinner H3 SoC

---
 sound/soc/sunxi/Kconfig     |    2 +
 sound/soc/sunxi/sun4i-i2s.c | 1977 ++++++++++++++++++++---------------
 sound/soc/sunxi/sun4i-i2s.h |  234 +++++
 3 files changed, 1384 insertions(+), 829 deletions(-)
 create mode 100644 sound/soc/sunxi/sun4i-i2s.h

diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 9cd7009..66d6364 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -39,6 +39,8 @@ config SND_SUN50I_CODEC_ANALOG
 
 config SND_SUN4I_I2S
 	tristate "Allwinner A10 I2S Support"
+	depends on OF
+	depends on DMA_SUN6I
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	select REGMAP_MMIO
 	help
diff --git a/sound/soc/sunxi/sun4i-i2s.c b/sound/soc/sunxi/sun4i-i2s.c
index 7fa5c61..9231a5d 100644
--- a/sound/soc/sunxi/sun4i-i2s.c
+++ b/sound/soc/sunxi/sun4i-i2s.c
@@ -1,12 +1,12 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright (C) 2015 Andrea Venturi
- * Andrea Venturi <be17068@iperbole.bo.it>
+ * ALSA SoC I2S Audio Layer for Allwinner sunXi SoC
  *
- * Copyright (C) 2016 Maxime Ripard
- * Maxime Ripard <maxime.ripard@free-electrons.com>
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
  */
 
+#define DEBUG
+
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
 #include <linux/module.h>
@@ -21,195 +21,39 @@
 #include <sound/soc.h>
 #include <sound/soc-dai.h>
 
-#define SUN4I_I2S_CTRL_REG		0x00
-#define SUN4I_I2S_CTRL_SDO_EN_MASK		GENMASK(11, 8)
-#define SUN4I_I2S_CTRL_SDO_EN(sdo)			BIT(8 + (sdo))
-#define SUN4I_I2S_CTRL_MODE_MASK		BIT(5)
-#define SUN4I_I2S_CTRL_MODE_SLAVE			(1 << 5)
-#define SUN4I_I2S_CTRL_MODE_MASTER			(0 << 5)
-#define SUN4I_I2S_CTRL_TX_EN			BIT(2)
-#define SUN4I_I2S_CTRL_RX_EN			BIT(1)
-#define SUN4I_I2S_CTRL_GL_EN			BIT(0)
-
-#define SUN4I_I2S_FMT0_REG		0x04
-#define SUN4I_I2S_FMT0_LRCLK_POLARITY_MASK	BIT(7)
-#define SUN4I_I2S_FMT0_LRCLK_POLARITY_INVERTED		(1 << 7)
-#define SUN4I_I2S_FMT0_LRCLK_POLARITY_NORMAL		(0 << 7)
-#define SUN4I_I2S_FMT0_BCLK_POLARITY_MASK	BIT(6)
-#define SUN4I_I2S_FMT0_BCLK_POLARITY_INVERTED		(1 << 6)
-#define SUN4I_I2S_FMT0_BCLK_POLARITY_NORMAL		(0 << 6)
-#define SUN4I_I2S_FMT0_SR_MASK			GENMASK(5, 4)
-#define SUN4I_I2S_FMT0_SR(sr)				((sr) << 4)
-#define SUN4I_I2S_FMT0_WSS_MASK			GENMASK(3, 2)
-#define SUN4I_I2S_FMT0_WSS(wss)				((wss) << 2)
-#define SUN4I_I2S_FMT0_FMT_MASK			GENMASK(1, 0)
-#define SUN4I_I2S_FMT0_FMT_RIGHT_J			(2 << 0)
-#define SUN4I_I2S_FMT0_FMT_LEFT_J			(1 << 0)
-#define SUN4I_I2S_FMT0_FMT_I2S				(0 << 0)
-#define SUN4I_I2S_FMT0_POLARITY_INVERTED		(1)
-#define SUN4I_I2S_FMT0_POLARITY_NORMAL			(0)
-
-#define SUN4I_I2S_FMT1_REG		0x08
-#define SUN4I_I2S_FIFO_TX_REG		0x0c
-#define SUN4I_I2S_FIFO_RX_REG		0x10
-
-#define SUN4I_I2S_FIFO_CTRL_REG		0x14
-#define SUN4I_I2S_FIFO_CTRL_FLUSH_TX		BIT(25)
-#define SUN4I_I2S_FIFO_CTRL_FLUSH_RX		BIT(24)
-#define SUN4I_I2S_FIFO_CTRL_TX_MODE_MASK	BIT(2)
-#define SUN4I_I2S_FIFO_CTRL_TX_MODE(mode)		((mode) << 2)
-#define SUN4I_I2S_FIFO_CTRL_RX_MODE_MASK	GENMASK(1, 0)
-#define SUN4I_I2S_FIFO_CTRL_RX_MODE(mode)		(mode)
-
-#define SUN4I_I2S_FIFO_STA_REG		0x18
-
-#define SUN4I_I2S_DMA_INT_CTRL_REG	0x1c
-#define SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN	BIT(7)
-#define SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN	BIT(3)
-
-#define SUN4I_I2S_INT_STA_REG		0x20
-
-#define SUN4I_I2S_CLK_DIV_REG		0x24
-#define SUN4I_I2S_CLK_DIV_MCLK_EN		BIT(7)
-#define SUN4I_I2S_CLK_DIV_BCLK_MASK		GENMASK(6, 4)
-#define SUN4I_I2S_CLK_DIV_BCLK(bclk)			((bclk) << 4)
-#define SUN4I_I2S_CLK_DIV_MCLK_MASK		GENMASK(3, 0)
-#define SUN4I_I2S_CLK_DIV_MCLK(mclk)			((mclk) << 0)
-
-#define SUN4I_I2S_RX_CNT_REG		0x28
-#define SUN4I_I2S_TX_CNT_REG		0x2c
-
-#define SUN4I_I2S_TX_CHAN_SEL_REG	0x30
-#define SUN4I_I2S_CHAN_SEL(num_chan)		(((num_chan) - 1) << 0)
-
-#define SUN4I_I2S_TX_CHAN_MAP_REG	0x34
-#define SUN4I_I2S_TX_CHAN_MAP(chan, sample)	((sample) << (chan << 2))
-
-#define SUN4I_I2S_RX_CHAN_SEL_REG	0x38
-#define SUN4I_I2S_RX_CHAN_MAP_REG	0x3c
-
-/* Defines required for sun8i-h3 support */
-#define SUN8I_I2S_CTRL_BCLK_OUT			BIT(18)
-#define SUN8I_I2S_CTRL_LRCK_OUT			BIT(17)
-
-#define SUN8I_I2S_FMT0_LRCK_PERIOD_MASK		GENMASK(17, 8)
-#define SUN8I_I2S_FMT0_LRCK_PERIOD(period)	((period - 1) << 8)
-
-#define SUN8I_I2S_INT_STA_REG		0x0c
-#define SUN8I_I2S_FIFO_TX_REG		0x20
-
-#define SUN8I_I2S_CHAN_CFG_REG		0x30
-#define SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK	GENMASK(6, 4)
-#define SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(chan)	((chan - 1) << 4)
-#define SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK	GENMASK(2, 0)
-#define SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(chan)	(chan - 1)
-
-#define SUN8I_I2S_TX_CHAN_MAP_REG	0x44
-#define SUN8I_I2S_TX_CHAN_SEL_REG	0x34
-#define SUN8I_I2S_TX_CHAN_OFFSET_MASK		GENMASK(13, 12)
-#define SUN8I_I2S_TX_CHAN_OFFSET(offset)	(offset << 12)
-#define SUN8I_I2S_TX_CHAN_EN_MASK		GENMASK(11, 4)
-#define SUN8I_I2S_TX_CHAN_EN(num_chan)		(((1 << num_chan) - 1) << 4)
-
-#define SUN8I_I2S_RX_CHAN_SEL_REG	0x54
-#define SUN8I_I2S_RX_CHAN_MAP_REG	0x58
-
-struct sun4i_i2s;
-
-/**
- * struct sun4i_i2s_quirks - Differences between SoC variants.
- *
- * @has_reset: SoC needs reset deasserted.
- * @has_slave_select_bit: SoC has a bit to enable slave mode.
- * @has_fmt_set_lrck_period: SoC requires lrclk period to be set.
- * @has_chcfg: tx and rx slot number need to be set.
- * @has_chsel_tx_chen: SoC requires that the tx channels are enabled.
- * @has_chsel_offset: SoC uses offset for selecting dai operational mode.
- * @reg_offset_txdata: offset of the tx fifo.
- * @sun4i_i2s_regmap: regmap config to use.
- * @mclk_offset: Value by which mclkdiv needs to be adjusted.
- * @bclk_offset: Value by which bclkdiv needs to be adjusted.
- * @field_clkdiv_mclk_en: regmap field to enable mclk output.
- * @field_fmt_wss: regmap field to set word select size.
- * @field_fmt_sr: regmap field to set sample resolution.
- * @field_fmt_bclk: regmap field to set clk polarity.
- * @field_fmt_lrclk: regmap field to set frame polarity.
- * @field_fmt_mode: regmap field to set the operational mode.
- * @field_txchanmap: location of the tx channel mapping register.
- * @field_rxchanmap: location of the rx channel mapping register.
- * @field_txchansel: location of the tx channel select bit fields.
- * @field_rxchansel: location of the rx channel select bit fields.
- */
-struct sun4i_i2s_quirks {
-	bool				has_reset;
-	bool				has_slave_select_bit;
-	bool				has_fmt_set_lrck_period;
-	bool				has_chcfg;
-	bool				has_chsel_tx_chen;
-	bool				has_chsel_offset;
-	unsigned int			reg_offset_txdata;	/* TX FIFO */
-	const struct regmap_config	*sun4i_i2s_regmap;
-	unsigned int			mclk_offset;
-	unsigned int			bclk_offset;
-
-	/* Register fields for i2s */
-	struct reg_field		field_clkdiv_mclk_en;
-	struct reg_field		field_fmt_wss;
-	struct reg_field		field_fmt_sr;
-	struct reg_field		field_fmt_bclk;
-	struct reg_field		field_fmt_lrclk;
-	struct reg_field		field_fmt_mode;
-	struct reg_field		field_txchanmap;
-	struct reg_field		field_rxchanmap;
-	struct reg_field		field_txchansel;
-	struct reg_field		field_rxchansel;
-
-	s8	(*get_sr)(const struct sun4i_i2s *, int);
-	s8	(*get_wss)(const struct sun4i_i2s *, int);
-};
-
-struct sun4i_i2s {
-	struct clk	*bus_clk;
-	struct clk	*mod_clk;
-	struct regmap	*regmap;
-	struct reset_control *rst;
-
-	unsigned int	mclk_freq;
-
-	struct snd_dmaengine_dai_dma_data	capture_dma_data;
-	struct snd_dmaengine_dai_dma_data	playback_dma_data;
-
-	/* Register fields for i2s */
-	struct regmap_field	*field_clkdiv_mclk_en;
-	struct regmap_field	*field_fmt_wss;
-	struct regmap_field	*field_fmt_sr;
-	struct regmap_field	*field_fmt_bclk;
-	struct regmap_field	*field_fmt_lrclk;
-	struct regmap_field	*field_fmt_mode;
-	struct regmap_field	*field_txchanmap;
-	struct regmap_field	*field_rxchanmap;
-	struct regmap_field	*field_txchansel;
-	struct regmap_field	*field_rxchansel;
-
-	const struct sun4i_i2s_quirks	*variant;
-};
+#include "sun4i-i2s.h"
 
-struct sun4i_i2s_clk_div {
-	u8	div;
-	u8	val;
-};
 
-static const struct sun4i_i2s_clk_div sun4i_i2s_bclk_div[] = {
+static const struct sun4i_i2s_clkdiv sun4i_i2s_bclk_div[] = {
 	{ .div = 2, .val = 0 },
 	{ .div = 4, .val = 1 },
 	{ .div = 6, .val = 2 },
 	{ .div = 8, .val = 3 },
 	{ .div = 12, .val = 4 },
 	{ .div = 16, .val = 5 },
-	/* TODO - extend divide ratio supported by newer SoCs */
+	{ .div = 32, .val = 6 },
+	{ .div = 64, .val = 7 },
+};
+
+static const struct sun4i_i2s_clkdiv sun8i_i2s_clk_div[] = {
+	{ .div = 1, .val = 1 },
+	{ .div = 2, .val = 2 },
+	{ .div = 4, .val = 3 },
+	{ .div = 6, .val = 4 },
+	{ .div = 8, .val = 5 },
+	{ .div = 12, .val = 6 },
+	{ .div = 16, .val = 7 },
+	{ .div = 24, .val = 8 },
+	{ .div = 32, .val = 9 },
+	{ .div = 48, .val = 10 },
+	{ .div = 64, .val = 11 },
+	{ .div = 96, .val = 12 },
+	{ .div = 128, .val = 13 },
+	{ .div = 176, .val = 14 },
+	{ .div = 192, .val = 15 },
 };
 
-static const struct sun4i_i2s_clk_div sun4i_i2s_mclk_div[] = {
+static const struct sun4i_i2s_clkdiv sun4i_i2s_mclk_div[] = {
 	{ .div = 1, .val = 0 },
 	{ .div = 2, .val = 1 },
 	{ .div = 4, .val = 2 },
@@ -218,72 +62,109 @@ static const struct sun4i_i2s_clk_div sun4i_i2s_mclk_div[] = {
 	{ .div = 12, .val = 5 },
 	{ .div = 16, .val = 6 },
 	{ .div = 24, .val = 7 },
-	/* TODO - extend divide ratio supported by newer SoCs */
+	{ .div = 32, .val = 8 },
+	{ .div = 48, .val = 9 },
+	{ .div = 64, .val = 10 },
+};
+
+static int sun4i_i2s_oversample_rates[] = {
+	128,
+	192,
+	256,
+	384,
+	512,
+	768,
 };
 
-static int sun4i_i2s_get_bclk_div(struct sun4i_i2s *i2s,
-				  unsigned int oversample_rate,
-				  unsigned int word_size)
+static int sun4i_i2s_is_oversample_valid(u32 oversample_rate)
 {
-	int div = oversample_rate / word_size / 2;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_bclk_div); i++) {
-		const struct sun4i_i2s_clk_div *bdiv = &sun4i_i2s_bclk_div[i];
+	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++)
+		if (sun4i_i2s_oversample_rates[i] == oversample_rate)
+			return 1;
+
+	return 0;
+}
+
+static int sun4i_i2s_get_bclk_div(struct sun4i_i2s *i2s, u32 clk_rate,
+				  u32 channels, u32 sample_rate, u32 word_size)
+{
+	int div, i;
+	u32 bclk_rate, oversample;
+
+	if (i2s->tdm_slots) {
+		bclk_rate = i2s->frame_length * sample_rate;
+		div = clk_rate / bclk_rate;
+	} else {
+		oversample = clk_rate / sample_rate;
+		div = oversample / word_size / channels;
+	}
 
-		if (bdiv->div == div)
-			return bdiv->val;
+	for (i = 0; i < i2s->quirks->num_bclkdiv; i++) {
+		if (i2s->quirks->bclk_div[i].div == div)
+			return i2s->quirks->bclk_div[i].val;
 	}
 
 	return -EINVAL;
 }
 
-static int sun4i_i2s_get_mclk_div(struct sun4i_i2s *i2s,
-				  unsigned int oversample_rate,
-				  unsigned int module_rate,
-				  unsigned int sampling_rate)
+static int sun4i_i2s_get_mclk_div(struct sun4i_i2s *i2s, u32 clk_rate,
+				  const struct sun4i_i2s_clkdiv *mdiv,
+				  int size)
 {
-	int div = module_rate / sampling_rate / oversample_rate;
+	int div = clk_rate / i2s->mclk_rate;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_mclk_div); i++) {
-		const struct sun4i_i2s_clk_div *mdiv = &sun4i_i2s_mclk_div[i];
-
+	for (i = 0; i < size; i++) {
 		if (mdiv->div == div)
 			return mdiv->val;
+		mdiv++;
 	}
 
 	return -EINVAL;
 }
 
-static int sun4i_i2s_oversample_rates[] = { 128, 192, 256, 384, 512, 768 };
-static bool sun4i_i2s_oversample_is_valid(unsigned int oversample)
+static inline u32 sun4i_i2s_field_get(struct sun4i_i2s *i2s, u32 index)
 {
-	int i;
+	struct regmap_field *field;
+	u32 val;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++)
-		if (sun4i_i2s_oversample_rates[i] == oversample)
-			return true;
+	if (index >= REGMAP_NUM_FIELDS)
+		return 0;
 
-	return false;
+	field = i2s->fields[index];
+	return !regmap_field_read(field, &val) ? val : 0;
 }
 
-static int sun4i_i2s_set_clk_rate(struct snd_soc_dai *dai,
-				  unsigned int rate,
-				  unsigned int word_size)
+static inline void sun4i_i2s_field_set(struct sun4i_i2s *i2s, u32 index, u32 val)
+{
+	struct regmap_field *field;
+
+	if (index >= REGMAP_NUM_FIELDS)
+		return;
+
+	dev_dbg(i2s->dev,
+		"write regmap: field = %d, val = 0x%08x\n",
+		index, val);
+
+	field = i2s->fields[index];
+	regmap_field_write(field, val);
+}
+
+static int sun4i_i2s_setup_pll(struct sun4i_i2s *i2s, u32 sample_rate,
+			       u32 *clk_rate)
 {
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	unsigned int oversample_rate, clk_rate;
-	int bclk_div, mclk_div;
 	int ret;
 
-	switch (rate) {
+	/* cpu master */
+	switch (sample_rate) {
 	case 176400:
 	case 88200:
 	case 44100:
 	case 22050:
 	case 11025:
-		clk_rate = 22579200;
+		*clk_rate = 22579200;
 		break;
 
 	case 192000:
@@ -296,355 +177,820 @@ static int sun4i_i2s_set_clk_rate(struct snd_soc_dai *dai,
 	case 16000:
 	case 12000:
 	case 8000:
-		clk_rate = 24576000;
+		*clk_rate = 24576000;
 		break;
 
 	default:
-		dev_err(dai->dev, "Unsupported sample rate: %u\n", rate);
+		dev_err(i2s->dev, "Unsupported frame rate: %d\n",
+			sample_rate);
 		return -EINVAL;
 	}
 
-	ret = clk_set_rate(i2s->mod_clk, clk_rate);
-	if (ret)
+	ret = clk_set_rate(i2s->mod_clk, *clk_rate);
+	if (ret) {
+		dev_err(i2s->dev, "Unable to set PLL rate\n");
 		return ret;
-
-	oversample_rate = i2s->mclk_freq / rate;
-	if (!sun4i_i2s_oversample_is_valid(oversample_rate)) {
-		dev_err(dai->dev, "Unsupported oversample rate: %d\n",
-			oversample_rate);
-		return -EINVAL;
 	}
 
-	bclk_div = sun4i_i2s_get_bclk_div(i2s, oversample_rate,
-					  word_size);
-	if (bclk_div < 0) {
-		dev_err(dai->dev, "Unsupported BCLK divider: %d\n", bclk_div);
-		return -EINVAL;
-	}
+	return 0;
+}
 
-	mclk_div = sun4i_i2s_get_mclk_div(i2s, oversample_rate,
-					  clk_rate, rate);
-	if (mclk_div < 0) {
-		dev_err(dai->dev, "Unsupported MCLK divider: %d\n", mclk_div);
-		return -EINVAL;
-	}
+static int sun4i_i2s_set_sync_period(struct sun4i_i2s *i2s,
+				     struct snd_pcm_hw_params *params)
+{
+	u32 sync_period, frame_length;
+	int i, ret, max = 4;
 
-	/* Adjust the clock division values if needed */
-	bclk_div += i2s->variant->bclk_offset;
-	mclk_div += i2s->variant->mclk_offset;
+	if (i2s->tdm_slots)
+		frame_length = i2s->frame_length;
+	else
+		frame_length = snd_soc_params_to_frame_size(params);
 
-	regmap_write(i2s->regmap, SUN4I_I2S_CLK_DIV_REG,
-		     SUN4I_I2S_CLK_DIV_BCLK(bclk_div) |
-		     SUN4I_I2S_CLK_DIV_MCLK(mclk_div));
+	for (i = 0; i <= max; i++) {
+		sync_period = (1 << (4 + i));
+		if (frame_length == sync_period)
+			break;
+	}
+	if (i > max) {
+		dev_err(i2s->dev, "unsupported SYNC period\n");
+		return -EINVAL;
+	}
 
-	regmap_field_write(i2s->field_clkdiv_mclk_en, 1);
+	dev_dbg(i2s->dev, "%s: SYNC period = %d, BCLK ratio = %d\n",
+		__func__, i, frame_length);
 
-	/* Set sync period */
-	if (i2s->variant->has_fmt_set_lrck_period)
-		regmap_update_bits(i2s->regmap, SUN4I_I2S_FMT0_REG,
-				   SUN8I_I2S_FMT0_LRCK_PERIOD_MASK,
-				   SUN8I_I2S_FMT0_LRCK_PERIOD(32));
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT1,
+			   SUN4I_I2S_FMT1_SYNC_PERIOD_MASK,
+			   SUN4I_I2S_FMT1_SYNC_PERIOD(i));
 
 	return 0;
 }
 
-static s8 sun4i_i2s_get_sr(const struct sun4i_i2s *i2s, int width)
+static int sun8i_i2s_set_lrck_period(struct sun4i_i2s *i2s,
+				     struct snd_pcm_hw_params *params)
 {
-	if (width < 16 || width > 24)
-		return -EINVAL;
+	u32 lrck_period, frame_length;
+
+	if (i2s->tdm_slots) {
+		/* For PCM-mode LRCK period includes both slots */
+		if (i2s->is_pcm)
+			lrck_period = i2s->frame_length;
+		else
+			lrck_period = i2s->slot_width;
+
+		dev_dbg(i2s->dev, "%s: BCLK ratio = %d, LRCK period = %d\n",
+			__func__, i2s->frame_length, lrck_period);
+
+	} else {
+		/* For PCM-mode LRCK period includes both channels */
+		if (i2s->is_pcm) {
+			frame_length = snd_soc_params_to_frame_size(params);
+			lrck_period = frame_length;
+		} else
+			lrck_period = params_physical_width(params);
+
+		dev_dbg(i2s->dev, "%s: BCLK ratio = %d, LRCK period = %d\n",
+			__func__, frame_length, lrck_period);
+	}
 
-	if (width % 4)
+	if (lrck_period > SUN8I_I2S_LRCK_MAX_PERIOD) {
+		dev_err(i2s->dev, "unsupported LRCK period\n");
 		return -EINVAL;
+	}
+
+	/* Set LRCK(R) period */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_LRCK_PERIOD_MASK,
+			   SUN8I_I2S_LRCK_PERIOD(lrck_period));
 
-	return (width - 16) / 4;
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_LRCKR_PERIOD_MASK,
+			   SUN8I_I2S_LRCKR_PERIOD(lrck_period));
+
+	return 0;
 }
 
-static s8 sun4i_i2s_get_wss(const struct sun4i_i2s *i2s, int width)
+static int sun4i_i2s_set_rate(struct sun4i_i2s *i2s,
+			      struct snd_pcm_hw_params *params)
 {
-	if (width < 16 || width > 32)
-		return -EINVAL;
+	int ret, i;
+	int bclk_div, mclk_div;
+	u32 sample_rate, channels;
+	u32 word_size, frame_length;
+	u32 pll_rate, oversample_rate;
+	u32 bclk_rate;
 
-	if (width % 4)
-		return -EINVAL;
+	channels = params_channels(params);
+	sample_rate = params_rate(params);
+
+	if (i2s->tdm_slots) {
+		word_size = i2s->slot_width;
+		frame_length = i2s->frame_length;
+	} else {
+		word_size = params_physical_width(params);
+		frame_length = snd_soc_params_to_frame_size(params);
+	}
+
+	if (i2s->bit_clk_master) {
+		/* CPU bit & frame clock master */
+		ret = sun4i_i2s_setup_pll(i2s, sample_rate, &pll_rate);
+		if (ret)
+			return ret;
+
+		oversample_rate = i2s->mclk_rate / sample_rate;
+		if (!sun4i_i2s_is_oversample_valid(oversample_rate)) {
+			dev_err(i2s->dev, "unsupported oversample: %d\n",
+				oversample_rate);
+			return -EINVAL;
+		}
+
+		mclk_div = sun4i_i2s_get_mclk_div(i2s, pll_rate,
+						i2s->quirks->mclk_div,
+						i2s->quirks->num_mclkdiv);
+		if (mclk_div < 0) {
+			dev_err(i2s->dev, "unsupported MCLK rate\n");
+			return -EINVAL;
+		}
+
+		bclk_div = sun4i_i2s_get_bclk_div(i2s,
+						i2s->quirks->bclk_parent
+							== BCLK_PARENT_PLL ?
+							pll_rate : i2s->mclk_rate,
+						channels,
+						sample_rate,
+						word_size);
+		if (bclk_div < 0) {
+			dev_err(i2s->dev, "unsupported BCLK divider\n");
+			return -EINVAL;
+		}
+
+		bclk_rate = frame_length * sample_rate;
 
-	return (width - 16) / 4;
+		dev_dbg(i2s->dev,
+                        "%s: rate = %d, word = %d, o/sample = %d, PLL = %d, MCLK = %lu, BCLK = %d, BCLK ratio = %d\n",
+                        __func__, sample_rate, word_size, oversample_rate,
+			pll_rate, i2s->mclk_rate, bclk_rate, frame_length);
+
+		dev_dbg(i2s->dev,
+			"%s: setting dividers: MCLK div = %d, BCLK div = %d\n",
+			 __func__, mclk_div, bclk_div);
+
+		sun4i_i2s_field_set(i2s, FIELD_BCLK_DIV, bclk_div);
+		sun4i_i2s_field_set(i2s, FIELD_MCLK_DIV, mclk_div);
+		sun4i_i2s_field_set(i2s, FIELD_MCLK_OUT_EN, 1);
+
+	} else {
+		/* CPU bit & frame clock slave, do nothing */
+	}
+
+	return 0;
 }
 
-static s8 sun8i_i2s_get_sr_wss(const struct sun4i_i2s *i2s, int width)
+static int sun4i_i2s_set_format(struct sun4i_i2s *i2s, u32 fmt)
 {
-	if (width % 4)
+	u32 mode, subm = 0, val;
+	u32 format = (fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+	u32 master = (fmt & SND_SOC_DAIFMT_MASTER_MASK);
+
+	/* DAI Mode */
+	switch (format) {
+	case SND_SOC_DAIFMT_I2S:
+		mode = SUN4I_I2S_CTRL_MODE_I2S;
+		subm = SUN4I_I2S_FMT0_FMT_I2S;
+		break;
+
+	case SND_SOC_DAIFMT_LEFT_J:
+		mode = SUN4I_I2S_CTRL_MODE_I2S;
+		subm = SUN4I_I2S_FMT0_FMT_LEFT_J;
+		break;
+
+	case SND_SOC_DAIFMT_RIGHT_J:
+		mode = SUN4I_I2S_CTRL_MODE_I2S;
+		subm = SUN4I_I2S_FMT0_FMT_RIGHT_J;
+		break;
+
+	case SND_SOC_DAIFMT_DSP_A:
+		mode = SUN4I_I2S_CTRL_MODE_PCM;
+		subm = SUN4I_I2S_FMT0_DSP_MODE_A;
+		break;
+
+	case SND_SOC_DAIFMT_DSP_B:
+		mode = SUN4I_I2S_CTRL_MODE_PCM;
+		subm = SUN4I_I2S_FMT0_DSP_MODE_B;
+		break;
+
+	default:
+		dev_err(i2s->dev, "unsupported format: %d\n",
+			format);
 		return -EINVAL;
+	}
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_MODE_MASK, mode);
+
+	switch (mode) {
+	case SUN4I_I2S_CTRL_MODE_I2S:
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+				   SUN4I_I2S_FMT0_FMT_MASK, subm);
+		break;
+
+	case SUN4I_I2S_CTRL_MODE_PCM:
+		/* Store PCM mode flag */
+		i2s->is_pcm = 1;
+
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+				   SUN4I_I2S_FMT0_DSP_MODE_MASK,
+				   subm);
+
+		/* Set short sync (one BCLK period)*/
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT1,
+				   SUN4I_I2S_PCM_SYNC_WIDTH,
+				   SUN4I_I2S_PCM_SYNC_SHORT);
+		break;
+	}
 
-	if (width < 8 || width > 32)
+
+	/* DAI clock master masks */
+	switch (master) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* BCLK and LRCK master */
+		val = SUN4I_I2S_CTRL_MASTER;
+		i2s->bit_clk_master = 1;
+		break;
+
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* BCLK and LRCLK slave */
+		val = SUN4I_I2S_CTRL_SLAVE;
+		i2s->bit_clk_master = 0;
+		break;
+
+	default:
+		dev_err(i2s->dev,
+			"unsupported master/slave option: %d\n",
+			master);
 		return -EINVAL;
+	}
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_SLAVE_MASK, val);
 
-	return (width - 8) / 4 + 1;
+	return 0;
 }
 
-static int sun4i_i2s_hw_params(struct snd_pcm_substream *substream,
-			       struct snd_pcm_hw_params *params,
-			       struct snd_soc_dai *dai)
+static int sun8i_i2s_set_format(struct sun4i_i2s *i2s, u32 fmt)
 {
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	int sr, wss, channels;
-	u32 width;
+	u32 mode, val, offset = 0;
+	u32 format = (fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+	u32 master = (fmt & SND_SOC_DAIFMT_MASTER_MASK);
+
+	/*
+	 * The offset indicates that we're connected to an I2S device,
+	 * however offset is only used on sun8i hardware. I2S shares
+	 * the same setting with the LJ format.
+	 */
+	/* DAI Mode */
+	switch (format) {
+	case SND_SOC_DAIFMT_I2S:
+		mode = SUN8I_I2S_CTRL_MODE_LEFT_J;
+		offset = 1;
+		break;
 
-	channels = params_channels(params);
-	if (channels != 2) {
-		dev_err(dai->dev, "Unsupported number of channels: %d\n",
-			channels);
+	case SND_SOC_DAIFMT_LEFT_J:
+		mode = SUN8I_I2S_CTRL_MODE_LEFT_J;
+		break;
+
+	case SND_SOC_DAIFMT_RIGHT_J:
+		mode = SUN8I_I2S_CTRL_MODE_RIGHT_J;
+		break;
+
+	case SND_SOC_DAIFMT_DSP_A:
+		mode = SUN8I_I2S_CTRL_MODE_PCM;
+		offset = 1;
+		break;
+
+	case SND_SOC_DAIFMT_DSP_B:
+		mode = SUN8I_I2S_CTRL_MODE_PCM;
+		break;
+
+	default:
+		dev_err(i2s->dev, "unsupported format: %d\n",
+			format);
 		return -EINVAL;
 	}
 
-	if (i2s->variant->has_chcfg) {
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_CHAN_CFG_REG,
-				   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK,
-				   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(channels));
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_CHAN_CFG_REG,
-				   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK,
-				   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(channels));
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN8I_I2S_CTRL_MODE_MASK, mode);
+
+	/* BCLK offset determines submode (see datasheet)*/
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_TX_CHAN_SEL,
+			   SUN8I_I2S_CHAN_SEL_OFFSET_MASK,
+			   SUN8I_I2S_CHAN_SEL_OFFSET(offset));
+
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_RX_CHAN_SEL,
+			   SUN8I_I2S_CHAN_SEL_OFFSET_MASK,
+			   SUN8I_I2S_CHAN_SEL_OFFSET(offset));
+
+	if (mode == SUN8I_I2S_CTRL_MODE_PCM) {
+		/* Store PCM mode flag */
+		i2s->is_pcm = 1;
+
+		/* Set short sync (1 BCLK period)*/
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+				   SUN8I_I2S_PCM_SYNC_WIDTH,
+				   SUN8I_I2S_PCM_SYNC_SHORT);
+	}
+
+	/*
+	 * The newer i2s block does not have a slave select bit,
+	 * instead the clk pins are configured as inputs.
+	 */
+	/* DAI clock master masks */
+	switch (master) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* BCLK and LRCLK master */
+		val = SUN8I_I2S_CTRL_BCLK_OUT |
+		      SUN8I_I2S_CTRL_LRCK_OUT;
+		i2s->bit_clk_master = 1;
+		break;
+
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* BCLK and LRCLK slave */
+		val = 0;
+		i2s->bit_clk_master = 0;
+		break;
+
+	default:
+		dev_err(i2s->dev,
+			"unsupported master/slave option: %d\n",
+			master);
+		return -EINVAL;
 	}
 
-	/* Map the channels for playback and capture */
-	regmap_field_write(i2s->field_txchanmap, 0x76543210);
-	regmap_field_write(i2s->field_rxchanmap, 0x00003210);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN8I_I2S_CTRL_BCLK_OUT |
+			   SUN8I_I2S_CTRL_LRCK_OUT, val);
 
-	/* Configure the channels */
-	regmap_field_write(i2s->field_txchansel,
-			   SUN4I_I2S_CHAN_SEL(params_channels(params)));
+	return 0;
+}
 
-	regmap_field_write(i2s->field_rxchansel,
-			   SUN4I_I2S_CHAN_SEL(params_channels(params)));
+static int sun4i_i2s_set_hw_config(struct snd_soc_dai *dai,
+				   struct snd_pcm_hw_params *params)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 sr, wss;
+	u32 sample_rate, sample_size, word_size;
+	int i;
 
-	if (i2s->variant->has_chsel_tx_chen)
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_TX_CHAN_SEL_REG,
-				   SUN8I_I2S_TX_CHAN_EN_MASK,
-				   SUN8I_I2S_TX_CHAN_EN(channels));
+	sample_rate = params_rate(params);
+	sample_size = params_width(params);
 
-	switch (params_physical_width(params)) {
+	switch (sample_size) {
 	case 16:
-		width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		sr = 0x0;
+		break;
+	case 20:
+		sr = 0x1;
+		break;
+	case 24:
+		sr = 0x2;
 		break;
 	default:
-		dev_err(dai->dev, "Unsupported physical sample width: %d\n",
-			params_physical_width(params));
+		dev_err(dai->dev, "unsupported sample size: %d\n",
+			sample_size);
 		return -EINVAL;
 	}
-	i2s->playback_dma_data.addr_width = width;
 
-	sr = i2s->variant->get_sr(i2s, params_width(params));
-	if (sr < 0)
-		return -EINVAL;
+	if (i2s->tdm_slots)
+		word_size = i2s->slot_width;
+	else
+		word_size = params_physical_width(params);
 
-	wss = i2s->variant->get_wss(i2s, params_width(params));
-	if (wss < 0)
+	switch (word_size) {
+	case 16:
+		wss = 0x0;
+		break;
+	case 20:
+		wss = 0x1;
+		break;
+	case 24:
+		wss = 0x2;
+		break;
+	case 32:
+		wss = 0x3;
+		break;
+	default:
+		dev_err(dai->dev, "unsupported word size: %d\n",
+			word_size);
 		return -EINVAL;
+	}
 
-	regmap_field_write(i2s->field_fmt_wss, wss);
-	regmap_field_write(i2s->field_fmt_sr, sr);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN4I_I2S_FMT0_SR_MASK,
+			   SUN4I_I2S_FMT0_SR(sr));
 
-	return sun4i_i2s_set_clk_rate(dai, params_rate(params),
-				      params_width(params));
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN4I_I2S_FMT0_WSS_MASK,
+			   SUN4I_I2S_FMT0_WSS(wss));
+
+	dev_dbg(dai->dev,
+		"%s: rate = %d, sample size = %d (sr = %d), word size = %d (wss = %d)\n",
+		__func__, sample_rate, sample_size, sr, word_size, wss);
+
+	return sun4i_i2s_set_sync_period(i2s, params);
 }
 
-static int sun4i_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+static int sun8i_i2s_set_hw_config(struct snd_soc_dai *dai,
+				   struct snd_pcm_hw_params *params)
 {
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	u32 val;
-	u32 offset = 0;
-	u32 bclk_polarity = SUN4I_I2S_FMT0_POLARITY_NORMAL;
-	u32 lrclk_polarity = SUN4I_I2S_FMT0_POLARITY_NORMAL;
+	u32 sr, sw;
+	u32 sample_rate, sample_size, channels;
+	u32 word_size;
 
-	/* DAI Mode */
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		val = SUN4I_I2S_FMT0_FMT_I2S;
-		offset = 1;
+	channels	= params_channels(params);
+        sample_rate	= params_rate(params);
+        sample_size	= params_width(params);
+
+
+	/* Set channel config register */
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_CHAN_CFG,
+			   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK,
+			   SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(channels));
+
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_CHAN_CFG,
+			   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK,
+			   SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(channels));
+
+
+	/* Enable TX channels */
+	regmap_update_bits(i2s->regmap, SUN8I_I2S_REG_TX_CHAN_SEL,
+			   SUN8I_I2S_TX_CHAN_SEL_EN_MASK,
+			   SUN8I_I2S_TX_CHAN_SEL_EN(channels));
+
+	switch (sample_size) {
+	case 16:
+		sr = 0x3;
 		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		val = SUN4I_I2S_FMT0_FMT_LEFT_J;
+	case 20:
+		sr = 0x4;
 		break;
-	case SND_SOC_DAIFMT_RIGHT_J:
-		val = SUN4I_I2S_FMT0_FMT_RIGHT_J;
+	case 24:
+		sr = 0x5;
+		break;
+	case 32:
+		sr = 0x7;
+		break;
+        default:
+		dev_err(i2s->dev, "unsupported sample size: %d\n",
+			sample_size);
+		return -EINVAL;
+	}
+
+	if (i2s->tdm_slots)
+		word_size = i2s->slot_width;
+	else
+		word_size = params_physical_width(params);
+
+	switch (word_size) {
+	case 16:
+		sw = 0x3;
+		break;
+	case 20:
+		sw = 0x4;
+		break;
+	case 24:
+		sw = 0x5;
+		break;
+	case 32:
+		sw = 0x7;
 		break;
 	default:
-		dev_err(dai->dev, "Unsupported format: %d\n",
-			fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+		dev_err(dai->dev, "unsupported word size: %d\n",
+			word_size);
 		return -EINVAL;
 	}
 
-	if (i2s->variant->has_chsel_offset) {
-		/*
-		 * offset being set indicates that we're connected to an i2s
-		 * device, however offset is only used on the sun8i block and
-		 * i2s shares the same setting with the LJ format. Increment
-		 * val so that the bit to value to write is correct.
-		 */
-		if (offset > 0)
-			val++;
-		/* blck offset determines whether i2s or LJ */
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_TX_CHAN_SEL_REG,
-				   SUN8I_I2S_TX_CHAN_OFFSET_MASK,
-				   SUN8I_I2S_TX_CHAN_OFFSET(offset));
-
-		regmap_update_bits(i2s->regmap, SUN8I_I2S_RX_CHAN_SEL_REG,
-				   SUN8I_I2S_TX_CHAN_OFFSET_MASK,
-				   SUN8I_I2S_TX_CHAN_OFFSET(offset));
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_FMT0_SR_MASK,
+			   SUN8I_I2S_FMT0_SR(sr));
+
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FMT0,
+			   SUN8I_I2S_FMT0_SW_MASK,
+			   SUN8I_I2S_FMT0_SW(sw));
+
+        dev_dbg(dai->dev,
+                "%s: rate = %d, sample size = %d (sr = %d), word size = %d (sw = %d)\n",
+                __func__, sample_rate, sample_size, sr, word_size, sw);
+
+	return sun8i_i2s_set_lrck_period(i2s, params);
+}
+
+#define STEREO_CHAN_MAP	SUN4I_I2S_CHAN_MAP(0,0) | \
+			SUN4I_I2S_CHAN_MAP(1,1)
+
+
+static int sun4i_i2s_dai_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params,
+				   struct snd_soc_dai *dai)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 channels, lines;
+	u32 bus_width;
+	u32 sample_rate, word_size, sample_size;
+	int ret;
+
+	channels	= params_channels(params);
+	word_size	= params_physical_width(params);
+	sample_rate	= params_rate(params);
+	sample_size	= params_width(params);
+
+	if ((channels > dai->driver->playback.channels_max) ||
+	    (channels < dai->driver->playback.channels_min)) {
+		dev_err(dai->dev, "unsupported number of channels: %d\n",
+			channels);
+		return -EINVAL;
 	}
 
-	regmap_field_write(i2s->field_fmt_mode, val);
+	lines = (channels + 1) / 2;
 
-	/* DAI clock polarity */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_IB_IF:
-		/* Invert both clocks */
-		bclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
-		lrclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		/* Invert bit clock */
-		bclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		/* Invert frame clock */
-		lrclk_polarity = SUN4I_I2S_FMT0_POLARITY_INVERTED;
+	/* Enable the required output lines */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_SDO_EN_MASK,
+			   SUN4I_I2S_CTRL_SDO_EN(lines));
+
+	switch (word_size) {
+	case 16:
+		bus_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 		break;
-	case SND_SOC_DAIFMT_NB_NF:
+	case 20:
+	case 24:
+	case 32:
+		bus_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		break;
 	default:
-		dev_err(dai->dev, "Unsupported clock polarity: %d\n",
-			fmt & SND_SOC_DAIFMT_INV_MASK);
+		dev_err(i2s->dev, "unsupported storage size: %d\n",
+			word_size);
 		return -EINVAL;
 	}
 
-	regmap_field_write(i2s->field_fmt_bclk, bclk_polarity);
-	regmap_field_write(i2s->field_fmt_lrclk, lrclk_polarity);
+	i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width = bus_width;
+	i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width = bus_width;
 
-	if (i2s->variant->has_slave_select_bit) {
-		/* DAI clock master masks */
-		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-		case SND_SOC_DAIFMT_CBS_CFS:
-			/* BCLK and LRCLK master */
-			val = SUN4I_I2S_CTRL_MODE_MASTER;
-			break;
-		case SND_SOC_DAIFMT_CBM_CFM:
-			/* BCLK and LRCLK slave */
-			val = SUN4I_I2S_CTRL_MODE_SLAVE;
-			break;
-		default:
-			dev_err(dai->dev, "Unsupported slave setting: %d\n",
-				fmt & SND_SOC_DAIFMT_MASTER_MASK);
-			return -EINVAL;
-		}
-		regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-				   SUN4I_I2S_CTRL_MODE_MASK,
-				   val);
-	} else {
-		/*
-		 * The newer i2s block does not have a slave select bit,
-		 * instead the clk pins are configured as inputs.
-		 */
-		/* DAI clock master masks */
-		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-		case SND_SOC_DAIFMT_CBS_CFS:
-			/* BCLK and LRCLK master */
-			val = SUN8I_I2S_CTRL_BCLK_OUT |
-				SUN8I_I2S_CTRL_LRCK_OUT;
-			break;
-		case SND_SOC_DAIFMT_CBM_CFM:
-			/* BCLK and LRCLK slave */
-			val = 0;
-			break;
-		default:
-			dev_err(dai->dev, "Unsupported slave setting: %d\n",
-				fmt & SND_SOC_DAIFMT_MASTER_MASK);
-			return -EINVAL;
-		}
-		regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-				   SUN8I_I2S_CTRL_BCLK_OUT |
-				   SUN8I_I2S_CTRL_LRCK_OUT,
-				   val);
+
+	/* Select and map channels for playback */
+	sun4i_i2s_field_set(i2s, FIELD_TX_CHAN_MAP, STEREO_CHAN_MAP);
+	sun4i_i2s_field_set(i2s, FIELD_TX_CHAN_SEL,
+				SUN4I_I2S_CHAN_SEL(channels));
+
+	/* Select and map channels for capture */
+	sun4i_i2s_field_set(i2s, FIELD_RX_CHAN_MAP, STEREO_CHAN_MAP);
+	sun4i_i2s_field_set(i2s, FIELD_RX_CHAN_SEL,
+				SUN4I_I2S_CHAN_SEL(channels));
+
+	ret = sun4i_i2s_set_rate(i2s, params);
+	if (ret)
+		return ret;
+
+	/* Apply platform-specific config */
+	ret = i2s->quirks->set_hw_config(dai, params);
+	if (ret)
+		return ret;
+
+	/* If sample resolution < slot width */
+	/* 0 - Zero/Gain padding at LSB */
+	/* 1 - Sign extension to MSB */
+	/* 3 - Transfer 0 after each sample */
+	sun4i_i2s_field_set(i2s, FIELD_SIGN_EXT, 0);
+
+	return 0;
+}
+
+static int sun4i_i2s_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 bclk_pol = SUN4I_I2S_POLARITY_NORMAL;
+	u32 lrck_pol = SUN4I_I2S_POLARITY_NORMAL;
+	int ret;
+
+	/* Invoke platform-specific portion */
+	ret = i2s->quirks->set_format(i2s, fmt);
+	if (ret)
+		return ret;
+
+        /* DAI clock polarity */
+        switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+        case SND_SOC_DAIFMT_IB_IF:
+                /* Invert both clocks */
+                bclk_pol = SUN4I_I2S_POLARITY_INVERT;
+                lrck_pol = SUN4I_I2S_POLARITY_INVERT;
+                break;
+
+        case SND_SOC_DAIFMT_IB_NF:
+                /* Invert bit clock only */
+                bclk_pol = SUN4I_I2S_POLARITY_INVERT;
+                break;
+
+        case SND_SOC_DAIFMT_NB_IF:
+                /* Invert frame clock only */
+                lrck_pol = SUN4I_I2S_POLARITY_INVERT;
+                break;
+
+        case SND_SOC_DAIFMT_NB_NF:
+                break;
+
+        default:
+                dev_err(i2s->dev, "Unsupported clock polarity: %d\n",
+                        (fmt & SND_SOC_DAIFMT_INV_MASK));
+                return -EINVAL;
+        }
+
+        sun4i_i2s_field_set(i2s, FIELD_BCLK_POLARITY, bclk_pol);
+
+        /* LRCK can't be inverted in PCM mode */
+        if (!i2s->is_pcm)
+                sun4i_i2s_field_set(i2s, FIELD_LRCK_POLARITY, lrck_pol);
+	else
+		sun4i_i2s_field_set(i2s, FIELD_LRCK_POLARITY,
+					SUN4I_I2S_POLARITY_NORMAL);
+
+
+	/* Set significant bits in FIFOs */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_CTRL_TX_IM_MASK |
+			   SUN4I_I2S_FIFO_CTRL_RX_OM_MASK,
+			   SUN4I_I2S_FIFO_CTRL_TX_IM(1) |
+			   SUN4I_I2S_FIFO_CTRL_RX_OM(1));
+
+	/* Try to avoid FIFO underrun */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_TX_TL_MASK,
+			   SUN4I_I2S_FIFO_TX_TL(0x20));
+
+	dev_dbg(i2s->dev,
+		"%s: BCLK pol = %d, LRCK pol = %d, is PCM = %d, is master = %d\n",
+		__func__, bclk_pol, lrck_pol, i2s->is_pcm, i2s->bit_clk_master);
+
+	return 0;
+}
+
+/**
+ * Configures the DAI for a preset BCLK to sample rate ratio.
+ */
+static int sun4i_i2s_dai_set_bclk_ratio(struct snd_soc_dai *dai,
+					unsigned int ratio)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	if (!ratio) {
+		i2s->tdm_slots = 0;
+		return 0;
 	}
 
-	/* Set significant bits in our FIFOs */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG,
-			   SUN4I_I2S_FIFO_CTRL_TX_MODE_MASK |
-			   SUN4I_I2S_FIFO_CTRL_RX_MODE_MASK,
-			   SUN4I_I2S_FIFO_CTRL_TX_MODE(1) |
-			   SUN4I_I2S_FIFO_CTRL_RX_MODE(1));
+	i2s->tdm_slots = 2;
+	i2s->slot_width = ratio / 2;
+	i2s->frame_length = ratio;
+
 	return 0;
 }
 
-static void sun4i_i2s_start_capture(struct sun4i_i2s *i2s)
+static int sun4i_i2s_dai_set_tdm_slot(struct snd_soc_dai *dai,
+				      unsigned int tx_mask,
+				      unsigned int rx_mask,
+				      int slots, int width)
 {
-	/* Flush RX FIFO */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_RX,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_RX);
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
-	/* Clear RX counter */
-	regmap_write(i2s->regmap, SUN4I_I2S_RX_CNT_REG, 0);
+	slots = (slots / 2) * 2;
+	if (slots < 2)
+		return -EINVAL;
 
-	/* Enable RX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_RX_EN,
-			   SUN4I_I2S_CTRL_RX_EN);
+	i2s->tdm_slots = slots;
+	i2s->slot_width = width;
+	i2s->frame_length = width * slots;
 
-	/* Enable RX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN,
-			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN);
+	return 0;
+}
+
+static int sun4i_i2s_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+				    unsigned int rate, int dir)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	if (clk_id != 0)
+		return -EINVAL;
+
+	i2s->mclk_rate = rate;
+
+	return 0;
+}
+
+static void sun4i_i2s_dai_shutdown(struct snd_pcm_substream *substream,
+				   struct snd_soc_dai *dai)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	clk_disable_unprepare(i2s->mod_clk);
+
+	/* Disable output lines */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_SDO_EN_MASK, 0);
+
+	/* Disable whole hardware block */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_GLOB_EN, 0);
+
+	i2s->tdm_slots = 0;
+}
+
+static int sun4i_i2s_dai_startup(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	/* Enable whole hardware block */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_GLOB_EN,
+			   SUN4I_I2S_CTRL_GLOB_EN);
+
+	return clk_prepare_enable(i2s->mod_clk);
 }
 
 static void sun4i_i2s_start_playback(struct sun4i_i2s *i2s)
 {
 	/* Flush TX FIFO */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_TX,
-			   SUN4I_I2S_FIFO_CTRL_FLUSH_TX);
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_FLUSH_TX,
+			   SUN4I_I2S_FIFO_FLUSH_TX);
 
 	/* Clear TX counter */
-	regmap_write(i2s->regmap, SUN4I_I2S_TX_CNT_REG, 0);
+	regmap_write(i2s->regmap, SUN4I_I2S_REG_TX_COUNT, 0);
+
 
 	/* Enable TX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
 			   SUN4I_I2S_CTRL_TX_EN,
 			   SUN4I_I2S_CTRL_TX_EN);
 
 	/* Enable TX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN,
-			   SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN);
+	regmap_update_bits(i2s->regmap,
+			   SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_TX_DRQ_EN,
+			   SUN4I_I2S_TX_DRQ_EN);
+}
+
+static void sun4i_i2s_start_capture(struct sun4i_i2s *i2s)
+{
+	/* Flush RX FIFO */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_FIFO_CTRL,
+			   SUN4I_I2S_FIFO_FLUSH_RX,
+			   SUN4I_I2S_FIFO_FLUSH_RX);
+
+	/* Clear RX counter */
+	regmap_write(i2s->regmap, SUN4I_I2S_REG_RX_COUNT, 0);
+
+
+	/* Enable RX Block */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_RX_EN,
+			   SUN4I_I2S_CTRL_RX_EN);
+
+	/* Enable RX DRQ */
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_RX_DRQ_EN,
+			   SUN4I_I2S_RX_DRQ_EN);
+
+	/* Debugging without codec */
+	if (i2s->loopback)
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+				   SUN4I_I2S_CTRL_LOOPBACK,
+				   SUN4I_I2S_CTRL_LOOPBACK);
 }
 
 static void sun4i_i2s_stop_capture(struct sun4i_i2s *i2s)
 {
 	/* Disable RX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_RX_EN,
-			   0);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_RX_EN, 0);
 
 	/* Disable RX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN,
-			   0);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_RX_DRQ_EN, 0);
 }
 
 static void sun4i_i2s_stop_playback(struct sun4i_i2s *i2s)
 {
 	/* Disable TX Block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_TX_EN,
-			   0);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_CTRL,
+			   SUN4I_I2S_CTRL_TX_EN, 0);
 
 	/* Disable TX DRQ */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
-			   SUN4I_I2S_DMA_INT_CTRL_TX_DRQ_EN,
-			   0);
+	regmap_update_bits(i2s->regmap, SUN4I_I2S_REG_DMA_INT_CTRL,
+			   SUN4I_I2S_TX_DRQ_EN, 0);
 }
 
-static int sun4i_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
-			     struct snd_soc_dai *dai)
+static int sun4i_i2s_dai_trigger(struct snd_pcm_substream *substream,
+				 int cmd, struct snd_soc_dai *dai)
 {
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
@@ -674,24 +1020,15 @@ static int sun4i_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-static int sun4i_i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id,
-				unsigned int freq, int dir)
-{
-	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-
-	if (clk_id != 0)
-		return -EINVAL;
-
-	i2s->mclk_freq = freq;
-
-	return 0;
-}
-
 static const struct snd_soc_dai_ops sun4i_i2s_dai_ops = {
-	.hw_params	= sun4i_i2s_hw_params,
-	.set_fmt	= sun4i_i2s_set_fmt,
-	.set_sysclk	= sun4i_i2s_set_sysclk,
-	.trigger	= sun4i_i2s_trigger,
+	.hw_params	= sun4i_i2s_dai_hw_params,
+	.set_fmt	= sun4i_i2s_dai_set_fmt,
+	.set_bclk_ratio = sun4i_i2s_dai_set_bclk_ratio,
+	.set_tdm_slot	= sun4i_i2s_dai_set_tdm_slot,
+	.set_sysclk	= sun4i_i2s_dai_set_sysclk,
+	.shutdown	= sun4i_i2s_dai_shutdown,
+	.startup	= sun4i_i2s_dai_startup,
+	.trigger	= sun4i_i2s_dai_trigger,
 };
 
 static int sun4i_i2s_dai_probe(struct snd_soc_dai *dai)
@@ -699,8 +1036,8 @@ static int sun4i_i2s_dai_probe(struct snd_soc_dai *dai)
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
 	snd_soc_dai_init_dma_data(dai,
-				  &i2s->playback_dma_data,
-				  &i2s->capture_dma_data);
+			&i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK],
+			&i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE]);
 
 	snd_soc_dai_set_drvdata(dai, i2s);
 
@@ -708,20 +1045,18 @@ static int sun4i_i2s_dai_probe(struct snd_soc_dai *dai)
 }
 
 static struct snd_soc_dai_driver sun4i_i2s_dai = {
-	.probe = sun4i_i2s_dai_probe,
+	.probe	= sun4i_i2s_dai_probe,
 	.capture = {
 		.stream_name = "Capture",
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_192000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	},
 	.playback = {
 		.stream_name = "Playback",
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_8000_192000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	},
 	.ops = &sun4i_i2s_dai_ops,
 	.symmetric_rates = 1,
@@ -731,118 +1066,26 @@ static const struct snd_soc_component_driver sun4i_i2s_component = {
 	.name	= "sun4i-dai",
 };
 
-static bool sun4i_i2s_rd_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case SUN4I_I2S_FIFO_TX_REG:
-		return false;
-
-	default:
-		return true;
-	}
-}
-
-static bool sun4i_i2s_wr_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case SUN4I_I2S_FIFO_RX_REG:
-	case SUN4I_I2S_FIFO_STA_REG:
-		return false;
-
-	default:
-		return true;
-	}
-}
-
-static bool sun4i_i2s_volatile_reg(struct device *dev, unsigned int reg)
+static int sun4i_i2s_alloc_regmap_fields(struct device *dev,
+					 struct sun4i_i2s *i2s)
 {
-	switch (reg) {
-	case SUN4I_I2S_FIFO_RX_REG:
-	case SUN4I_I2S_INT_STA_REG:
-	case SUN4I_I2S_RX_CNT_REG:
-	case SUN4I_I2S_TX_CNT_REG:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static bool sun8i_i2s_rd_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case SUN8I_I2S_FIFO_TX_REG:
-		return false;
-
-	default:
-		return true;
+	int i, ret;
+
+	for (i = 0; i < REGMAP_NUM_FIELDS; i++) {
+		i2s->fields[i] = devm_regmap_field_alloc(dev,
+						i2s->regmap,
+						i2s->quirks->reg_fields[i]);
+		if (IS_ERR(i2s->fields[i])) {
+			dev_err(dev, "Failed to allocate regmap field\n");
+			ret = PTR_ERR(i2s->fields[i]);
+			i2s->fields[i] = NULL;
+			return ret;
+		}
 	}
-}
 
-static bool sun8i_i2s_volatile_reg(struct device *dev, unsigned int reg)
-{
-	if (reg == SUN8I_I2S_INT_STA_REG)
-		return true;
-	if (reg == SUN8I_I2S_FIFO_TX_REG)
-		return false;
-
-	return sun4i_i2s_volatile_reg(dev, reg);
+	return 0;
 }
 
-static const struct reg_default sun4i_i2s_reg_defaults[] = {
-	{ SUN4I_I2S_CTRL_REG, 0x00000000 },
-	{ SUN4I_I2S_FMT0_REG, 0x0000000c },
-	{ SUN4I_I2S_FMT1_REG, 0x00004020 },
-	{ SUN4I_I2S_FIFO_CTRL_REG, 0x000400f0 },
-	{ SUN4I_I2S_DMA_INT_CTRL_REG, 0x00000000 },
-	{ SUN4I_I2S_CLK_DIV_REG, 0x00000000 },
-	{ SUN4I_I2S_TX_CHAN_SEL_REG, 0x00000001 },
-	{ SUN4I_I2S_TX_CHAN_MAP_REG, 0x76543210 },
-	{ SUN4I_I2S_RX_CHAN_SEL_REG, 0x00000001 },
-	{ SUN4I_I2S_RX_CHAN_MAP_REG, 0x00003210 },
-};
-
-static const struct reg_default sun8i_i2s_reg_defaults[] = {
-	{ SUN4I_I2S_CTRL_REG, 0x00060000 },
-	{ SUN4I_I2S_FMT0_REG, 0x00000033 },
-	{ SUN4I_I2S_FMT1_REG, 0x00000030 },
-	{ SUN4I_I2S_FIFO_CTRL_REG, 0x000400f0 },
-	{ SUN4I_I2S_DMA_INT_CTRL_REG, 0x00000000 },
-	{ SUN4I_I2S_CLK_DIV_REG, 0x00000000 },
-	{ SUN8I_I2S_CHAN_CFG_REG, 0x00000000 },
-	{ SUN8I_I2S_TX_CHAN_SEL_REG, 0x00000000 },
-	{ SUN8I_I2S_TX_CHAN_MAP_REG, 0x00000000 },
-	{ SUN8I_I2S_RX_CHAN_SEL_REG, 0x00000000 },
-	{ SUN8I_I2S_RX_CHAN_MAP_REG, 0x00000000 },
-};
-
-static const struct regmap_config sun4i_i2s_regmap_config = {
-	.reg_bits	= 32,
-	.reg_stride	= 4,
-	.val_bits	= 32,
-	.max_register	= SUN4I_I2S_RX_CHAN_MAP_REG,
-
-	.cache_type	= REGCACHE_FLAT,
-	.reg_defaults	= sun4i_i2s_reg_defaults,
-	.num_reg_defaults	= ARRAY_SIZE(sun4i_i2s_reg_defaults),
-	.writeable_reg	= sun4i_i2s_wr_reg,
-	.readable_reg	= sun4i_i2s_rd_reg,
-	.volatile_reg	= sun4i_i2s_volatile_reg,
-};
-
-static const struct regmap_config sun8i_i2s_regmap_config = {
-	.reg_bits	= 32,
-	.reg_stride	= 4,
-	.val_bits	= 32,
-	.max_register	= SUN8I_I2S_RX_CHAN_MAP_REG,
-	.cache_type	= REGCACHE_FLAT,
-	.reg_defaults	= sun8i_i2s_reg_defaults,
-	.num_reg_defaults	= ARRAY_SIZE(sun8i_i2s_reg_defaults),
-	.writeable_reg	= sun4i_i2s_wr_reg,
-	.readable_reg	= sun8i_i2s_rd_reg,
-	.volatile_reg	= sun8i_i2s_volatile_reg,
-};
-
 static int sun4i_i2s_runtime_resume(struct device *dev)
 {
 	struct sun4i_i2s *i2s = dev_get_drvdata(dev);
@@ -863,25 +1106,11 @@ static int sun4i_i2s_runtime_resume(struct device *dev)
 		goto err_disable_clk;
 	}
 
-	/* Enable the whole hardware block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_GL_EN, SUN4I_I2S_CTRL_GL_EN);
-
-	/* Enable the first output line */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_SDO_EN_MASK,
-			   SUN4I_I2S_CTRL_SDO_EN(0));
-
-	ret = clk_prepare_enable(i2s->mod_clk);
-	if (ret) {
-		dev_err(dev, "Failed to enable module clock\n");
-		goto err_disable_clk;
-	}
-
 	return 0;
 
 err_disable_clk:
 	clk_disable_unprepare(i2s->bus_clk);
+
 	return ret;
 }
 
@@ -889,16 +1118,6 @@ static int sun4i_i2s_runtime_suspend(struct device *dev)
 {
 	struct sun4i_i2s *i2s = dev_get_drvdata(dev);
 
-	clk_disable_unprepare(i2s->mod_clk);
-
-	/* Disable our output lines */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_SDO_EN_MASK, 0);
-
-	/* Disable the whole hardware block */
-	regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
-			   SUN4I_I2S_CTRL_GL_EN, 0);
-
 	regcache_cache_only(i2s->regmap, true);
 
 	clk_disable_unprepare(i2s->bus_clk);
@@ -906,276 +1125,133 @@ static int sun4i_i2s_runtime_suspend(struct device *dev)
 	return 0;
 }
 
-static const struct sun4i_i2s_quirks sun4i_a10_i2s_quirks = {
-	.has_reset		= false,
-	.reg_offset_txdata	= SUN4I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun4i_i2s_regmap_config,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 7, 7),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 2, 3),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 5),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 6, 6),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.has_slave_select_bit	= true,
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 1),
-	.field_txchanmap	= REG_FIELD(SUN4I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN4I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN4I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN4I_I2S_RX_CHAN_SEL_REG, 0, 2),
-	.get_sr			= sun4i_i2s_get_sr,
-	.get_wss		= sun4i_i2s_get_wss,
-};
-
-static const struct sun4i_i2s_quirks sun6i_a31_i2s_quirks = {
-	.has_reset		= true,
-	.reg_offset_txdata	= SUN4I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun4i_i2s_regmap_config,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 7, 7),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 2, 3),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 5),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 6, 6),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.has_slave_select_bit	= true,
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 1),
-	.field_txchanmap	= REG_FIELD(SUN4I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN4I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN4I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN4I_I2S_RX_CHAN_SEL_REG, 0, 2),
-	.get_sr			= sun4i_i2s_get_sr,
-	.get_wss		= sun4i_i2s_get_wss,
-};
-
-static const struct sun4i_i2s_quirks sun8i_a83t_i2s_quirks = {
-	.has_reset		= true,
-	.reg_offset_txdata	= SUN8I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun4i_i2s_regmap_config,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 7, 7),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 2, 3),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 5),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 6, 6),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.has_slave_select_bit	= true,
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 1),
-	.field_txchanmap	= REG_FIELD(SUN4I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN4I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN4I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN4I_I2S_RX_CHAN_SEL_REG, 0, 2),
-	.get_sr			= sun8i_i2s_get_sr_wss,
-	.get_wss		= sun8i_i2s_get_sr_wss,
-};
-
-static const struct sun4i_i2s_quirks sun8i_h3_i2s_quirks = {
-	.has_reset		= true,
-	.reg_offset_txdata	= SUN8I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun8i_i2s_regmap_config,
-	.mclk_offset		= 1,
-	.bclk_offset		= 2,
-	.has_fmt_set_lrck_period = true,
-	.has_chcfg		= true,
-	.has_chsel_tx_chen	= true,
-	.has_chsel_offset	= true,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 8, 8),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 2),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 6),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 19, 19),
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_CTRL_REG, 4, 5),
-	.field_txchanmap	= REG_FIELD(SUN8I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN8I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN8I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN8I_I2S_RX_CHAN_SEL_REG, 0, 2),
-	.get_sr			= sun8i_i2s_get_sr_wss,
-	.get_wss		= sun8i_i2s_get_sr_wss,
-};
-
-static const struct sun4i_i2s_quirks sun50i_a64_codec_i2s_quirks = {
-	.has_reset		= true,
-	.reg_offset_txdata	= SUN8I_I2S_FIFO_TX_REG,
-	.sun4i_i2s_regmap	= &sun4i_i2s_regmap_config,
-	.has_slave_select_bit	= true,
-	.field_clkdiv_mclk_en	= REG_FIELD(SUN4I_I2S_CLK_DIV_REG, 7, 7),
-	.field_fmt_wss		= REG_FIELD(SUN4I_I2S_FMT0_REG, 2, 3),
-	.field_fmt_sr		= REG_FIELD(SUN4I_I2S_FMT0_REG, 4, 5),
-	.field_fmt_bclk		= REG_FIELD(SUN4I_I2S_FMT0_REG, 6, 6),
-	.field_fmt_lrclk	= REG_FIELD(SUN4I_I2S_FMT0_REG, 7, 7),
-	.field_fmt_mode		= REG_FIELD(SUN4I_I2S_FMT0_REG, 0, 1),
-	.field_txchanmap	= REG_FIELD(SUN4I_I2S_TX_CHAN_MAP_REG, 0, 31),
-	.field_rxchanmap	= REG_FIELD(SUN4I_I2S_RX_CHAN_MAP_REG, 0, 31),
-	.field_txchansel	= REG_FIELD(SUN4I_I2S_TX_CHAN_SEL_REG, 0, 2),
-	.field_rxchansel	= REG_FIELD(SUN4I_I2S_RX_CHAN_SEL_REG, 0, 2),
-	.get_sr			= sun4i_i2s_get_sr,
-	.get_wss		= sun4i_i2s_get_wss,
-};
-
-static int sun4i_i2s_init_regmap_fields(struct device *dev,
-					struct sun4i_i2s *i2s)
-{
-	i2s->field_clkdiv_mclk_en =
-		devm_regmap_field_alloc(dev, i2s->regmap,
-					i2s->variant->field_clkdiv_mclk_en);
-	if (IS_ERR(i2s->field_clkdiv_mclk_en))
-		return PTR_ERR(i2s->field_clkdiv_mclk_en);
-
-	i2s->field_fmt_wss =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_wss);
-	if (IS_ERR(i2s->field_fmt_wss))
-		return PTR_ERR(i2s->field_fmt_wss);
-
-	i2s->field_fmt_sr =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_sr);
-	if (IS_ERR(i2s->field_fmt_sr))
-		return PTR_ERR(i2s->field_fmt_sr);
-
-	i2s->field_fmt_bclk =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_bclk);
-	if (IS_ERR(i2s->field_fmt_bclk))
-		return PTR_ERR(i2s->field_fmt_bclk);
-
-	i2s->field_fmt_lrclk =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_lrclk);
-	if (IS_ERR(i2s->field_fmt_lrclk))
-		return PTR_ERR(i2s->field_fmt_lrclk);
-
-	i2s->field_fmt_mode =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_fmt_mode);
-	if (IS_ERR(i2s->field_fmt_mode))
-		return PTR_ERR(i2s->field_fmt_mode);
-
-	i2s->field_txchanmap =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_txchanmap);
-	if (IS_ERR(i2s->field_txchanmap))
-		return PTR_ERR(i2s->field_txchanmap);
-
-	i2s->field_rxchanmap =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_rxchanmap);
-	if (IS_ERR(i2s->field_rxchanmap))
-		return PTR_ERR(i2s->field_rxchanmap);
-
-	i2s->field_txchansel =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_txchansel);
-	if (IS_ERR(i2s->field_txchansel))
-		return PTR_ERR(i2s->field_txchansel);
-
-	i2s->field_rxchansel =
-			devm_regmap_field_alloc(dev, i2s->regmap,
-						i2s->variant->field_rxchansel);
-	return PTR_ERR_OR_ZERO(i2s->field_rxchansel);
-}
-
 static int sun4i_i2s_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct sun4i_i2s *i2s;
+	struct snd_soc_dai_driver *soc_dai;
 	struct resource *res;
-	void __iomem *regs;
+	void __iomem *base;
 	int irq, ret;
 
-	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	i2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);
 	if (!i2s)
 		return -ENOMEM;
+
+	i2s->dev = dev;
 	platform_set_drvdata(pdev, i2s);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(regs))
-		return PTR_ERR(regs);
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
-		dev_err(&pdev->dev, "Can't retrieve our interrupt\n");
+		dev_err(dev, "Couldn't request interrupt\n");
 		return irq;
-	}
+        }
 
-	i2s->variant = of_device_get_match_data(&pdev->dev);
-	if (!i2s->variant) {
-		dev_err(&pdev->dev, "Failed to determine the quirks to use\n");
+	i2s->quirks = of_device_get_match_data(dev);
+	if (!i2s->quirks) {
+		dev_err(dev, "Failed to get quirks to use\n");
 		return -ENODEV;
 	}
 
-	i2s->bus_clk = devm_clk_get(&pdev->dev, "apb");
-	if (IS_ERR(i2s->bus_clk)) {
-		dev_err(&pdev->dev, "Can't get our bus clock\n");
-		return PTR_ERR(i2s->bus_clk);
-	}
-
-	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
-					    i2s->variant->sun4i_i2s_regmap);
+	i2s->regmap = devm_regmap_init_mmio(dev, base,
+					i2s->quirks->regmap_cfg);
 	if (IS_ERR(i2s->regmap)) {
-		dev_err(&pdev->dev, "Regmap initialisation failed\n");
+		dev_err(dev, "Couldn't initialize regmap\n");
 		return PTR_ERR(i2s->regmap);
 	}
 
-	i2s->mod_clk = devm_clk_get(&pdev->dev, "mod");
+	i2s->bus_clk = devm_clk_get(dev, "apb");
+	if (IS_ERR(i2s->bus_clk)) {
+		dev_err(dev, "Couldn't get bus clock\n");
+		return PTR_ERR(i2s->bus_clk);
+	}
+
+	i2s->mod_clk = devm_clk_get(dev, "mod");
 	if (IS_ERR(i2s->mod_clk)) {
-		dev_err(&pdev->dev, "Can't get our mod clock\n");
+		dev_err(dev, "couldn't get mod clock\n");
 		return PTR_ERR(i2s->mod_clk);
 	}
 
-	if (i2s->variant->has_reset) {
-		i2s->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (i2s->quirks->has_reset) {
+		i2s->rst = devm_reset_control_get_exclusive(dev, NULL);
+
 		if (IS_ERR(i2s->rst)) {
-			dev_err(&pdev->dev, "Failed to get reset control\n");
+			dev_err(dev, "failed to get our reset line\n");
 			return PTR_ERR(i2s->rst);
 		}
-	}
 
-	if (!IS_ERR(i2s->rst)) {
 		ret = reset_control_deassert(i2s->rst);
 		if (ret) {
-			dev_err(&pdev->dev,
-				"Failed to deassert the reset control\n");
+			dev_err(dev,
+				"couldn't deassert reset line\n");
 			return -EINVAL;
 		}
 	}
 
-	i2s->playback_dma_data.addr = res->start +
-					i2s->variant->reg_offset_txdata;
-	i2s->playback_dma_data.maxburst = 8;
+	i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr = res->start +
+						i2s->quirks->reg_offset_txdata;
+	i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr = res->start +
+						SUN4I_I2S_REG_RX_FIFO;
 
-	i2s->capture_dma_data.addr = res->start + SUN4I_I2S_FIFO_RX_REG;
-	i2s->capture_dma_data.maxburst = 8;
+	i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 8;
+	i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 8;
 
-	pm_runtime_enable(&pdev->dev);
-	if (!pm_runtime_enabled(&pdev->dev)) {
-		ret = sun4i_i2s_runtime_resume(&pdev->dev);
-		if (ret)
-			goto err_pm_disable;
+
+	if (of_property_read_bool(dev->of_node, "loopback"))
+		i2s->loopback = 1;
+
+	soc_dai = devm_kmemdup(dev, &sun4i_i2s_dai,
+			       sizeof(*soc_dai), GFP_KERNEL);
+	if (!soc_dai)
+		goto err_quit;
+
+	soc_dai->playback.formats = i2s->quirks->playback_formats;
+	soc_dai->capture.formats = i2s->quirks->capture_formats;
+
+	ret = sun4i_i2s_alloc_regmap_fields(dev, i2s);
+	if (ret) {
+		dev_err(dev, "Couldn't alloc regmap fields: %d\n", ret);
+		goto err_quit;
 	}
 
-	ret = devm_snd_soc_register_component(&pdev->dev,
-					      &sun4i_i2s_component,
-					      &sun4i_i2s_dai, 1);
+	ret = sun4i_i2s_runtime_resume(dev);
 	if (ret) {
-		dev_err(&pdev->dev, "Could not register DAI\n");
-		goto err_suspend;
+		dev_err(dev, "Couldn't resume device: %d\n", ret);
+		goto err_quit;
 	}
 
-	ret = snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	ret = devm_snd_soc_register_component(dev,
+					      &sun4i_i2s_component,
+					      soc_dai, 1);
 	if (ret) {
-		dev_err(&pdev->dev, "Could not register PCM\n");
-		goto err_suspend;
+		dev_err(dev, "Could not register DAI: %d\n", ret);
+		goto err_pm_disable;
 	}
 
-	ret = sun4i_i2s_init_regmap_fields(&pdev->dev, i2s);
+	ret = snd_dmaengine_pcm_register(dev, NULL, 0);
 	if (ret) {
-		dev_err(&pdev->dev, "Could not initialise regmap fields\n");
-		goto err_suspend;
+		dev_err(dev, "Could not register PCM: %d\n", ret);
+		goto err_pm_disable;
 	}
 
 	return 0;
 
-err_suspend:
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		sun4i_i2s_runtime_suspend(&pdev->dev);
 err_pm_disable:
-	pm_runtime_disable(&pdev->dev);
-	if (!IS_ERR(i2s->rst))
+	pm_runtime_disable(dev);
+
+	if (!pm_runtime_status_suspended(dev))
+		sun4i_i2s_runtime_suspend(dev);
+err_quit:
+	if (i2s->rst)
 		reset_control_assert(i2s->rst);
 
 	return ret;
@@ -1187,16 +1263,258 @@ static int sun4i_i2s_remove(struct platform_device *pdev)
 
 	snd_dmaengine_pcm_unregister(&pdev->dev);
 
-	pm_runtime_disable(&pdev->dev);
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		sun4i_i2s_runtime_suspend(&pdev->dev);
+	pm_runtime_force_suspend(&pdev->dev);
 
-	if (!IS_ERR(i2s->rst))
+	if (!IS_ERR_OR_NULL(i2s->rst))
 		reset_control_assert(i2s->rst);
 
 	return 0;
 }
 
+static bool sun4i_i2s_readable_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN4I_I2S_REG_TX_FIFO:
+		return false;
+
+	default:
+		return true;
+	}
+}
+
+static bool sun4i_i2s_writable_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN4I_I2S_REG_RX_FIFO:
+	case SUN4I_I2S_REG_FIFO_STA:
+		return false;
+
+	default:
+		return true;
+	}
+}
+
+static bool sun4i_i2s_volatile_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN4I_I2S_REG_RX_FIFO:
+	case SUN4I_I2S_REG_INT_STA:
+	case SUN4I_I2S_REG_RX_COUNT:
+	case SUN4I_I2S_REG_TX_COUNT:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool sun8i_i2s_readable_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN8I_I2S_REG_TX_FIFO:
+		return false;
+
+	default:
+		return true;
+	}
+}
+
+static bool sun8i_i2s_volatile_reg(struct device *dev, u32 reg)
+{
+	switch (reg) {
+	case SUN8I_I2S_REG_INT_STA:
+		return true;
+	case SUN8I_I2S_REG_TX_FIFO:
+		return false;
+
+	default:
+		return sun4i_i2s_volatile_reg(dev, reg);
+	}
+}
+
+static const struct reg_default sun4i_i2s_reg_defaults[] = {
+	{ SUN4I_I2S_REG_CTRL,		0x00000000 },
+	{ SUN4I_I2S_REG_FMT0,		0x0000000c },
+	{ SUN4I_I2S_REG_FMT1,		0x00004020 },
+	{ SUN4I_I2S_REG_FIFO_CTRL,	0x000400f0 },
+	{ SUN4I_I2S_REG_DMA_INT_CTRL,	0x00000000 },
+	{ SUN4I_I2S_REG_CLKDIV,		0x00000000 },
+	{ SUN4I_I2S_REG_TX_CHAN_SEL,	0x00000001 },
+	{ SUN4I_I2S_REG_TX_CHAN_MAP,	0x76543210 },
+	{ SUN4I_I2S_REG_RX_CHAN_SEL,	0x00000001 },
+	{ SUN4I_I2S_REG_RX_CHAN_MAP,	0x00003210 },
+};
+
+static const struct reg_default sun8i_i2s_reg_defaults[] = {
+	{ SUN4I_I2S_REG_CTRL,		0x00060000 },
+	{ SUN4I_I2S_REG_FMT0,		0x00000033 },
+	{ SUN4I_I2S_REG_FMT1,		0x00000030 },
+	{ SUN4I_I2S_REG_FIFO_CTRL,	0x000400f0 },
+	{ SUN4I_I2S_REG_DMA_INT_CTRL,	0x00000000 },
+	{ SUN4I_I2S_REG_CLKDIV,		0x00000000 },
+	{ SUN8I_I2S_REG_CHAN_CFG,	0x00000000 },
+	{ SUN8I_I2S_REG_TX_CHAN_SEL,	0x00000000 },
+	{ SUN8I_I2S_REG_TX_CHAN_MAP,	0x00000000 },
+	{ SUN8I_I2S_REG_RX_CHAN_SEL,	0x00000000 },
+	{ SUN8I_I2S_REG_RX_CHAN_MAP,	0x00000000 },
+};
+
+static const struct regmap_config sun4i_i2s_regmap_config = {
+	.reg_bits		= 32,
+	.reg_stride		= 4,
+	.val_bits		= 32,
+	.max_register		= SUN4I_I2S_REG_RX_CHAN_MAP,
+	.cache_type		= REGCACHE_FLAT,
+	.reg_defaults		= sun4i_i2s_reg_defaults,
+	.num_reg_defaults	= ARRAY_SIZE(sun4i_i2s_reg_defaults),
+	.writeable_reg		= sun4i_i2s_writable_reg,
+	.readable_reg		= sun4i_i2s_readable_reg,
+	.volatile_reg		= sun4i_i2s_volatile_reg,
+};
+
+static const struct regmap_config sun8i_i2s_regmap_config = {
+	.reg_bits		= 32,
+	.reg_stride		= 4,
+	.val_bits		= 32,
+	.max_register		= SUN8I_I2S_REG_RX_CHAN_MAP,
+	.cache_type		= REGCACHE_FLAT,
+	.reg_defaults		= sun8i_i2s_reg_defaults,
+	.num_reg_defaults	= ARRAY_SIZE(sun8i_i2s_reg_defaults),
+	.writeable_reg		= sun4i_i2s_writable_reg,
+	.readable_reg		= sun8i_i2s_readable_reg,
+	.volatile_reg		= sun8i_i2s_volatile_reg,
+};
+
+static const struct reg_field sun4i_a10_i2s_reg_fields[REGMAP_NUM_FIELDS] = {
+	[FIELD_MCLK_OUT_EN]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 7, 7),
+	[FIELD_BCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 4, 6),
+	[FIELD_MCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 0, 3),
+	[FIELD_BCLK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 6, 6),
+	[FIELD_LRCK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 7, 7),
+	[FIELD_SIGN_EXT]	= REG_FIELD(SUN4I_I2S_REG_FMT1, 8, 8),
+	[FIELD_TX_CHAN_SEL]	= REG_FIELD(SUN4I_I2S_REG_TX_CHAN_SEL, 0, 2),
+	[FIELD_RX_CHAN_SEL]	= REG_FIELD(SUN4I_I2S_REG_RX_CHAN_SEL, 0, 2),
+	[FIELD_TX_CHAN_MAP]	= REG_FIELD(SUN4I_I2S_REG_TX_CHAN_MAP, 0, 31),
+	[FIELD_RX_CHAN_MAP]	= REG_FIELD(SUN4I_I2S_REG_RX_CHAN_MAP, 0, 31),
+};
+
+static const struct reg_field sun8i_h3_i2s_reg_fields[REGMAP_NUM_FIELDS] = {
+	[FIELD_MCLK_OUT_EN]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 8, 8),
+	[FIELD_BCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 4, 7),
+	[FIELD_MCLK_DIV]	= REG_FIELD(SUN4I_I2S_REG_CLKDIV, 0, 3),
+	[FIELD_BCLK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 7, 7),
+	[FIELD_LRCK_POLARITY]	= REG_FIELD(SUN4I_I2S_REG_FMT0, 19, 19),
+	[FIELD_SIGN_EXT]	= REG_FIELD(SUN4I_I2S_REG_FMT1, 4, 5),
+	[FIELD_TX_CHAN_SEL]	= REG_FIELD(SUN8I_I2S_REG_TX_CHAN_SEL, 0, 2),
+	[FIELD_RX_CHAN_SEL]	= REG_FIELD(SUN8I_I2S_REG_RX_CHAN_SEL, 0, 2),
+	[FIELD_TX_CHAN_MAP]	= REG_FIELD(SUN8I_I2S_REG_TX_CHAN_MAP, 0, 31),
+	[FIELD_RX_CHAN_MAP]	= REG_FIELD(SUN8I_I2S_REG_RX_CHAN_MAP, 0, 31),
+};
+
+#define SUN4I_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			 SNDRV_PCM_FMTBIT_S20_3LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE)
+
+#define SUN8I_FORMATS	(SUN4I_FORMATS | \
+			 SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct sun4i_i2s_quirks sun4i_a10_i2s_quirks = {
+	.has_reset		= 0,
+	.reg_offset_txdata	= SUN4I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+};
+
+static const struct sun4i_i2s_quirks sun6i_a31_i2s_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN4I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+};
+
+static const struct sun4i_i2s_quirks sun8i_a83t_i2s_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN8I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+};
+
+static struct sun4i_i2s_quirks sun8i_h3_i2s_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN8I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun8i_i2s_regmap_config,
+	.reg_fields		= sun8i_h3_i2s_reg_fields,
+
+	.bclk_div		= sun8i_i2s_clk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun8i_i2s_clk_div),
+	.mclk_div		= sun8i_i2s_clk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun8i_i2s_clk_div),
+
+	.bclk_parent		= BCLK_PARENT_PLL,
+
+	.playback_formats	= SUN8I_FORMATS,
+	.capture_formats	= SUN8I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun8i_i2s_set_format,
+	.set_hw_config		= sun8i_i2s_set_hw_config,
+};
+
+static const struct sun4i_i2s_quirks sun50i_a64_codec_i2s_quirks = {
+	.has_reset		= 1,
+	.reg_offset_txdata	= SUN8I_I2S_REG_TX_FIFO,
+	.regmap_cfg		= &sun4i_i2s_regmap_config,
+	.reg_fields		= sun4i_a10_i2s_reg_fields,
+
+	.bclk_div		= sun4i_i2s_bclk_div,
+	.num_bclkdiv		= ARRAY_SIZE(sun4i_i2s_bclk_div),
+	.mclk_div		= sun4i_i2s_mclk_div,
+	.num_mclkdiv		= ARRAY_SIZE(sun4i_i2s_mclk_div),
+
+	.playback_formats	= SUN4I_FORMATS,
+	.capture_formats	= SUN4I_FORMATS,
+
+	/* DAI configuration callbacks */
+	.set_format		= sun4i_i2s_set_format,
+	.set_hw_config		= sun4i_i2s_set_hw_config,
+};
+
 static const struct of_device_id sun4i_i2s_match[] = {
 	{
 		.compatible = "allwinner,sun4i-a10-i2s",
@@ -1218,19 +1536,19 @@ static const struct of_device_id sun4i_i2s_match[] = {
 		.compatible = "allwinner,sun50i-a64-codec-i2s",
 		.data = &sun50i_a64_codec_i2s_quirks,
 	},
-	{}
+	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, sun4i_i2s_match);
 
 static const struct dev_pm_ops sun4i_i2s_pm_ops = {
-	.runtime_resume		= sun4i_i2s_runtime_resume,
-	.runtime_suspend	= sun4i_i2s_runtime_suspend,
+	.runtime_resume	 = sun4i_i2s_runtime_resume,
+	.runtime_suspend = sun4i_i2s_runtime_suspend,
 };
 
 static struct platform_driver sun4i_i2s_driver = {
-	.probe	= sun4i_i2s_probe,
-	.remove	= sun4i_i2s_remove,
-	.driver	= {
+	.probe  = sun4i_i2s_probe,
+	.remove = sun4i_i2s_remove,
+	.driver = {
 		.name		= "sun4i-i2s",
 		.of_match_table	= sun4i_i2s_match,
 		.pm		= &sun4i_i2s_pm_ops,
@@ -1240,5 +1558,6 @@ module_platform_driver(sun4i_i2s_driver);
 
 MODULE_AUTHOR("Andrea Venturi <be17068@iperbole.bo.it>");
 MODULE_AUTHOR("Maxime Ripard <maxime.ripard@free-electrons.com>");
-MODULE_DESCRIPTION("Allwinner A10 I2S driver");
+MODULE_AUTHOR("Sergey Suloev <ssuloev@orpaltech.com>");
+MODULE_DESCRIPTION("Allwinner sunXi I2S interface driver");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sun4i-i2s.h b/sound/soc/sunxi/sun4i-i2s.h
new file mode 100644
index 0000000..f629709
--- /dev/null
+++ b/sound/soc/sunxi/sun4i-i2s.h
@@ -0,0 +1,234 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Allwinner sunXi I2S controller driver
+ *
+ * Copyright 2018 Sergey Suloev <ssuloev@orpaltech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_SUN4I_I2S_H
+#define __LINUX_SUN4I_I2S_H
+
+
+#define SUN4I_I2S_REG_CTRL		0x00	/* Control Register */
+#define  SUN4I_I2S_CTRL_SDO_EN_MASK		GENMASK(11,8)
+#define  SUN4I_I2S_CTRL_SDO_EN(lines)		(((1 << lines) - 1) << 8)
+#define  SUN4I_I2S_CTRL_SLAVE_MASK		BIT(5)
+#define  SUN4I_I2S_CTRL_SLAVE			(1 << 5)
+#define  SUN4I_I2S_CTRL_MASTER			(0 << 5)
+#define  SUN4I_I2S_CTRL_MODE_MASK		BIT(4)
+#define  SUN4I_I2S_CTRL_MODE_PCM		(1 << 4)
+#define  SUN4I_I2S_CTRL_MODE_I2S		(0 << 4)
+#define  SUN4I_I2S_CTRL_LOOPBACK		BIT(3)
+#define  SUN4I_I2S_CTRL_TX_EN			BIT(2)
+#define  SUN4I_I2S_CTRL_RX_EN			BIT(1)
+#define  SUN4I_I2S_CTRL_GLOB_EN			BIT(0)
+
+#define  SUN8I_I2S_CTRL_BCLK_OUT		BIT(18)
+#define  SUN8I_I2S_CTRL_LRCK_OUT		BIT(17)
+
+#define  SUN8I_I2S_CTRL_MODE_MASK		GENMASK(5,4)
+#define  SUN8I_I2S_CTRL_MODE_PCM		(0 << 4)
+#define  SUN8I_I2S_CTRL_MODE_LEFT_J		(1 << 4)
+#define  SUN8I_I2S_CTRL_MODE_RIGHT_J		(2 << 4)
+
+
+#define SUN4I_I2S_REG_FMT0		0x04	/* Format 0 Register */
+#define  SUN4I_I2S_FMT0_DSP_MODE_MASK		BIT(7)
+#define  SUN4I_I2S_FMT0_DSP_MODE_A		(0 << 7)
+#define  SUN4I_I2S_FMT0_DSP_MODE_B		(1 << 7)
+#define  SUN4I_I2S_FMT0_SR_MASK			GENMASK(5,4)
+#define  SUN4I_I2S_FMT0_SR(sr)			((sr) << 4)
+#define  SUN4I_I2S_FMT0_WSS_MASK		GENMASK(3,2)
+#define  SUN4I_I2S_FMT0_WSS(ws)			((ws) << 2)
+
+#define  SUN4I_I2S_FMT0_FMT_MASK		GENMASK(1,0)
+#define  SUN4I_I2S_FMT0_FMT_RIGHT_J		(2 << 0)
+#define  SUN4I_I2S_FMT0_FMT_LEFT_J		(1 << 0)
+#define  SUN4I_I2S_FMT0_FMT_I2S			(0 << 0)
+
+#define  SUN4I_I2S_POLARITY_INVERT		1
+#define  SUN4I_I2S_POLARITY_NORMAL		0
+
+#define  SUN8I_I2S_FMT0_SR_MASK			GENMASK(6,4)
+#define  SUN8I_I2S_FMT0_SR(sr)			((sr) << 4)
+#define  SUN8I_I2S_FMT0_SW_MASK			GENMASK(2,0)
+#define  SUN8I_I2S_FMT0_SW(sw)			((sw) << 0)
+
+#define  SUN8I_I2S_LRCK_PERIOD_MASK		GENMASK(17,8)
+#define  SUN8I_I2S_LRCK_PERIOD(prd)		((prd - 1) << 8)
+#define  SUN8I_I2S_LRCK_MAX_PERIOD		1024
+#define  SUN8I_I2S_LRCKR_PERIOD_MASK		GENMASK(29,20)
+#define  SUN8I_I2S_LRCKR_PERIOD(prd)		((prd - 1) << 20)
+
+#define  SUN8I_I2S_PCM_SYNC_WIDTH		BIT(30)
+#define  SUN8I_I2S_PCM_SYNC_SHORT		(0 << 30)	/*1 BCLK period*/
+#define  SUN8I_I2S_PCM_SYNC_LONG		(1 << 30)	/*2 BCLK period*/
+
+#define SUN4I_I2S_REG_FMT1		0x08	/* Format 1 Register */
+#define  SUN4I_I2S_PCM_SYNC_WIDTH		BIT(4)
+#define  SUN4I_I2S_PCM_SYNC_SHORT		(1 << 4)	/*1 BCLK period*/
+#define  SUN4I_I2S_PCM_SYNC_LONG		(0 << 4)	/*2 BCLK period*/
+#define  SUN4I_I2S_FMT1_SEXT_MASK		BIT(8)
+#define  SUN4I_I2S_FMT1_SEXT(sext)		((sext) << 8)
+#define  SUN4I_I2S_FMT1_SYNC_PERIOD_MASK	GENMASK(14,12)
+#define  SUN4I_I2S_FMT1_SYNC_PERIOD(prd)	((prd) << 12)
+
+
+#define SUN4I_I2S_REG_RX_FIFO		0x10	/* RX FIFO Register */
+
+
+#define SUN4I_I2S_REG_FIFO_CTRL		0x14	/* FIFO Control Register */
+#define  SUN4I_I2S_FIFO_CTRL_TX_IM_MASK		BIT(2)
+#define  SUN4I_I2S_FIFO_CTRL_TX_IM(mod)		((mod) << 2)
+#define  SUN4I_I2S_FIFO_CTRL_RX_OM_MASK		GENMASK(1,0)
+#define  SUN4I_I2S_FIFO_CTRL_RX_OM(mod)		((mod) << 0)
+#define  SUN4I_I2S_FIFO_RX_TL_MASK		GENMASK(9,4)
+#define  SUN4I_I2S_FIFO_RX_TL(tl)		((tl) << 4)
+#define  SUN4I_I2S_FIFO_TX_TL_MASK		GENMASK(18,12)
+#define  SUN4I_I2S_FIFO_TX_TL(tl)		((tl) << 12)
+#define  SUN4I_I2S_FIFO_FLUSH_TX		BIT(25)
+#define  SUN4I_I2S_FIFO_FLUSH_RX		BIT(24)
+
+
+#define SUN4I_I2S_REG_FIFO_STA		0x18	/* FIFO Status Register */
+
+
+#define SUN4I_I2S_REG_TX_FIFO		0x0c	/* TX FIFO Register */
+#define SUN8I_I2S_REG_TX_FIFO		0x20	/* TX FIFO Register */
+
+
+#define SUN4I_I2S_REG_INT_STA		0x20	/* Interrupt Status Register */
+#define SUN8I_I2S_REG_INT_STA		0x0c	/* Interrupt Status Register */
+
+
+#define SUN4I_I2S_REG_DMA_INT_CTRL	0x1c	/* Interrupt/DMA Control Register */
+#define  SUN4I_I2S_TX_DRQ_EN			BIT(7)
+#define  SUN4I_I2S_RX_DRQ_EN			BIT(3)
+
+
+#define SUN4I_I2S_REG_CLKDIV		0x24	/* Clock Divide Register */
+#define  SUN4I_I2S_CLKDIV_MCLK_EN		BIT(7)
+#define  SUN4I_I2S_CLKDIV_MCLK_MASK		GENMASK(3,0)
+#define  SUN4I_I2S_CLKDIV_MCLK(div)		((div) << 0)
+#define  SUN4I_I2S_CLKDIV_BCLK_MASK		GENMASK(6,4)
+#define  SUN4I_I2S_CLKDIV_BCLK(div)		((div) << 4)
+
+#define  SUN8I_I2S_CLKDIV_BCLK_MASK		GENMASK(7,4)
+#define  SUN8I_I2S_CLKDIV_MCLK_EN		BIT(8)
+
+
+#define SUN4I_I2S_REG_TX_COUNT		0x28	/* TX Sample Counter Register */
+#define SUN4I_I2S_REG_RX_COUNT		0x2c	/* RX Sample Counter Register */
+
+
+#define SUN8I_I2S_REG_CHAN_CFG		0x30
+#define  SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM_MASK	GENMASK(6,4)
+#define  SUN8I_I2S_CHAN_CFG_RX_SLOT_NUM(ch)	(((ch) - 1) << 4)
+#define  SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM_MASK	GENMASK(2,0)
+#define  SUN8I_I2S_CHAN_CFG_TX_SLOT_NUM(ch)	(((ch) - 1) << 0)
+
+
+#define SUN4I_I2S_REG_TX_CHAN_SEL	0x30	/* TX Channel Select Register */
+#define SUN4I_I2S_REG_RX_CHAN_SEL	0x38    /* RX Channel Select Register */
+#define SUN8I_I2S_REG_TX_CHAN_SEL	0x34
+#define SUN8I_I2S_REG_RX_CHAN_SEL	0x54
+#define  SUN8I_I2S_TX_CHAN_SEL_EN_MASK		GENMASK(11,4)
+#define  SUN8I_I2S_TX_CHAN_SEL_EN(ch)		(((1 << (ch)) - 1) << 4)
+#define  SUN4I_I2S_CHAN_SEL(num)		((num) - 1)
+#define  SUN8I_I2S_CHAN_SEL_OFFSET_MASK		GENMASK(13,12)
+#define  SUN8I_I2S_CHAN_SEL_OFFSET(off)		((off) << 12)
+
+
+#define SUN4I_I2S_REG_TX_CHAN_MAP	0x34	/* TX Channel Mapping Register */
+#define SUN4I_I2S_REG_RX_CHAN_MAP	0x3c	/* RX Channel Mapping Register */
+#define SUN8I_I2S_REG_TX_CHAN_MAP	0x44
+#define SUN8I_I2S_REG_RX_CHAN_MAP	0x58
+#define  SUN4I_I2S_CHAN_MAP(chan, samp)		((samp) << ((chan) << 2))
+
+
+/* regmap fields */
+enum {
+	FIELD_MCLK_OUT_EN,	/* MCLK Enable */
+
+	FIELD_BCLK_DIV,
+	FIELD_MCLK_DIV,
+
+	FIELD_BCLK_POLARITY,	/* BCLK Polarity */
+	FIELD_LRCK_POLARITY,	/* LRCK	Polarity */
+
+	FIELD_SIGN_EXT,		/* Sign Extend in slot */
+
+	FIELD_TX_CHAN_MAP,	/* TX Channel Mapping */
+	FIELD_RX_CHAN_MAP,	/* RX Channel Mapping */
+	FIELD_TX_CHAN_SEL,	/* TX Channel Select */
+	FIELD_RX_CHAN_SEL,	/* RX Channel Select */
+
+	/* Keep last */
+	REGMAP_NUM_FIELDS,
+};
+
+struct sun4i_i2s;
+
+struct sun4i_i2s_clkdiv {
+	u8	div;
+	u8	val;
+};
+
+enum {
+	BCLK_PARENT_MCLK,
+	BCLK_PARENT_PLL,
+};
+
+struct sun4i_i2s_quirks {
+	bool				has_reset;
+	u32				reg_offset_txdata;
+	const struct regmap_config	*regmap_cfg;
+	const struct reg_field		*reg_fields;
+
+	const struct sun4i_i2s_clkdiv	*bclk_div;
+	unsigned int			num_bclkdiv;
+
+	const struct sun4i_i2s_clkdiv	*mclk_div;
+	unsigned int			num_mclkdiv;
+
+	u32				playback_formats;
+	u32				capture_formats;
+
+	int				bclk_parent;
+
+	/* SoC-specific DAI configuration */
+	int (*set_format)(struct sun4i_i2s *i2s, u32 fmt);
+	int (*set_hw_config)(struct snd_soc_dai *dai,
+			     struct snd_pcm_hw_params *params);
+};
+
+struct sun4i_i2s {
+	struct device		*dev;
+	struct clk		*bus_clk;
+	struct clk		*mod_clk;
+	struct regmap		*regmap;
+	struct regmap_field	*fields[REGMAP_NUM_FIELDS];
+	struct reset_control	*rst;
+
+	bool		loopback;
+	bool		bit_clk_master;
+	bool		is_pcm;
+
+	unsigned long	mclk_rate;
+
+	u32		tdm_slots;
+	u32		slot_width;
+	u32		frame_length;
+
+	struct snd_dmaengine_dai_dma_data
+			dma_data[SNDRV_PCM_STREAM_LAST + 1];
+
+	const struct sun4i_i2s_quirks	*quirks;
+};
+
+#endif	// __LINUX_SUN4I_I2S_H
-- 
2.17.1

