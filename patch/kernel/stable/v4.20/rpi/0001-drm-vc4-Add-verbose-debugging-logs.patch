From 2aa084432b40cec847ba536489372359f26bfe07 Mon Sep 17 00:00:00 2001
From: Sergey Suloev <ssuloev@orpaltech.com>
Date: Sun, 23 Dec 2018 00:12:51 +0300
Subject: [PATCH] drm/vc4: Add verbose debugging logs

---
 drivers/gpu/drm/vc4/vc4_dsi.c | 81 ++++++++++++++++++++++++++++-------
 1 file changed, 66 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/vc4/vc4_dsi.c b/drivers/gpu/drm/vc4/vc4_dsi.c
index 0c607eb..a21ee81 100644
--- a/drivers/gpu/drm/vc4/vc4_dsi.c
+++ b/drivers/gpu/drm/vc4/vc4_dsi.c
@@ -29,6 +29,9 @@
  * hopefully present.
  */
 
+#define DEBUG
+
+
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_edid.h>
@@ -557,6 +560,8 @@ dsi_dma_workaround_write(struct vc4_dsi *dsi, u32 offset, u32 val)
 	dma_cookie_t cookie;
 	int ret;
 
+	dev_dbg(&dsi->pdev->dev, "dsi write\n");
+
 	/* DSI0 should be able to write normally. */
 	if (!chan) {
 		writel(val, dsi->regs + offset);
@@ -850,6 +855,9 @@ static bool vc4_dsi_encoder_mode_fixup(struct drm_encoder *encoder,
 	unsigned long pll_clock = pixel_clock_hz * dsi->divider;
 	int divider;
 
+	dev_dbg(&dsi->pdev->dev, "mode fixup, parent_rate = %d, pixel_clock_hz = %d, pll_clock = %d\n",
+               	parent_rate, pixel_clock_hz, pll_clock);
+
 	/* Find what divider gets us a faster clock than the requested
 	 * pixel clock.
 	 */
@@ -883,7 +891,7 @@ static void vc4_dsi_encoder_enable(struct drm_encoder *encoder)
 	struct vc4_dsi_encoder *vc4_encoder = to_vc4_dsi_encoder(encoder);
 	struct vc4_dsi *dsi = vc4_encoder->dsi;
 	struct device *dev = &dsi->pdev->dev;
-	bool debug_dump_regs = false;
+	bool debug_dump_regs = true;
 	unsigned long hs_clock;
 	u32 ui_ns;
 	/* Minimum LP state duration in escape clock cycles. */
@@ -893,6 +901,9 @@ static void vc4_dsi_encoder_enable(struct drm_encoder *encoder)
 	unsigned long phy_clock;
 	int ret;
 
+	dev_dbg(&dsi->pdev->dev, "encoder enable, pixel_clock_hz = %d, mode->htotal = %d, mode->hsync_start = %d, mode->hsync_end = %d\n",
+		pixel_clock_hz, mode->htotal, mode->hsync_start, mode->hsync_end);
+
 	ret = pm_runtime_get_sync(dev);
 	if (ret) {
 		DRM_ERROR("Failed to runtime PM enable on DSI%d\n", dsi->port);
@@ -1150,6 +1161,9 @@ static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
 	bool is_long = mipi_dsi_packet_format_is_long(msg->type);
 	u32 cmd_fifo_len = 0, pix_fifo_len = 0;
 
+	dev_dbg(&dsi->pdev->dev, "dsi host transfer, %s, type = %d, tx_len = %d, rx_len = %d\n",
+		(is_long?"long":"short"), msg->type, msg->tx_len, msg->rx_len);
+
 	mipi_dsi_create_packet(&packet, msg);
 
 	pkth |= VC4_SET_FIELD(packet.header[0], DSI_TXPKT1H_BC_DT);
@@ -1189,6 +1203,9 @@ static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
 				      DSI_TXPKT1C_CMD_CTRL);
 	}
 
+	dev_dbg(&dsi->pdev->dev, "dsi host transfer, cmd_fifo_len = %d, pix_fifo_len = %d\n",
+		cmd_fifo_len, pix_fifo_len);
+
 	for (i = 0; i < cmd_fifo_len; i++)
 		DSI_PORT_WRITE(TXPKT_CMD_FIFO, packet.payload[i]);
 	for (i = 0; i < pix_fifo_len; i++) {
@@ -1280,6 +1297,8 @@ static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
 		}
 	}
 
+	dev_dbg(&dsi->pdev->dev, "dsi host transfer complete\n");
+
 	return ret;
 
 reset_fifo_and_return:
@@ -1305,6 +1324,8 @@ static int vc4_dsi_host_attach(struct mipi_dsi_host *host,
 	dsi->channel = device->channel;
 	dsi->mode_flags = device->mode_flags;
 
+	dev_dbg(&dsi->pdev->dev, "dsi host attach\n");
+
 	switch (device->format) {
 	case MIPI_DSI_FMT_RGB888:
 		dsi->format = DSI_PFORMAT_RGB888;
@@ -1398,6 +1419,8 @@ static irqreturn_t vc4_dsi_irq_handler(int irq, void *data)
 	u32 stat = DSI_PORT_READ(INT_STAT);
 	irqreturn_t ret = IRQ_NONE;
 
+	dev_dbg(&dsi->pdev->dev, "irq handler\n");
+
 	DSI_PORT_WRITE(INT_STAT, stat);
 
 	dsi_handle_error(dsi, &ret, stat,
@@ -1420,10 +1443,12 @@ static irqreturn_t vc4_dsi_irq_handler(int irq, void *data)
 	if (stat & (DSI1_INT_TXPKT1_DONE | DSI1_INT_PHY_DIR_RTF)) {
 		complete(&dsi->xfer_completion);
 		ret = IRQ_HANDLED;
+		dev_dbg(&dsi->pdev->dev, "irq is ok\n");
 	} else if (stat & DSI1_INT_HSTX_TO) {
 		complete(&dsi->xfer_completion);
 		dsi->xfer_result = -ETIMEDOUT;
 		ret = IRQ_HANDLED;
+		dev_dbg(&dsi->pdev->dev, "irq timed out\n");
 	}
 
 	return ret;
@@ -1509,6 +1534,8 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 	dma_cap_mask_t dma_mask;
 	int ret;
 
+	dev_dbg(dev, "DSI bind\n");
+
 	match = of_match_device(vc4_dsi_dt_match, dev);
 	if (!match)
 		return -ENODEV;
@@ -1583,7 +1610,7 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 	if (ret) {
 		if (ret != -EPROBE_DEFER)
 			dev_err(dev, "Failed to get interrupt: %d\n", ret);
-		return ret;
+		goto err_release_dma;
 	}
 
 	dsi->escape_clock = devm_clk_get(dev, "escape");
@@ -1591,7 +1618,7 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 		ret = PTR_ERR(dsi->escape_clock);
 		if (ret != -EPROBE_DEFER)
 			dev_err(dev, "Failed to get escape clock: %d\n", ret);
-		return ret;
+		goto err_release_dma;
 	}
 
 	dsi->pll_phy_clock = devm_clk_get(dev, "phy");
@@ -1599,7 +1626,7 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 		ret = PTR_ERR(dsi->pll_phy_clock);
 		if (ret != -EPROBE_DEFER)
 			dev_err(dev, "Failed to get phy clock: %d\n", ret);
-		return ret;
+		goto err_release_dma;
 	}
 
 	dsi->pixel_clock = devm_clk_get(dev, "pixel");
@@ -1607,41 +1634,52 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 		ret = PTR_ERR(dsi->pixel_clock);
 		if (ret != -EPROBE_DEFER)
 			dev_err(dev, "Failed to get pixel clock: %d\n", ret);
-		return ret;
+		goto err_release_dma;
 	}
 
+	dev_dbg(dev, "try to find a panel\n");
+
 	ret = drm_of_find_panel_or_bridge(dev->of_node, 0, 0,
 					  &panel, &dsi->bridge);
 	if (ret) {
+		dev_dbg(dev, "couldn't find a panel\n");
+
 		/* If the bridge or panel pointed by dev->of_node is not
 		 * enabled, just return 0 here so that we don't prevent the DRM
 		 * dev from being registered. Of course that means the DSI
 		 * encoder won't be exposed, but that's not a problem since
 		 * nothing is connected to it.
 		 */
-		if (ret == -ENODEV)
-			return 0;
+		if (ret == -ENODEV) {
+			ret = 0;
+		}
 
-		return ret;
+		goto err_release_dma;
 	}
 
 	if (panel) {
+
+		dev_dbg(dev, "add panel\n");
+
 		dsi->bridge = devm_drm_panel_bridge_add(dev, panel,
 							DRM_MODE_CONNECTOR_DSI);
-		if (IS_ERR(dsi->bridge))
-			return PTR_ERR(dsi->bridge);
+		if (IS_ERR(dsi->bridge)) {
+			ret = PTR_ERR(dsi->bridge);
+			goto err_release_dma;
+		}
 	}
 
 	/* The esc clock rate is supposed to always be 100Mhz. */
 	ret = clk_set_rate(dsi->escape_clock, 100 * 1000000);
 	if (ret) {
 		dev_err(dev, "Failed to set esc clock: %d\n", ret);
-		return ret;
+		goto err_release_dma;
 	}
 
 	ret = vc4_dsi_init_phy_clocks(dsi);
-	if (ret)
-		return ret;
+	if (ret) {
+		goto err_release_dma;
+	}
 
 	if (dsi->port == 1)
 		vc4->dsi1 = dsi;
@@ -1653,7 +1691,7 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 	ret = drm_bridge_attach(dsi->encoder, dsi->bridge, NULL);
 	if (ret) {
 		dev_err(dev, "bridge attach failed: %d\n", ret);
-		return ret;
+		goto err_release_dma;
 	}
 	/* Disable the atomic helper calls into the bridge.  We
 	 * manually call the bridge pre_enable / enable / etc. calls
@@ -1664,7 +1702,15 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 
 	pm_runtime_enable(dev);
 
+	dev_dbg(dev, "DSI bind complete\n");
+
 	return 0;
+
+err_release_dma:
+	if (dsi->port == 1)
+		dma_release_channel(dsi->reg_dma_chan);
+
+	return ret;
 }
 
 static void vc4_dsi_unbind(struct device *dev, struct device *master,
@@ -1679,8 +1725,11 @@ static void vc4_dsi_unbind(struct device *dev, struct device *master,
 
 	vc4_dsi_encoder_destroy(dsi->encoder);
 
-	if (dsi->port == 1)
+	if (dsi->port == 1) {
+		dma_release_channel(dsi->reg_dma_chan);
+
 		vc4->dsi1 = NULL;
+	}
 }
 
 static const struct component_ops vc4_dsi_ops = {
@@ -1714,6 +1763,8 @@ static int vc4_dsi_dev_probe(struct platform_device *pdev)
 	dsi->dsi_host.dev = dev;
 	mipi_dsi_host_register(&dsi->dsi_host);
 
+	dev_dbg(dev, "add component\n");
+
 	ret = component_add(&pdev->dev, &vc4_dsi_ops);
 	if (ret) {
 		mipi_dsi_host_unregister(&dsi->dsi_host);
-- 
2.17.1

