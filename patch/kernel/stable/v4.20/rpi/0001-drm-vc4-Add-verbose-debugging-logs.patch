From 7435cfbae1d45893e102f0334ec4a336f08da4aa Mon Sep 17 00:00:00 2001
From: Sergey Suloev <ssuloev@orpaltech.com>
Date: Mon, 19 Nov 2018 01:19:18 +0300
Subject: [PATCH] drm/vc4: Add verbose debugging logs

---
 drivers/gpu/drm/vc4/vc4_dsi.c | 40 ++++++++++++++++++++++++++++++++++-
 1 file changed, 39 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/vc4/vc4_dsi.c b/drivers/gpu/drm/vc4/vc4_dsi.c
index 0c607eb..11aecc2 100644
--- a/drivers/gpu/drm/vc4/vc4_dsi.c
+++ b/drivers/gpu/drm/vc4/vc4_dsi.c
@@ -29,6 +29,9 @@
  * hopefully present.
  */
 
+#define DEBUG
+
+
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_edid.h>
@@ -557,6 +560,8 @@ dsi_dma_workaround_write(struct vc4_dsi *dsi, u32 offset, u32 val)
 	dma_cookie_t cookie;
 	int ret;
 
+	dev_dbg(&dsi->pdev->dev, "dsi write\n");
+
 	/* DSI0 should be able to write normally. */
 	if (!chan) {
 		writel(val, dsi->regs + offset);
@@ -850,6 +855,9 @@ static bool vc4_dsi_encoder_mode_fixup(struct drm_encoder *encoder,
 	unsigned long pll_clock = pixel_clock_hz * dsi->divider;
 	int divider;
 
+	dev_dbg(&dsi->pdev->dev, "mode fixup, parent_rate = %d, pixel_clock_hz = %d, pll_clock = %d\n",
+               	parent_rate, pixel_clock_hz, pll_clock);
+
 	/* Find what divider gets us a faster clock than the requested
 	 * pixel clock.
 	 */
@@ -883,7 +891,7 @@ static void vc4_dsi_encoder_enable(struct drm_encoder *encoder)
 	struct vc4_dsi_encoder *vc4_encoder = to_vc4_dsi_encoder(encoder);
 	struct vc4_dsi *dsi = vc4_encoder->dsi;
 	struct device *dev = &dsi->pdev->dev;
-	bool debug_dump_regs = false;
+	bool debug_dump_regs = true;
 	unsigned long hs_clock;
 	u32 ui_ns;
 	/* Minimum LP state duration in escape clock cycles. */
@@ -893,6 +901,9 @@ static void vc4_dsi_encoder_enable(struct drm_encoder *encoder)
 	unsigned long phy_clock;
 	int ret;
 
+	dev_dbg(&dsi->pdev->dev, "encoder enable, pixel_clock_hz = %d, mode->htotal = %d, mode->hsync_start = %d, mode->hsync_end = %d\n",
+		pixel_clock_hz, mode->htotal, mode->hsync_start, mode->hsync_end);
+
 	ret = pm_runtime_get_sync(dev);
 	if (ret) {
 		DRM_ERROR("Failed to runtime PM enable on DSI%d\n", dsi->port);
@@ -1150,6 +1161,9 @@ static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
 	bool is_long = mipi_dsi_packet_format_is_long(msg->type);
 	u32 cmd_fifo_len = 0, pix_fifo_len = 0;
 
+	dev_dbg(&dsi->pdev->dev, "dsi host transfer, %s, type = %d, tx_len = %d, rx_len = %d\n",
+		(is_long?"long":"short"), msg->type, msg->tx_len, msg->rx_len);
+
 	mipi_dsi_create_packet(&packet, msg);
 
 	pkth |= VC4_SET_FIELD(packet.header[0], DSI_TXPKT1H_BC_DT);
@@ -1189,6 +1203,9 @@ static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
 				      DSI_TXPKT1C_CMD_CTRL);
 	}
 
+	dev_dbg(&dsi->pdev->dev, "dsi host transfer, cmd_fifo_len = %d, pix_fifo_len = %d\n",
+		cmd_fifo_len, pix_fifo_len);
+
 	for (i = 0; i < cmd_fifo_len; i++)
 		DSI_PORT_WRITE(TXPKT_CMD_FIFO, packet.payload[i]);
 	for (i = 0; i < pix_fifo_len; i++) {
@@ -1280,6 +1297,8 @@ static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
 		}
 	}
 
+	dev_dbg(&dsi->pdev->dev, "dsi host transfer complete\n");
+
 	return ret;
 
 reset_fifo_and_return:
@@ -1305,6 +1324,8 @@ static int vc4_dsi_host_attach(struct mipi_dsi_host *host,
 	dsi->channel = device->channel;
 	dsi->mode_flags = device->mode_flags;
 
+	dev_dbg(&dsi->pdev->dev, "dsi host attach\n");
+
 	switch (device->format) {
 	case MIPI_DSI_FMT_RGB888:
 		dsi->format = DSI_PFORMAT_RGB888;
@@ -1398,6 +1419,8 @@ static irqreturn_t vc4_dsi_irq_handler(int irq, void *data)
 	u32 stat = DSI_PORT_READ(INT_STAT);
 	irqreturn_t ret = IRQ_NONE;
 
+	dev_dbg(&dsi->pdev->dev, "irq handler\n");
+
 	DSI_PORT_WRITE(INT_STAT, stat);
 
 	dsi_handle_error(dsi, &ret, stat,
@@ -1420,10 +1443,12 @@ static irqreturn_t vc4_dsi_irq_handler(int irq, void *data)
 	if (stat & (DSI1_INT_TXPKT1_DONE | DSI1_INT_PHY_DIR_RTF)) {
 		complete(&dsi->xfer_completion);
 		ret = IRQ_HANDLED;
+		dev_dbg(&dsi->pdev->dev, "irq is ok\n");
 	} else if (stat & DSI1_INT_HSTX_TO) {
 		complete(&dsi->xfer_completion);
 		dsi->xfer_result = -ETIMEDOUT;
 		ret = IRQ_HANDLED;
+		dev_dbg(&dsi->pdev->dev, "irq timed out\n");
 	}
 
 	return ret;
@@ -1509,6 +1534,8 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 	dma_cap_mask_t dma_mask;
 	int ret;
 
+	dev_dbg(dev, "DSI bind\n");
+
 	match = of_match_device(vc4_dsi_dt_match, dev);
 	if (!match)
 		return -ENODEV;
@@ -1610,9 +1637,13 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 		return ret;
 	}
 
+	dev_dbg(dev, "try to find a panel\n");
+
 	ret = drm_of_find_panel_or_bridge(dev->of_node, 0, 0,
 					  &panel, &dsi->bridge);
 	if (ret) {
+		dev_dbg(dev, "couldn't find a panel\n");
+
 		/* If the bridge or panel pointed by dev->of_node is not
 		 * enabled, just return 0 here so that we don't prevent the DRM
 		 * dev from being registered. Of course that means the DSI
@@ -1626,6 +1657,9 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 	}
 
 	if (panel) {
+
+		dev_dbg(dev, "add panel\n");
+
 		dsi->bridge = devm_drm_panel_bridge_add(dev, panel,
 							DRM_MODE_CONNECTOR_DSI);
 		if (IS_ERR(dsi->bridge))
@@ -1664,6 +1698,8 @@ static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
 
 	pm_runtime_enable(dev);
 
+	dev_dbg(dev, "DSI bind complete\n");
+
 	return 0;
 }
 
@@ -1714,6 +1750,8 @@ static int vc4_dsi_dev_probe(struct platform_device *pdev)
 	dsi->dsi_host.dev = dev;
 	mipi_dsi_host_register(&dsi->dsi_host);
 
+	dev_dbg(dev, "add component\n");
+
 	ret = component_add(&pdev->dev, &vc4_dsi_ops);
 	if (ret) {
 		mipi_dsi_host_unregister(&dsi->dsi_host);
-- 
2.17.1

